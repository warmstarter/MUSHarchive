<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Code: MUSH Manual - Section V: The Art of Psychocoding</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <!-- Apple devices fullscreen -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <!-- Apple devices fullscreen -->
    <meta names="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <!-- Bootstrap -->
	<link rel="stylesheet" href="../Theme/Flat/html/css/bootstrap.min.css">
	<!-- Bootstrap responsive -->
	<link rel="stylesheet" href="../Theme/Flat/html/css/bootstrap-responsive.min.css">
	<!-- jQuery UI -->
	<link rel="stylesheet" href="../Theme/Flat/html/css/plugins/jquery-ui/smoothness/jquery-ui.css">
	<link rel="stylesheet" href="../Theme/Flat/html/css/plugins/jquery-ui/smoothness/jquery.ui.theme.css">
	<!-- Theme CSS -->
	<link rel="stylesheet" href="../Theme/Flat/html/css/style.css">
	<!-- Color CSS -->
	<link rel="stylesheet" href="../Theme/Flat/html/css/themes.css">


    <link rel="stylesheet" href="../Content/site.css">

    <!-- jQuery -->
    <script src="../Theme/Flat/html/js/jquery.min.js"></script>
    <!-- Nice Scroll -->
    <script src="../Theme/Flat/html/js/plugins/nicescroll/jquery.nicescroll.min.js"></script>
    <!-- jQuery UI -->
    <script src="../Theme/Flat/html/js/plugins/jquery-ui/jquery.ui.core.min.js"></script>
    <script src="../Theme/Flat/html/js/plugins/jquery-ui/jquery.ui.widget.min.js"></script>
    <script src="../Theme/Flat/html/js/plugins/jquery-ui/jquery.ui.mouse.min.js"></script>
    <script src="../Theme/Flat/html/js/plugins/jquery-ui/jquery.ui.resizable.min.js"></script>
    <script src="../Theme/Flat/html/js/plugins/jquery-ui/jquery.ui.sortable.min.js"></script>
    <!-- slimScroll -->
    <script src="../Theme/Flat/html/js/plugins/slimscroll/jquery.slimscroll.min.js"></script>
    <!-- Bootstrap -->
    <script src="../Theme/Flat/html/js/bootstrap.min.js"></script>
    <!-- Form -->
    <script src="../Theme/Flat/html/js/plugins/form/jquery.form.min.js"></script>

    <!-- Theme framework -->
    <script src="../Theme/Flat/html/js/eakroko.min.js"></script>
    <!-- Theme scripts -->
    <script src="../Theme/Flat/html/js/application.min.js"></script>

    <!--[if lte IE 9]>
		<script src="js/plugins/placeholder/jquery.placeholder.min.js"></script>
		<script>
			$(document).ready(function() {
				$('input, textarea').placeholder();
			});
		</script>
	<![endif]-->

    <!-- Favicon -->
    <link rel="shortcut icon" href="http://www.mushcode.com/File/img/favicon.ico" />
    <!-- Apple devices Homescreen icon -->
    <link rel="apple-touch-icon-precomposed" href="http://www.mushcode.com/File/img/apple-touch-icon-precomposed.png" />

</head>

<body class="theme-green">
    <div id="navigation">
        <div class="container-fluid">
            <a href="../index.html" id="brand">MUSHCode.com</a>
        </div>
    </div>
    <div class="container-fluid" id="content">
        <div id="left">
            <div class="subnav">
                <div class="subnav-title">
                    <a href="MUSH-Manual---Section-VColon-The-Art-of-Psychocoding.html#" class='toggle-subnav'>
                        <i class="icon-angle-down"></i>
                        <span>About</span>
                    </a>
                </div>
                <ul class="subnav-menu">
                    <li>
                        <a href="../index.html">Overview</a>
                    </li>
                </ul>
            </div>
            <div class="subnav">
                <div class="subnav-title">
                    <a href="MUSH-Manual---Section-VColon-The-Art-of-Psychocoding.html#" class='toggle-subnav'>
                        <i class="icon-angle-down"></i>
                        <span>Files</span>
                    </a>
                </div>
                <ul class="subnav-menu">
                    <li class='dropdown'>
                        <a href="MUSH-Manual---Section-VColon-The-Art-of-Psychocoding.html#" data-toggle="dropdown">Code</a>
                        
<ul class="dropdown-menu">
        <li>
            <a href="../Category/Administration.html">Administration</a>
        </li>
        <li>
            <a href="../Category/Building.html">Building</a>
        </li>
        <li>
            <a href="../Category/Bulletin-Board.html">Bulletin Board</a>
        </li>
        <li>
            <a href="../Category/Combat.html">Combat</a>
        </li>
        <li>
            <a href="../Category/Dynamic-Space.html">Dynamic Space</a>
        </li>
        <li>
            <a href="../Category/Fonts.html">Fonts</a>
        </li>
        <li>
            <a href="../Category/Functions.html">Functions</a>
        </li>
        <li>
            <a href="../Category/Games.html">Games</a>
        </li>
        <li>
            <a href="../Category/Globals.html">Globals</a>
        </li>
        <li>
            <a href="../Category/Mail-Systems.html">Mail Systems</a>
        </li>
        <li>
            <a href="../Category/Other.html">Other</a>
        </li>
        <li>
            <a href="../Category/Schedulers.html">Schedulers</a>
        </li>
        <li>
            <a href="../Category/Time.html">Time</a>
        </li>
        <li>
            <a href="../Category/Vehicles.html">Vehicles</a>
        </li>
        <li>
            <a href="../Category/Vendors.html">Vendors</a>
        </li>
        <li>
            <a href="../Category/Weather-Systems.html">Weather Systems</a>
        </li>
</ul>
                    </li>
                    <li class='dropdown'>
                        <a href="MUSH-Manual---Section-VColon-The-Art-of-Psychocoding.html#" data-toggle="dropdown">Classes</a>
                        
<ul class="dropdown-menu">
        <li>
            <a href="../Category/Administration.html">Administration</a>
        </li>
        <li>
            <a href="../Category/Building.html">Building</a>
        </li>
        <li>
            <a href="../Category/Globals.html">Globals</a>
        </li>
        <li>
            <a href="../Category/Hardcode.html">Hardcode</a>
        </li>
        <li>
            <a href="../Category/Other.html">Other</a>
        </li>
        <li>
            <a href="../Category/Softcode.html">Softcode</a>
        </li>
</ul>
                    </li>
                    <li>
                        <a href="../Manuals.html">Manuals</a>
                    </li>
                </ul>
            </div>
            <div class="subnav">
                <div class="subnav-title">
                    <a href="MUSH-Manual---Section-VColon-The-Art-of-Psychocoding.html#" class='toggle-subnav'>
                        <i class="icon-angle-down"></i>
                        <span>Misc</span>
                    </a>
                </div>
                <ul class="subnav-menu">
                    <li>
                        <a href="../Ascii2Mu.html">ASCII To MUSHCode</a>
                    </li>
                    <li>
                        <a href="../MushList.html">MUSH/MUX List</a>
                    </li>
                    <li>
                        <a href="../MushRoom.html">MUSHRoom</a>
                    </li>
                </ul>
            </div>
            <div class="subnav">
                <div class="subnav-title">
                    <a href="MUSH-Manual---Section-VColon-The-Art-of-Psychocoding.html#" class='toggle-subnav'>
                        <i class="icon-angle-down"></i>
                        <span>Contribute</span>
                    </a>
                </div>
                <ul class="subnav-menu">
                    <li>
                        <a href="../Submit.html">Submit</a>
                    </li>
                </ul>
            </div>
        </div>
        <div id="main">
            <div class="container-fluid">
                <div class="breadcrumbs">
                    <ul>
                        
    <li>
        <a href="../index.html">Home</a>
        <i class="icon-angle-right"></i>
    </li>
    <li>
        <a href="../Category/Softcode.html">Softcode</a>
        <i class="icon-angle-right"></i>
    </li>
    <li>
        <a href="MUSH-Manual---Section-VColon-The-Art-of-Psychocoding.html#">MUSH Manual - Section V: The Art of Psychocoding</a>
    </li>

                    </ul>
                </div>
                <div class="row-fluid">
                    <div class="span12">
                        



<div class="box">
    <div class="box-title title">
        <h2>
            MUSH Manual - Section V: The Art of Psychocoding
        </h2>
    </div>
    <div class="box-content">

        <div class="description">
            <p></p>
        </div>

        <div class="author">
            <strong>Author:</strong>
                <a href="../Author/Amberyl.html">Amberyl</a>
        </div>

        <div class="author">
            <strong>Category:</strong>
            <a href="../Category/Softcode.html">Softcode</a>
        </div>

            <div class="commands">
            <strong>Commands:</strong>
                    <a href="http://www.mushcode.com/Command/@describe" class="command">@describe</a>,
                    <a href="http://www.mushcode.com/Command/@dolist" class="command">@dolist</a>,
                    <a href="http://www.mushcode.com/Command/@emit" class="command">@emit</a>,
                    <a href="../Command/@function.html" class="command">@function</a>,
                    <a href="http://www.mushcode.com/Command/@pemit" class="command">@pemit</a>,
                    <a href="http://www.mushcode.com/Command/@switch" class="command">@switch</a>,
                    <a href="http://www.mushcode.com/Command/@trigger" class="command">@trigger</a>,
                    <a href="http://www.mushcode.com/Command/@va" class="command">@va</a>,
                    <a href="http://www.mushcode.com/Command/@vb" class="command">@vb</a>.
            </div>

            <div class="functions">
                <strong>Functions:</strong>
                        <a href="../Function/add.html" class="function">add&#40;&#41;</a>,
                        <a href="../Function/and.html" class="function">and&#40;&#41;</a>,
                        <a href="../Function/comp.html" class="function">comp&#40;&#41;</a>,
                        <a href="../Function/create.html" class="function">create&#40;&#41;</a>,
                        <a href="../Function/default.html" class="function">default&#40;&#41;</a>,
                        <a href="../Function/delete.html" class="function">delete&#40;&#41;</a>,
                        <a href="../Function/edefault.html" class="function">edefault&#40;&#41;</a>,
                        <a href="../Function/edit.html" class="function">edit&#40;&#41;</a>,
                        <a href="../Function/eq.html" class="function">eq&#40;&#41;</a>,
                        <a href="../Function/extract.html" class="function">extract&#40;&#41;</a>,
                        <a href="../Function/filter.html" class="function">filter&#40;&#41;</a>,
                        <a href="../Function/first.html" class="function">first&#40;&#41;</a>,
                        <a href="../Function/fold.html" class="function">fold&#40;&#41;</a>,
                        <a href="../Function/get.html" class="function">get&#40;&#41;</a>,
                        <a href="../Function/get_eval.html" class="function">get_eval&#40;&#41;</a>,
                        <a href="../Function/gt.html" class="function">gt&#40;&#41;</a>,
                        <a href="../Function/gte.html" class="function">gte&#40;&#41;</a>,
                        <a href="../Function/hasattr.html" class="function">hasattr&#40;&#41;</a>,
                        <a href="../Function/insert.html" class="function">insert&#40;&#41;</a>,
                        <a href="../Function/iter.html" class="function">iter&#40;&#41;</a>,
                        <a href="../Function/lattr.html" class="function">lattr&#40;&#41;</a>,
                        <a href="../Function/lcon.html" class="function">lcon&#40;&#41;</a>,
                        <a href="../Function/ldelete.html" class="function">ldelete&#40;&#41;</a>,
                        <a href="../Function/ljust.html" class="function">ljust&#40;&#41;</a>,
                        <a href="../Function/lnum.html" class="function">lnum&#40;&#41;</a>,
                        <a href="../Function/lte.html" class="function">lte&#40;&#41;</a>,
                        <a href="../Function/match.html" class="function">match&#40;&#41;</a>,
                        <a href="../Function/max.html" class="function">max&#40;&#41;</a>,
                        <a href="../Function/member.html" class="function">member&#40;&#41;</a>,
                        <a href="../Function/mid.html" class="function">mid&#40;&#41;</a>,
                        <a href="../Function/mod.html" class="function">mod&#40;&#41;</a>,
                        <a href="../Function/mul.html" class="function">mul&#40;&#41;</a>,
                        <a href="../Function/name.html" class="function">name&#40;&#41;</a>,
                        <a href="../Function/not.html" class="function">not&#40;&#41;</a>,
                        <a href="../Function/num.html" class="function">num&#40;&#41;</a>,
                        <a href="../Function/or.html" class="function">or&#40;&#41;</a>,
                        <a href="../Function/owner.html" class="function">owner&#40;&#41;</a>,
                        <a href="../Function/r.html" class="function">r&#40;&#41;</a>,
                        <a href="../Function/rand.html" class="function">rand&#40;&#41;</a>,
                        <a href="../Function/remove.html" class="function">remove&#40;&#41;</a>,
                        <a href="../Function/repeat.html" class="function">repeat&#40;&#41;</a>,
                        <a href="../Function/replace.html" class="function">replace&#40;&#41;</a>,
                        <a href="../Function/rest.html" class="function">rest&#40;&#41;</a>,
                        <a href="../Function/revwords.html" class="function">revwords&#40;&#41;</a>,
                        <a href="../Function/rjust.html" class="function">rjust&#40;&#41;</a>,
                        <a href="../Function/s.html" class="function">s&#40;&#41;</a>,
                        <a href="../Function/setdiff.html" class="function">setdiff&#40;&#41;</a>,
                        <a href="../Function/setinter.html" class="function">setinter&#40;&#41;</a>,
                        <a href="../Function/setq.html" class="function">setq&#40;&#41;</a>,
                        <a href="../Function/setunion.html" class="function">setunion&#40;&#41;</a>,
                        <a href="../Function/shuffle.html" class="function">shuffle&#40;&#41;</a>,
                        <a href="../Function/space.html" class="function">space&#40;&#41;</a>,
                        <a href="../Function/squish.html" class="function">squish&#40;&#41;</a>,
                        <a href="../Function/strcat.html" class="function">strcat&#40;&#41;</a>,
                        <a href="../Function/strlen.html" class="function">strlen&#40;&#41;</a>,
                        <a href="../Function/sub.html" class="function">sub&#40;&#41;</a>,
                        <a href="../Function/switch.html" class="function">switch&#40;&#41;</a>,
                        <a href="../Function/u.html" class="function">u&#40;&#41;</a>,
                        <a href="../Function/udefault.html" class="function">udefault&#40;&#41;</a>,
                        <a href="../Function/ulocal.html" class="function">ulocal&#40;&#41;</a>,
                        <a href="../Function/v.html" class="function">v&#40;&#41;</a>,
                        <a href="../Function/words.html" class="function">words&#40;&#41;</a>.
            </div>


            <div class="servers">
                <strong>Compatibility:</strong>
                        <a href="../Server/CobraMUSH.html" class="server">CobraMUSH</a>,
                        <a href="../Server/PennMUSH.html" class="server">PennMUSH</a>,
                        <a href="../Server/TinyBit.html" class="server">TinyBit</a>.
            </div>

    </div>
</div>


<div class="box box-bordered box-condensed">
    <div class="box-title">
        <h3>
	        <i class="icon-reorder"></i>
	        MUSHCode for MUSH Manual - Section V: The Art of Psychocoding
        </h3>
        <div class="actions">
	        <a class="btn btn-mini select-all" href="MUSH-Manual---Section-VColon-The-Art-of-Psychocoding.html#">
                    <i class="icon-resize-full"></i> Select Content
            </a>
        </div>
    </div>
    <div id="code" class="box-content content">
        MUSH Manual Version 2.008:<br/>   Copyright 1993, 1994, 1995, Lydia Leong (lwl@netcom.com / Amberyl)<br/>   Last revised 5/22/95.<br/><br/>Section V: The Art of Psychocoding<br/><br/>13. Basic Concepts<br/>  13.1  Attribute naming and coding style<br/>  13.2  String concatenation and the switchless style<br/>  13.3  What the parser really does<br/>  13.4  Zones in TinyMUSH 2.2<br/>14. Tricks of the Trade<br/>  14.1  Adding to, removing from, and comparing lists<br/>  14.2  Function building blocks: U() and SWITCH(), DEFAULT(), @function<br/>  14.3  Formatting strings: SPACE(), REPEAT(), LJUST(), and RJUST()<br/>  14.4  Lists instead of @dolists: ITER() and FILTER()<br/>  14.5  Recursion: theory and practice, FOLD()<br/>15. Efficiency<br/>  15.1  Parameter passing: U(), ULOCAL(), local registers, SETQ(), and R()<br/>  15.2  How the queue works<br/>  15.3  Pipelining<br/>  15.4  Queue cycles vs. CPU cycles<br/><br/><br/>Unlike the rest of this MUSH manual, this section is intended for<br/>the programmer who already has some experience coding MUSH. Nonetheless,<br/>newcomers to MUSH might find it helpful to scan through this section, <br/>especially the "Basic Concepts". Familiarity with MUSH terminology, <br/>major commands, and important functions is assumed.<br/><br/>It is suggested that the reader be on-line while reading this manual,<br/>with access to the help text for the various functions and the ability<br/>to test out anything which doesn't seem clear. Some of the functions<br/>are not explained in gory syntactic detail, since the help text does<br/>exactly that; the purpose of this manual is to provide information<br/>that is not found in the help, and, thus, concentrates on style,<br/>techniques, and quirks that are not immediately obvious.<br/><br/><br/>---------------------------------------------------------------------------<br/>	<br/><br/>13. Basic Concepts<br/><br/><br/>13.1	Attribute naming and coding style<br/><br/>A user of MUSH once complained that most MUSH code "looks like<br/>line noise".  It's quite possible to write totally unreadable MUSH code;<br/>even with the introduction of the "@@" comment, almost nobody ever comments<br/>their MUSH code, either via "@@" or via attributes which explain what the <br/>object is supposed to do and how it does it. Code that is already difficult<br/>to fathom is made even more incomprehensible by semi-random naming of <br/>attributes and lack of whitespace.<br/><br/>* * * * *<br/><br/>Attributes should be named intelligently and consistently. One<br/>useful naming convention is to call any attribute which contains a $command<br/>DO_&lt;name of command&gt;; for example, an attribute with a "scan" command<br/>might be called DO_SCAN. Any attributes triggered by that command<br/>would be called SCAN1, SCAN2, etc.  Some people may prefer to place<br/>the $command in SCAN0; this makes it simple to see everything $scan<br/>related by doing an "examine object/SCAN*". <br/><br/>User-defined functions used by the $scan command might be named<br/>as SCAN_&lt;descriptive name&gt;_FN, such as "SCAN_FLAGS_FN".  Temporary<br/>registers set by $scan might be called SCAN_&lt;descriptive name&gt;_TEMP.<br/>The general description of how $scan works could be called SCAN_COMMENT,<br/>and the "help" for it would logically be named SCAN_HELP.<br/><br/>A recommended naming scheme for constants is to make their names<br/>based on what the attributes contain; a DBREF suffix indicates a dbref<br/>number, a NAME suffix indicates a name, and a NUM prefix indicates a<br/>counter of some sort.<br/><br/>* * * * *<br/><br/>Liberal use of whitespace is also encouraged. Whenever possible,<br/>leave spaces; a space should be left before the opening brace of an action <br/>list associated with a @switch, after the ':' separating a $command from<br/>its associated action list, after the commas in arguments to functions,<br/>around the '=' sign between command arguments, and every other place spaces<br/>can be left without affecting command evaluation.<br/><br/>Practicing a good coding style also helps. Actions associated with<br/>a @switch should be enclosed in curly braces, as should each group of<br/>parameters passed to a @trigger. Action lists for @dolist, @wait, and other <br/>similar commands should also be enclosed in curly braces. Even if there is <br/>only a single action, the braces make it very clear what commands or<br/>parameters are associated with each other.<br/><br/>* * * * *<br/><br/>Certain small things speed up evaluation. For example, whenever<br/>possible, use '%0', '%N', and other percent substitutions instead of<br/>'[v(0)]', '[v(N)]' and similar v-function equivalents. The percent<br/>evaluations are faster; the only time when the v-function equivalents are<br/>needed is when explicit string concatenation is required. Similarly,<br/>the percent-substitution '%b' is much faster than '[space(1)]'.<br/><br/>When possible, use "%#" instead of "%N" or "*%N". This removes<br/>one layer of name-matching when hunting for the object you are trying <br/>to reference, and also guarantees that you will get the enactor, and not<br/>merely something with the same name as it. Also, in 2.0, and, to a lesser<br/>extent, in 1.50, objects do not check the name of their container when<br/>trying to name-match. Furthermore, for objects holding global commands,<br/>a match on a name %N will fail if the enactor is not nearby. The match <br/>for the dbref %#, on the other hand, will always work, no matter where<br/>the enactor is located.<br/><br/>Avoid excessive use of the [] bracket grouping with functions.<br/>Unless you are forcing immediate evaluation of an expression for the<br/>purposes of string concatenation, only one set of brackets is needed <br/>around the entire function. If the function is the only argument to a<br/>command, the brackets are not even needed - "@pemit %#=[v(string)]" is<br/>the equivalent to "@pemit %#=v(string)". In the interests of readability,<br/>however, it is advisable to use the bracket delimiters around groups<br/>of functions within a large, complex function call; this is especially<br/>true within lengthy SWITCH() or ITER() evaluations.<br/><br/><br/>13.2	String concatenation and the switchless style<br/><br/>The increasingly popular "switchless style" of programming eschews<br/>the actual @switch command in favor of using function evaluations to<br/>generate a word. The object is then @forced to execute the contents of<br/>the attribute named by that word. A broader definition of the switchless<br/>style includes the entire concept of using complex function evaluations to<br/>replace nested @switches and similar control structures. This cuts down<br/>on the total number of queue cycles needed to execute a complex program.<br/><br/>The switchless style relies very heavily on string concatenation.<br/>This can be accomplished by using the square brackets to force immediate<br/>evaluation of the expression within the brackets. 1.50 also provides the<br/>STRCAT() function, which explicitly concatenates strings.<br/><br/>* * * * *<br/><br/>For example, suppose we create a "cat" object. We want to define<br/>a $command, "pet cat", on it, which causes the cat to give the person one<br/>of several random messages. This is quite simple to code in the standard<br/>style:<br/><br/>&amp;DO_PET_CAT cat = $pet cat: @switch rand(3)=<br/>              0, {@emit The cat purrs when %N pets her.},<br/>              1, {@emit The kitty blinks at %N.},<br/>              2, {@emit The cat arches her back and hisses at %N.}<br/><br/>The switchless style method would be:<br/><br/>&amp;DO_PET_CAT cat=$pet cat: @emit [s(v(PETMSG[rand(3)]))]<br/>&amp;PETMSG0 cat=The cat purrs when %N pets her.<br/>&amp;PETMSG1 cat=The kitty blinks at %N.<br/>&amp;PETMSSG2 cat=The cat arches her back and hisses at %N.<br/><br/>The brackets around the 'rand(3)' forces that evaluation to be done<br/>immediately; the result is then concatenated with PETMSG. Thus, if<br/>rand(3) is 1, we evaluate "[s(v(PETMSG1))]".<br/><br/>This method of picking a message is very useful. If we decide<br/>we want ten messages instead of three, we merely use @edit on the<br/>DO_PET_CAT attribute, and change 3 to 10. Then, we can add seven more<br/>PETMSG attributes.<br/><br/>* * * * *<br/><br/>The switchless style generally works by selecting among attributes.<br/>Attributes used for switchless programming frequently have names ending<br/>in a number, since it's generally easier to use MUSH to generate a number<br/>than a name. Frequently the number will be 0 or 1, since boolean functions<br/>like AND(), OR(), and NOT() evaluate to 0 or 1.<br/><br/>A broader definition of "switchless" programming is discussed<br/>later in this manual, in the section concerning SWITCH(). Note that it<br/>is difficult to program "truly" switchless objects; generally, it is<br/>neither convenient nor desirable to do so. Instead, the aim of switchless<br/>programming is to reduce the number of queue cycles needed through <br/>indirect selection on a string.<br/><br/>Note that because the switchless style makes heavy use of functions,<br/>it may use a large amount of CPU time without using many queue cycles. The<br/>queue cycles-CPU time tradeoff will be discussed later in this manual.<br/><br/><br/>13.3	What the parser really does<br/><br/>Many MUSH programmers are curious about exactly what the parser does.<br/>A large number of programmers who are not familiar with MUSH internals like<br/>to say, "The parser is consistent."  Throw away that notion. It's wrong.<br/>The parser is far from consistent. Various commands have their own little<br/>quirky ways of being parsed. Even certain functions handle their arguments<br/>differently. To the user, however, it should _appear_ that all things are<br/>parsed the same way.<br/><br/>Most MUSH commands take one of three forms:<br/><br/>1. &lt;command&gt; &lt;argument&gt;<br/>2. &lt;command&gt; &lt;argument 1&gt; = &lt;argument 2&gt;<br/>3. &lt;command&gt; &lt;argument&gt; = &lt;argv 1&gt;, &lt;argv 2&gt;, &lt;argv 3&gt;, ...<br/><br/>In most cases, the MUSH figures out what command you want, and<br/>then figures out how to parse the rest of the string you typed. Most<br/>of the time, arguments are run directly through the parser and the<br/>results handed to the command handler. There are several major exceptions<br/>to this. The most notable of these are @switch and @dolist. In @switch,<br/>he first argument (the variable to switch on) is evaluated; the comma-<br/>separated arguments are not. @switch evaluates these arguments as needed.<br/>For the @dolist command, the first argument (the list to use) is evaluated<br/>immediately. Then, a find-and-replace is done on the second argument,<br/>sequentially replacing the "##" token with elements of the list. The final<br/>result of such substitutions is then passed to the evaluator.<br/><br/>* * * * *<br/><br/>The MUSH parser evaluates expressions recursively. The main<br/>server routine to do this is called 'exec'; from this point on, the <br/>expression "the string is exec'ed" will be used to refer to the<br/>evaluation of the string by the parser.<br/><br/>Most uses of square brackets force another call to exec.<br/>Also, every argument to a function is passed through exec, as are the<br/>arguments of most commands. <br/><br/>Let's take a look at our cat example above. If we type "pet cat",<br/>the object attempts to execute "@emit [s(v(PETMSG[rand(3)]))]".<br/>The server goes through the following:<br/><br/>1. It looks up "@emit" in the command table. The server discovers that <br/>   this command takes one argument, which is evaluated. It thus<br/>   passes "[s(v(PETMSG[rand(3)]))]" to exec.<br/>2. exec attempts to evaluate that string. It sees the brackets, and<br/>   invokes exec a second time, with the brackets stripped, so we<br/>   are now evaluating "s(v(PETMSG[rand(3)]))"<br/>3. s() is a function, so exec is called yet another time to evaluate<br/>   the argument to s(). We now need to evaluate "v(PETMSG[rand(3)])"<br/>4. v() is also a function, so we call exec on its argument. We are<br/>   thus left with "PETMSG[rand(3)]"<br/>5. exec scans that string until it sees the pair of brackets. It then<br/>   invokes yet another exec call to evaluate the contents of the<br/>   brackets. We now evaluate "rand(3)".<br/>6. Because rand() is a function, we once more invoke exec, on "3".<br/>7. "3" is just a string literal, so exec returns "3".<br/>8. Having figured out the arguments to rand(), we evaluate it.<br/>   Let's say "rand(3)" is equal to "0".<br/>9. This expression is then concatenated with "PETMSG", giving us<br/>   the string "PETMSG0". This is our argument to v(). Now that we<br/>   have our argument, we evaluate "v(PETMSG0)", giving us,<br/>   "The cat purrs when %N pets her."<br/>10. We now pass this to s(). "s(The cat purrs when %N pets her.)"<br/>    evaluates to "The cat purrs when Amberyl pets her."  (assuming<br/>    Amberyl is the enactor). Note that because we used '%N' rather<br/>    than '[v(N)]', no additional execs are required to get the<br/>    name of the enactor. (If we used '[v(N)]', two additional exec<br/>    calls would be required: one to strip the brackets, and one to <br/>    evaluate the argument to V(). Thus, you can see that it's quite <br/>    a bit more efficient to use '%N'.)<br/>11. This string is passed to the command handler for @emit, which<br/>    shows it to the appropriate people.<br/><br/>Notice how many evaluations such a simple string can need!<br/>When coding, it is important to think not just about how many <br/>queue cycles something uses; most functions must evaluate all their<br/>arguments, and the computation time taken to do this eventually<br/>adds up. Although this is usually on the order of milliseconds,<br/>the actual cumulative delay, on a MUSH running on a busy machine,<br/>can add up to a significant amount of time.<br/><br/>* * * * *<br/><br/>One important effect of functions evaluating their arguments first<br/>before executing the function is that attempts to turn space-separated<br/>lists into comma-separated lists for functions frequently fail. For<br/>example, MAX(v(LIST), 25), where LIST is "1, 10, 83, 4"  causes the<br/>game to find the MAX of "1, 10, 83, 4" (which the string-to-integer<br/>conversion functions trims simply to "1") and "25", thus causing the<br/>function to return "25", rather than "83", which is what one might<br/>have expected it to return. <br/><br/>Similarly, using a LIST of "1 10 83 4" and then evaluating an<br/>expression such as "MAX([iter(v(LIST),{##,})] 25)" doesn't work.  The<br/>ITER() generates the list "1, 10, 83, 4," but this is NOT equivalent<br/>to "MAX(1, 10, 83, 4, 25)"; the erroneous use of ITER() instead causes<br/>MAX() to look for the maximum of "1, 10, 83, 4," (which turns into "1")<br/>and "25". There are several ways of getting around this; see the<br/>discussions on ITER() and FOLD() for examples.<br/><br/>* * * * *<br/><br/>Two important functions do not immediately evaluate their arguments.<br/>ITER() and SWITCH() only evaluate their arguments when the arguments<br/>are needed. ITER() does a brute force find-and-replace for "##" on its<br/>second argument, much like @dolist does; to avoid needing odd<br/>combinations of escapes in the second argument, none of the arguments<br/>are evaluated until the ITER() function actually uses them. Because<br/>SWITCH() calls can be massive, only those arguments which must be<br/>evaluated will be evaluated. This is important to keep in mind if you<br/>are using functions with side-effects, such as 1.50's create().<br/><br/>Note that if you are making multiple identical calls to functions,<br/>all the calls are evaluated _separately_; the MUSH does _not_ know that<br/>it has evaluated that expression before. This is definitely something to<br/>remember, if you use functions like U() to evaluate huge complex expressions.<br/>By the same logic, "@pemit me=add(rand(3),rand(3))" does NOT return the same<br/>value for those two rand() calls. Ways of avoiding multiple identical<br/>function calls will be discussed later in this manual.<br/><br/>Finally, note that the UNIX random-number generator is very poor, and<br/>for small values of N, often returns the same value several times in a<br/>row, even if the overall distribution over, for example, 1000 trials,<br/>is evenly apportioned. If, for some reason, it is important that your<br/>numbers be "more random", you may want to try a method such as using<br/>a very large value of N, and then using a MOD() call to bring it into<br/>the appropriate range. For example, to generate a number from 0 to 9,<br/>one can use "rand(10)"; however, one will get a better random distribution<br/>via "mod(rand(1000),10)".<br/><br/><br/>13.4    Zones in TinyMUSH 2.2<br/><br/>Zones in TinyMUSH 2.2 are somewhat different from PennMUSH 1.50 Zones,<br/>and therefore deserve a separate explanation. This section only applies<br/>if Zones are permitted by the MUSH's configuration.<br/><br/>If you are standing in a room, type a command which is not matched by<br/>an exit, or locally, or internally, and the parent of your current<br/>room is set ZONE, all objects inside that parent will be checked for<br/>$commands, just as if that parent object were the Global Master Room.<br/><br/>If there are no command matches, then if the parent of that parent is<br/>also ZONE, objects in it will be checked. This goes on until something<br/>is matched, or the parent is no longer set ZONE.<br/><br/>If there are still no matches, the same process is repeated, starting<br/>from your own parent object, if it's ZONE.<br/><br/>If still nothing is matched, command checking proceeds to the Global<br/>Master room.<br/><br/>* * * * *<br/><br/>Essentially, what this means is that the ZONE chain creates a chain of<br/>Local Master Rooms. They provides a great deal of power and<br/>flexibility that normal parent rooms don't provide; they confer all<br/>the benefits of normal parenting, in addition to this specialized form<br/>of command-checking.<br/><br/>Commands matched via zone checks are executed by the objects which<br/>contain the commands, NOT by the room or player itself. Therefore,<br/>this method is extremely useful for permitting players other than<br/>the Builder Character (or generic area owner) to execute commands for<br/>a given area. It also alleviates the necessity of setting all rooms<br/>in the area INHERIT, if a certain local command requires INHERIT.<br/><br/>Because the ZONE chain is essentially a chain of Master Rooms, the<br/>same caveats which apply to Master Room programming apply to objects<br/>in these chains. Objects in the rooms should have a minimal number of<br/>attributes on them. Because the parents of objects in the rooms are not<br/>checked for $commands, @parent'ing such objects to a data object will<br/>reduce the checks needed without significantly altering the programming<br/>style for such an object.<br/><br/>Security, of course, is important -- ZONE chains should be isolated,<br/>and unauthorized players should be prevented from gaining access to <br/>them.<br/><br/><br/>---------------------------------------------------------------------------<br/><br/><br/>14.	Tricks of the Trade<br/><br/><br/>14.1    Adding to, removing from, and comparing lists<br/><br/>Lists are the heart and soul of MUSH. Earlier in this manual,<br/>ways of finding certain items within a list, adding to lists, and removing<br/>from lists were discussed.<br/><br/>The standard list-operation functions fare poorly when there are<br/>items in the list which are identical. In particular, we often want to<br/>avoid adding items to a list which are already in it, get the result of<br/>merging two lists, and remove items from a list without destroying the<br/>spacing of the list.<br/><br/>The REMOVE() function generally leaves an extra space in the list.  We<br/>can get around this problem by passing the results of a REMOVE() call<br/>to S(); indeed, this method of forcing another round of pronoun<br/>substitution is useful for compressing undesired spaces. The SQUISH()<br/>function removes extra spaces, and is useful when a second round of<br/>evaluation is not desirable. Thus, REMOVE() is adequate for most of<br/>the times we wish to remove an item from a list.<br/><br/>* * * * *<br/><br/>The SETDIFF() function provides a better way to remove items from<br/>a list. SETDIFF(&lt;list 1&gt;,&lt;list 2&gt;) removes from &lt;list 1&gt; all items that are<br/>in &lt;list 2&gt;. It can also be thought of as returning all the elements of<br/>&lt;list 1&gt; that aren't in &lt;list 2&gt;. This is useful when you want to guarantee<br/>that you have removed every occurrence of an item; objects like communicator<br/>systems are best programmed like this. <br/><br/>The SETUNION() function is useful for adding an element (or elements)<br/>to a list. It merges two lists, removing duplicates. Like SETDIFF(), this <br/>function is useful when you want to guarantee that you have no duplicates;<br/>in a communicator system, this is especially important.<br/><br/>The SETINTER() function returns the elements that are in both lists.<br/>This is also for use in merging lists; elements that are only in one list<br/>get eliminated. This is also useful for telling if all elements of one<br/>list are in another; evaluate the SETINTER() of the two lists, and COMP()<br/>it to the list you are interested in.<br/><br/>* * * * *<br/><br/>One interesting example problem in list manipulation is the removal of<br/>a specific element by its position. This is a problem encountered when<br/>it is not possible to use REMOVE(), which removes the first instance of<br/>an elements by name, or SETDIFF(), which removes all occurrences of the<br/>elements, also by name. For example, if we keep two attributes on an <br/>object, one with the names of dragons, and the other with the colors of<br/>those dragons, and we want to remove one of the dragons from both lists,<br/>we encounter this problem; while names in the first list should be unique,<br/>many of the words in the second list will not be (we will probably have<br/>many Blue dragons, for example.)<br/><br/>If our list of dragon names is in the attribute NAMES and the<br/>corresponding colors list is in the attribute COLORS, we can delete,<br/>given a dragon name, its corresponding color from the colors list by<br/>using EXTRACT() to return all words before that position, and all<br/>words after that position. We determine the position using the MEMBER<br/>function, as per the standard list-matching routine described earlier<br/>in this manual. The code is thus:<br/><br/>&amp;COLORS object=[extract(v(colors), 1, sub(member(v(names),%0),1))]<br/>        [extract(v(colors), add(member(v(names),%0),1), words(v(colors)))]<br/><br/>Once we've deleted the color from the colors list, we can safely use REMOVE()<br/>or SETDIFF() to remove the dragon name from the names list.<br/><br/>* * * * *<br/><br/>The above problem can be more easily solved by the judicious application<br/>of a built-in function callled LDELETE(), which deletes an element from<br/>from a list, given the element position to delete.<br/><br/>LDELETE() has two brethren functions, called INSERT() and REPLACE(),<br/>which take the arguments &lt;list&gt;, &lt;pos&gt;, &lt;word&gt;. The first function <br/>inserts &lt;word&gt; into &lt;pos&gt; of &lt;list&gt;, and the second function replaces<br/>&lt;pos&gt; element of &lt;list&gt; with &lt;word&gt;.<br/><br/>All three of these functions should be used instead of clumsy EXTRACT()<br/>manipulations of the type described above.<br/><br/><br/>14.2	Function building blocks<br/><br/>Two functions form the core of switchless programming: U()<br/>and SWITCH(). The first (also known as UFUN() in 1.50) allows the<br/>MUSH programmer to define, in a limited sense, his own functions,<br/>while the latter pattern-matches a string against a list of other<br/>strings, and, instead of triggering an action, as does @switch<br/>command, the SWITCH() function simply returns a string.<br/><br/>U() takes up to ten arguments. The first argument is an<br/>attribute, which specifies where to look for the function definition.<br/>This argument can be a name, or it can be an object/attribute pair.<br/>The remaining arguments to U() are parameters to be passed on the<br/>stack (i.e. as %0 - %9). Thus, stack parameters to a U() evaluation<br/>are purely local - they are not at all related to the value of the<br/>"global" stack. A evaluation like "u(FOO_FN, bunch, of, words)" would<br/>pass "bunch" as %0, "of" as %1, and "words" as %2. Then, the contents<br/>of FOO_FN would be evaluated with those values. For example:<br/><br/>&gt; &amp;TEST me=%0 has [strlen(%0)] characters and [words(%0)] words. %1!<br/>&gt; "[u(TEST, Test string, Neat)]<br/>You say, "Test string has 11 characters and 2 words. Neat!"<br/><br/>In this example, %0 is "Test string", and %1 is "Neat". Note that<br/>those values are only true within TEST, though. For example, values<br/>passed by @trigger are unchanged:<br/><br/>&gt; &amp;TEST me=%0 has [words(%0)] words.<br/>&gt; &amp;ACT me=say %0 %1 %2 - [u(TEST,%1)] - %0<br/>&gt; @trigger me/act={a 1}, {b 2 3}, {c 4 5 6}<br/>You say, "a 1 b 2 3 c 4 5 6 - b 2 3 has 3 words - a 1<br/><br/>From the @trigger, %0 is "a 1", %1 is "b 2 3", and %2 is "c 4 5 6".<br/>In the TEST evaluation, %0 is "b 2 3", since that was the parameter<br/>passed to it. But when we return to evaluating the output of the <br/>@trigger, %0 is still "a 1"; the value of %0 in the U() evaluation<br/>of TEST does not change the real value of %0.<br/><br/>* * * * *<br/><br/>1.50 and 2.0 handle U() evaluation differently; 1.50's GET_EVAL() is<br/>basically identical to its U(). For the differences between 2.0's<br/>GET_EVAL() and U(), see the earlier section of the manual on GET().<br/><br/>The only other difference between 1.50 and 2.0's U() is that<br/>1.50 does not force immediate evaluation of a U() unless it is surrounded<br/>by square brackets. In other words, in 1.50, "&amp;FOO_FN object=strlen(%0)"<br/>and "&amp;FOO_FN object=[strlen(%0)]" are handled differently - without the<br/>brackets, the game does a local evaluation and substitution, and pastes<br/>that in, instead of forcing an immediate evaluation. For example:<br/><br/>&gt; &amp;TEST1 me=strlen(%0)<br/>&gt; &amp;TEST2 me=[strlen(%0)]<br/>&gt; "Test1: -[u(TEST1,foo)]- Test2: -[u(TEST2,foo)]<br/>You say, "Test1 -strlen(foo)- Test2: -3-"<br/><br/>The programmer is allowed slightly more flexibility when immediate<br/>evaluation is not forced. In general, it is good programming practice<br/>to put square brackets around the functions contained in an attribute<br/>called by U().<br/><br/>* * * * *<br/><br/>The U() function is usually used to clean up code which would<br/>otherwise be horrendously complicated and unclear. Also, because the<br/>parameters passed to U() are only evaluated once, if you need to evaluate<br/>an expression which utilizes a complex expression several times, you<br/>can simply make that complex expression a parameter to U(). This method<br/>of using U() is detailed later in the manual, in the section dealing<br/>with efficiency.<br/><br/>A general rule of thumb of putting an expression in a U() is,<br/>"If you use it more than once, and it contains more than two or three<br/>nested functions, or it is more than 70 characters (one line) long,<br/>make it a U()."   The 70-character rule has its exceptions, but<br/>anything you can't type without using emacs or some other kind of<br/>parentheses/brackets-matcher is Too Long and should go into a U()<br/>attribute by itself.<br/><br/>* * * * *<br/><br/>U() is often used for permission checks on objects. For example,<br/>a bulletin board might only permit the original poster of a message to<br/>delete it. In the future, however, you might wish to allow wizards to<br/>also delete messages. Rather than having to scan through all the bulletin<br/>board code, it'd be simpler just to change a single U() function. Thus,<br/>when writing the board code, it'd be good to call something like<br/>OK_TO_DELETE_FN, even if the check for permission to delete is simple.<br/>As long as you keep the parameter list the same, you shouldn't have any<br/>trouble swapping in a new OK_TO_DELETE_FN should you ever change your<br/>mind about who is allowed to delete messages.<br/><br/>* * * * *<br/><br/>"Switchless programming" is a bit of a misnomer; this style<br/>frequently involves the SWITCH() function, although it generally <br/>avoids the @switch command. The SWITCH() function is quite similar<br/>in format to @switch, but instead of performing a command list based<br/>on matching a string pattern, it returns another string. It is as<br/>flexible of a pattern-matcher as @switch, taking the '*' and '?'<br/>wildcard characters. The obvious use for this function is turning<br/>one string into another string; if there is more than one match<br/>possible, SWITCH() returns the first one. SWITCH() does not evaluate<br/>its arguments until it needs to; therefore, if you have side-effect<br/>functions within a SWITCH(), such as 1.50's CREATE(), remember that<br/>they will not get evaluated unless the corresponding pattern is<br/>matched.<br/><br/>When combined with U(), SWITCH() is an extremely powerful<br/>tool. One common application of this combination is to return boolean<br/>values (0 or 1) based on some string. The most frequently used<br/>example of this is HASATTRIB - the determination of whether or not<br/>an attribute exists on a certain object. If the attribute exists,<br/>it evaluates to 1; if not, it evaluates to 0. The code for this is<br/>simple:  &amp;HASATTRIB_FN object=[switch(get(%0/%1),,0,1)]<br/>It is then called via [u(HASATTRIB,object,attribute)]. If the<br/>GET() returns nothing, then there's no such attribute, and the<br/>evaluation is 0. Otherwise, it's 1.<br/><br/>Boolean returns can be extraordinarily useful in conjunction with<br/>SETQ() and R(). For example, if you want to print out a '+' for<br/>every time a function returns 1, and a '-' when the function returns<br/>0, you can do a '[setq(0,-)][setq(1,+)]' and then print out<br/>'[r(u(COMPLEX_FUNCTION))]' instead of continually SWITCH()ing<br/>for the string to print.<br/><br/>* * * * *<br/><br/>Note that one common use of SWITCH() -- returning a value if a <br/>certain attribute does not exist -- is made unnecessary by the<br/>addition of the functions DEFAULT(), EDEFAULT(), and UDEFAULT(),<br/>in TinyMUSH 2.2. These functions take the basic syntax:<br/>function([&lt;object&gt;/]&lt;attribute&gt;, &lt;default&gt;[,&lt;parameters for U()&gt;])<br/><br/>Instead of writing the following:<br/><br/>[switch(v(TEST),,No test string.,v(TEST))]<br/>[switch(get(#10/TEST),,No test string.,get_eval(#10/TEST))]<br/>[switch(v(TEST),,No test string.,u(TEST,%#))]<br/><br/>one could write, respectively:<br/><br/>[default(TEST,No test string.)]<br/>[edefault(#10/TEST,No test string.)]<br/>[udefault(TEST,No test string.,%#)]<br/><br/>This elimination of the extra attribute retrieval is valuable, and<br/>the lack of a SWITCH() removes the need to do any sort of wildcard<br/>pattern match. <br/><br/>			----------<br/><br/>SWITCH() can be used to entirely eliminate a @switch. For<br/>example, here's a typical lengthy @switch construction:<br/><br/>@switch v(num)=0,@emit [v(apple)],1,@emit [v(apple)],2,@emit [v(apple)],<br/>	3,@emit [v(apple)],4,@emit [v(apple)],5,@emit [v(pear)],6,<br/>	@emit [v(orange)],7,@emit [v(orange)],@emit [v(cherry)]<br/><br/>This can be reduced to:<br/><br/>@emit [v([switch([and(gte(v(num),0),lte(v(num),4))],1,apple,<br/>	[switch(v(num),5,pear,6,orange,7,orange,cherry)])])]<br/><br/>This has the advantage of reducing the extra queue cycle involved in<br/>the @switch. It isn't quite as easy to read as the @switch statement,<br/>initially, but with practice, switchless-style coding becomes just as<br/>simple to follow. (Note that extra brackets have been added in the<br/>example above in order to make it easier to read.)<br/><br/>The repeated calls of 'v(num)' are inefficient. A better method follows<br/>below; this time, the extra brackets have been left out.<br/><br/>@emit [setq(0,v(num))][v(switch(and(gte(%q0,0),lte(%q0,4)),1,apple,<br/>	switch(%q0,5,pear,6,orange,7,orange,cherry)))]<br/><br/>This can be even further compressed by a technique which will be described<br/>in another section; it combines several switch patterns into one.<br/><br/>@emit [setq(0,v(num))][v(switch([and(gte(%q0,0),lte(%q0,4))]:%q0,1:*,apple,<br/>	*:5,pear,*:6,orange,*:7,orange,cherry))]<br/><br/>* * * * *<br/><br/>There are also variations on this theme, which don't necessarily<br/>eliminate the @switch. For example, if instead of the simple @emit example<br/>above, there were different action lists associated with each value of<br/>the NUM attribute, it would be impossible to eliminate the @switch<br/>efficiently. It would be possible to generate, as a string, the action<br/>list to be run, and then @force the object to do it, but that wouldn't<br/>be any timed gained. Here is a more complex example of a @switch for<br/>which this is true:<br/><br/>@switch v(num)=0, {@pemit %#=Success.}, 1, {@pemit %#=Success.},<br/>	2, {@pemit %#=Success.}, 3, {@emit Disaster!}, 4, {@emit Disaster!},<br/>	5, {@tel %#=#100; &amp;victim me=[v(victim)] %#}, {@pemit %#=Failure.}<br/><br/>The best approach to something like this is to generate a "code string"<br/>via the SWITCH() function, and then @switch on that code. Usually, this<br/>looks best if done in combination with a U(), but for this example, we'll<br/>simply write it out; just realize that the left hand side of the '=' sign<br/>would probably be best put in a U().<br/><br/>@switch switch([and(gte(v(num),0),lte(v(num),2))],1,OKAY,<br/>		[switch(v(num),3,BAD,4,BAD,5,OTHER)]) =<br/>	OKAY, {@pemit %#=Success.}, <br/>	BAD, {@emit Disaster!},<br/>	OTHER, {@tel %#=#100; &amp;victim me=[v(victim)] %#},<br/>	{@pemit %#=Failure.}<br/><br/>In this particular case, the switchless code is not an improvement<br/>over the original @switch. However, if we ever want to change what constitues<br/>"okay", "bad", "other", or failure, all we have to change is the expression<br/>on the left hand side of the '='; we don't have to rewrite the entire <br/>command. If it's put in an attribute as a U() instead, this becomes<br/>even easier; we simply need to change that attribute.<br/><br/>* * * * *<br/><br/>Here is a variant of the "code string" procedure which does not<br/>use SWITCH(). Instead, it generates several words based on the values<br/>we are interested in switching on, and takes advantage of wildcards.<br/>In this case, the first number generated tests for 0 &lt;= num &lt;= 2,<br/>the second number for num = 3 or num = 4, and for convenience, the value <br/>of num itself as the third word.<br/><br/>@switch [and(gte(v(num),0),lte(v(num),2))] [or(eq(v(num),3),eq(v(num),4))]<br/>		[v(num)]=<br/>	1 * *, {@pemit %#=Success.},<br/>	0 1 *, {@emit Disaster!},<br/>	0 0 5, {@tel %#=#100; &amp;victim me=[v(victim)] %#},<br/>	{@pemit %#=Failure.}<br/><br/>When using this kind of switch, it is usually safer to use "@switch/first"<br/>(also called "@select") to ensure that we only match the first case that<br/>applies.<br/><br/>The multiple-code-words method is most efficient when used to<br/>eliminate multiple @switch statements. For example, consider the case<br/>of checking valid input for a command which takes the format<br/>"test &lt;four letter word&gt; &lt;player name&gt;". We want to display an<br/>appropriate error message. The simplest way to code this up is:<br/><br/>$test * *: @switch [eq(strlen(%0),4)]=0, {@pemit %#=Invalid word.},<br/>	{@switch [num(*%1)]=#-1, {@pemit %#=Invalid player.},<br/>	{@trigger *%1/TEST_ATTRIB}}<br/><br/>This costs us extra queue cycles, though, and also doesn't catch the<br/>case of both arguments being incorrect. Using code words, we can fix that:<br/><br/>$test * *: @switch/first [eq(strlen(%0),4)] [num(*%1)]=<br/>	0 #-1, {@pemit %#=Invalid word and player.},<br/>	0 *, {@pemit %#=Invalid word.},<br/>	* #-1, {@pemit %#=Invalid player.},<br/>	{@trigger *%1/TEST_ATTRIB}<br/><br/>Note that because we use patterns which are not mutually exclusive<br/>("0 #-1" also matches "0 *" and "* #-1"), we must use @switch/first.<br/><br/>* * * * *<br/><br/>Other interesting tricks can be done with @trigger and SWITCH().  For<br/>example, in cases where we want to pass a number of complex function<br/>evaluations to a later evaluation, we might want to use a @trigger<br/>instead; if we eliminate the @switch in the process, this turns out to<br/>be the same number of queue cycles, and syntatically neater.<br/><br/>Take the following example, based on the notes above. This time,<br/>however, instead of sending the message to %#, we want to send the<br/>message to something defined by the complex black-box user-defined<br/>function called with u(BIG_FN,%#,revwords(%0)) -- too much to type<br/>repeatedly. Thus, we end up with something like:<br/><br/>$test *: @trigger me/[u(FOOBLE_FN,%0)]_TRIG=u(BIG_FN,%#,revwords(%0))<br/><br/>We use FOOBLE_FN (whatever that happens to be) to generate the name<br/>of the attribute to trigger, and now we end up writing that parameter<br/>out only once. This technique is particularly useful in extremely<br/>large switch statements which have many cases and long action lists.<br/><br/>			----------<br/><br/>The major reason to write code using U() and SWITCH() isn't<br/>speed, for large projects. It's modularity. If you define some kind<br/>of U() to check permissions to run a command, for example, if you ever<br/>want to change the criteria, all you need to do is to change the<br/>definition of that U(). SWITCH() is also particularly good at reducing<br/>complex expressions that might otherwise require several @switches<br/>by means of the "code strings" method; it's easy to jam multiple<br/>@switch clauses into a single @switch by providing a complicated<br/>SWITCH() to generate a word that can be @switch-cased on. One<br/>should, however, be wary of trying to reduce all code down to the<br/>minimum number of queue cycles; some amount of readability is also<br/>important, as is the amount of "real CPU time" needed to execute<br/>a given MUSH program. This trade-off is discussed in detail later<br/>in this manual.<br/><br/>There are certain functions whose functionality is frequently needed,<br/>but simple enough to code in MUSH that they are not worth hardcoding<br/>into the server. To provide some kind of standardization for these<br/>functions, and to get around the occasionally clumsy U() calling<br/>convention, MUSH provides a mechanism called "@function". It enables<br/>the global definition of a U() as an imitation "real" function. A<br/>Wizard (or, in 1.50, someone with the Functions power) can specify a<br/>name for the function and the place where it can be found, and then<br/>anybody on the MUSH can use it as if it were a built-in function.  The<br/>syntax is: @function &lt;function name&gt;=&lt;object&gt;,&lt;attribute&gt; &lt;function<br/>name&gt; is the name used for the function, and &lt;object&gt; and &lt;attribute&gt;<br/>specify the name of the attribute and the object on which it can be<br/>found. The parameters passed to an invocation of a function defined in<br/>this way are passed as %0 - %9. Therefore, any function normally<br/>called via U() can be defined globally simply by adding it to the<br/>"local global" function table via @function. For example, in 1.50:<br/><br/>&gt; &amp;HASATTRIB_FN #10=[switch(get(%0/%1),,0,1)]<br/>&gt; @function hasattrib=#10,hasattrib_fn<br/><br/>tells the game to add HASATTRIB to the functions table, and to use<br/>the attribute HASATTRIB_FN on object #10 when evaluating that. Then<br/>one could simply do:<br/><br/>&gt; @desc me=The writer of the MUSH manual.<br/>&gt; say [hasattrib(me,desc)]<br/>You say, "1"<br/><br/>This would be equivalent to "say [u(#10/HASATTRIB_FN,me,desc)]", but is <br/>syntactically much neater, as well as faster. Also, because of the @function,<br/>any player on the MUSH can use HASATTRIB(), even if he can't directly read<br/>the attribute. Thus, players do not have to see the code in order to use<br/>it. If the function were a simple U(), another player would have to be<br/>able to read the attribute - it would either have to be public, set public<br/>via the VISUAL attribute flag, or visible because the object it was on (#10)<br/>was set VISUAL.<br/><br/>Note that the syntax in 2.2 is "@function &lt;function&gt;=&lt;object&gt;/&lt;attribute&gt;".<br/>2.2 also takes the switch "/privileged"; if this is given, the function<br/>is evaluated as if it was performed by the object on which it was stored<br/>(giving players access to information which, for example, might only be<br/>accessible to Wizards under normal circumstances). Otherwise, the function<br/>is evaluated as if it were stored on the invoker.  (Also note that the<br/>above example is somewhat irrelevant in 2.2 -- the HASATTR() function<br/>performs that functionality.)<br/><br/><br/>14.3	Formatting Strings<br/><br/>A lot of "MUSHtoys" involve the "pretty-printing" of output;<br/>frequently, this means listing output in neat columns. To do this,<br/>one must calculate the number of spaces needed to get to the place where<br/>the next "real" string should start. This can be accomplished in one<br/>of two ways.<br/><br/>The most efficient way to do this is to use the RJUST() and LJUST()<br/>functions, which right- and left-justify a string, respectively.  The<br/>first argument to these functions is the string to print, and the<br/>second argument specifies the field width. Strings that are too long<br/>do not get truncated. Both of these functions take an optional third<br/>argument, which specifies the fill character to use; if no third<br/>argument is given, a space is used. Thus, if you want to %0 to start<br/>at column 1, %1 to start at column 20, and %2 to start at column 45,<br/>the expression "[ljust(%0,19)][ljust(%1,24)]%2" will work.<br/><br/>* * * * *<br/><br/>In old versions of 2.0, a slightly clumsier method must be used. The SPACE()<br/>function is used to print spaces; you must calculate the number of spaces<br/>to print based on the length of the string you are printing. For the<br/>case above, the equivalent expression, using the SPACE() function, is<br/>"%0[space(sub(19,strlen(%0)))]%1[space(sub(24,strlen(%1)))]%2"<br/>The major problem with printing something in this way concerns recalculation<br/>of the same string. If, for example, you had, instead of %0, %1, and %2,<br/>three large, complex functions, you would have to evaluate those functions<br/>twice, once to actually print it, and once to calculate the length of<br/>the string. For extremely complicated functions, the doubling of this<br/>work may cause a significant loss of speed when the object is used. This<br/>can be avoided by defining RJUST and LJUST as U() functions:<br/><br/>&amp;LJUST_FN object=%0[space(sub(%1,strlen(%0)))]<br/>&amp;RJUST_FN object=[space(sub(%1,strlen(%0)))]%0<br/><br/>The extra overhead of invoking another U() function generally is less<br/>than that of computing a large function evaluation.<br/><br/>Related to the SPACE() function is the REPEAT() function,<br/>which repeats an arbitrary string a given number of times. The<br/>strings are concatenated with each other, without spaces separating<br/>each repetition. It can be used to fake the three-argument version of<br/>LJUST() and RJUST():<br/><br/>&amp;LJUST3_FN object=%0[repeat(%2,sub(%1,strlen(%0)))]<br/>&amp;RJUST3_FN object=[repeat(%2,sub(%1,strlen(%0)))]%0<br/><br/>Generally, though, this function is used for generating long lines of<br/>asterisks, dashes, and other symbols used for ASCII graphics or division<br/>of output into fields.<br/><br/>* * * * *<br/><br/>One common formatting task is the formatting of poses, says, and the like,<br/>for arbitrary commands. Suppose, for example, that you have a chat system,<br/>which takes a command of the format, "$chat *". You want the following:<br/><br/>chat Hi!          ==&gt;  Fire says "Hi!"<br/>chat :waves.      ==&gt;  Fire waves.<br/>chat ;'s idling.  ==&gt;  Fire's idling.<br/><br/>Assuming that the * is going to end up as %0, and the chatting person's<br/>going to be the enactor, the following works:<br/><br/>[switch(%0,:*,%N [delete(%0,0,1)],;*,%N[delete(%0,0,1)],%N says "%0")]<br/><br/>Note that we use DELETE() here to remove the first character of the<br/>string, if necessary, instead of using MID() to get everything after<br/>the first character; deleting one character is a lot faster.<br/><br/><br/>14.4	Lists instead of @dolists<br/><br/>The most powerful list-creation facility available in MUSH is<br/>the ITER() function. ITER() takes two arguments, a space-separated list<br/>of words, and a format string of some sort (which can contain other<br/>functions). The format string is evaluated for each element of the list,<br/>with the "##" token being replaced by the list element. The result is<br/>also a list, with each element separated by a space. The simplest<br/>example of an ITER() is something of the form "[iter(%0,##)]", which<br/>just returns back %0. The most common use of ITER(), however, is turning<br/>a list of dbrefs into a list of names: "[iter(lcon(here),name(##))]"<br/>returns a list of names of the objects in a room. <br/><br/>The mundane uses of ITER() are fairly obvious; it's used to<br/>transform one list into another list. A more sophisticated use of<br/>ITER() is using the function to replace a @dolist-@pemit combination<br/>with a single @pemit and ITER(). This is useful for bulletin board<br/>objects, mailer objects, WHO list formatters, and other mass-output<br/>devices. Because ITER() places a space between each element of the<br/>list returned, to correctly format such a list so that the elements<br/>are returned one per line, a "%r" should be placed at the beginning<br/>of the format string. For example, to return the list of contents<br/>in a room, by name, one to a line, use "[iter(lcon(here),%r[name(##)])]"<br/>The "%r" must come first, not last; otherwise, the output would be<br/>indented by one space.<br/><br/>Using @dolist: @pemit %#=You see:; @dolist lcon(here)={@pemit %#=name(##)}<br/>Using ITER():  @pemit %#=You see:[iter(lcon(here),%r[name(##)])]<br/><br/>* * * * *<br/><br/>One is frequently interested in obtaining only those members<br/>of a list for which a certain expression is true. For example, the<br/>construction "[iter(v(list),switch(u(FILTER_FN,##),1,##,))]" is quite<br/>common. It means "return all those elements of the list contained in<br/>the attribute LIST, for which FILTER_FN evaluates to 1."<br/>Because this construction is very frequently used, 1.50 provides a<br/>more efficient short form, via the FILTER() function. The first<br/>argument to FILTER() is an attribute or object/attribute pair (just<br/>like U()'s first argument), and the second argument is a list. FILTER()<br/>returns all elements of the list for which the first argument evalutes<br/>to 1. Thus, the equivalent to the expression above would be simply<br/>"[filter(FILTER_FN,v(list))]".<br/><br/>* * * * *<br/><br/>ITER() can also be used to solve the MAX() problem from earlier<br/>in this manual -- taking a space-separated list and passing it to a<br/>function as a comma-separated list. The MUSH parser, when it sees a<br/>function evaluation, attempts to evaluate each argument to the function,<br/>using the comma to separate each argument. The problem encountered with<br/>turning the space-separated list to the comma-separated list was that<br/>the comma-separated list was generated _after_ the parser had already<br/>determined where the argument began and ended. Thus, we must delay the<br/>evaluation.<br/><br/>We do this by causing the escaping the function, without escaping<br/>its arguments, so that the arguments are evaluated (using ITER() to turn<br/>the space-separated list into a comma-separated list), and then running<br/>the entire thing through the S() function, which causes a second parser<br/>pass. Presuming that the space-separated numeric list is in the LIST<br/>attribute on the object -- LIST was "1 10 83 4" in the earlier example --<br/>and we want to also compare it to the number 25, we end up with the<br/>following:  s(\[MAX([iter(v(LIST),{##,})] 25)\])<br/><br/>The parser reacts in the following manner:  it sees the S()<br/>function, and goes to evaluate the argument inside. The argument inside<br/>evalutes to [MAX(1, 10, 83, 4, 25)] -- the ITER() generates the string<br/>"1, 10, 83, 4, " and concatenated with the 25, generates the above string.<br/>Because of the '\' escapes, MAX is considered a string and not a function;<br/>the '[]'s around the ITER() force that evaluation to complete. Now, the<br/>S() function evaluates [MAX(1, 10, 83, 4, 25)], which is 83, our desired<br/>result.<br/><br/>This technique works, in general, for converting any space-separated<br/>list to a comma-separated list to be passed to a function which requires<br/>comma-separated arguments.<br/><br/><br/>14.5	Recursion<br/><br/>"Recursion" is a difficult term to define; it can be loosely<br/>described as a process by which an expression uses itself to determine<br/>its value. A "recursive function" calls itself, stopping when it reaches<br/>a "base case". This can probably be best illustrative via an example.<br/><br/>The mathematical expression "n!" ("n factorial") means the<br/>product of all whole numbers between 1 and n, or, since formal sigma<br/>(summation) notation is difficult to write in pure ASCII, informally <br/>expressed by the formula:    n! = (n)(n - 1)(n - 2)(n - 3)...(1)<br/>For example, 4! = (4)(3)(2)(1) = 24.  One quickly notes, however, that<br/>this is equal to (4)(3!) = (4)(3)(2!) = (4)(3)(2)(1)<br/>Therefore, we can write:   n! = (n)((n - 1)!)<br/>Because the factorial expression is used to determine a factorial,<br/>we can say that the factorial function is recursive.<br/><br/>All recursive expressions must have some kind of base case;<br/>otherwise, the function will continue to evaluate itself forever.<br/>For the factorial function, the base case occurs when n = 1; the<br/>function simply returns 1.<br/><br/>* * * * *<br/><br/>Recursion can be done quite simply in MUSH, although the built-in<br/>function evaluation limit prevents the "stack" of functions from<br/>growing too large. We can write a U() function to evaluate factorials,<br/>using a SWITCH() to check for the base case:<br/><br/>&amp;FACTORIAL_FN object=[switch(%0,1,1,mul(%0,u(FACTORIAL_FN,sub(%0,1))))]<br/><br/>The expression "[u(object/FACTORIAL_FN,4)]" will return "24".<br/>Note that this is a literal translation of the mathematics involved. "If 1, <br/>return 1. Else, multiply our current number by the factorial of our current <br/>number minus 1."  One of the beauties of recursion is that it usually <br/>follows quite naturally from the verbal description of the algorithm.<br/><br/>* * * * *<br/><br/>There is a built-in function called FOLD() which is intended for<br/>use in recursion. The first argument to FOLD() is the name of an attribute<br/>which is to be treated as a U(), and the second argument is a list whose<br/>members will be passed one at a time as %1 to the U() evaluation. (Note<br/>that the U() function is not directly involved in the FOLD() operation,<br/>but the attribute is evaluated like a U(), so for convenience's sake, we'll<br/>call it a U() evaluation). If there is no third argument, which could be<br/>called a base case, the first element passed for the first time is given<br/>as %0. Normally, the result of the previous evaluation is passed as %0.<br/><br/>To translate our factorial function into FOLD()'s syntax, we need<br/>to generate a list. The obvious method is to generate a list of all numbers<br/>between 1 and n, and multiply them all together. The LNUM() function will<br/>generate all numbers between 0 and n-1, so to get all numbers between<br/>0 and n, we must use LNUM(add(%0,1)). To eliminate that 0, we use the<br/>REST() function.<br/><br/>&amp;FACTORIAL_FN obj=[fold(FACT_AUX_FN,rest(lnum(add(%0,1))),1)]<br/>&amp;FACT_AUX_FN obj=[mul(%0,%1)]<br/><br/>This is considerably faster than the "pure" recursive method, and has<br/>the additional advantage of not running us up against the function <br/>recursion limit. Under a normal recursion limit, our first try at<br/>writing the factorial function fails when n is greater than 9; using<br/>FOLD(), we don't hit the recursion limit at all, since the nesting<br/>is never more than 3 functions deep (1 is the U() call to FACTORIAL_FN,<br/>2 is the call to FOLD(), and 3 is the call to MUL()).<br/><br/>* * * * *<br/><br/>Most people probably don't compute factorials in their daily<br/>MUSHing. A more practical application of recursive technique is the<br/>"pretty printing" of output into columns. If, for example, we wish to<br/>print a list in three columns, we should check to see if our current<br/>list has 3 words or less, and, if so, print them; otherwise, we should<br/>print the first three words, a newline, and then call our column function<br/>again on the remainder of the words in the list (i.e. word #4 on).<br/>This can be written as:<br/><br/>&amp;COLUMN_FN object=[switch(gt(words(%0),3),<br/>    0,[u(FORMAT_FN,%0)],<br/>    [u(FORMAT_FN,extract(%0,1,3))]%r[u(COLUMN_FN,extract(%0,4,words(%0)))])]<br/><br/>&amp;FORMAT_FN object=[first(%0)]%t[first(rest(%0))]%t[rest(rest(%0))]<br/><br/>Thus, the expression "[u(COLUMN_FN,lnum(8))]" gives us<br/><br/>0	1	2<br/>3	4	5<br/>6	7<br/><br/>By changing FORMAT_FN, we can do other interesting things with our words;<br/>the example above is not necessarily the optimal way to pass arguments<br/>to FORMAT_FN, if the expression is very complex; it might be better to<br/>pass FORMAT_FN three arguments, doing the FIRST()/REST() extractions<br/>before calling FORMAT_FN.<br/><br/>This is another case where FOLD() is useful. Because we can only<br/>grab one item off our list at a time when using FOLD(), we need to have<br/>some other way of determining when to insert a carriage return. For <br/>three-column output, we want to insert a carriage return every three<br/>words; therefore, if the number of words in the string is divisible by 3,<br/>we add a newline, otherwise, we add a tab. The code is then quite simple:<br/><br/>&amp;COLUMN_FN object=[fold(FORMAT_FN,%0)]<br/>&amp;FORMAT_FN object=%0[switch(mod(words(%0),3),0,%r,%t)]%1<br/><br/>* * * * *<br/><br/>FOLD() can also be used to randomize a list under 2.0 (there is a<br/>built-in function, SHUFFLE(), in 1.50 and 2.2, which randomizes<br/>lists).  The list cannot be too large, or the function invocation<br/>limit will cause an error, but using FOLD() is still more reasonable<br/>than most other list randomization methods.<br/><br/>What we want to do is to take the elements of the list one at a time<br/>and randomly put them into positions of another list. This can be<br/>done, fairly effectively, by doing the following:<br/><br/>1. Start with a blank new list.<br/>2. Take an element of the original list. Put it in the new list.<br/>3. Take the next element of the original list. Put it either before or<br/>   after the element of the new list.<br/>4. Take the third element of the original list. Insert it into the new<br/>   list at a random position.<br/><br/>We can use FOLD() to accomplish this, with %0 as the new list,<br/>and %1 as an element, using the following code:<br/><br/>&amp;SHUFFLE_FN object=[fold(SHUFFLE_LIST_FN,%0)]<br/>&amp;SHUFFLE_LIST_FN object=[insert(%0,add(rand(words(%0)),1),%1)]<br/><br/>* * * * *	<br/> <br/>Finally, FOLD() is very good for dealing with space-separated<br/>lists that need to be passed to functions which require comma-separated<br/>arguments, such as the example of MAX() used earlier in this manual<br/>section. Given an attribute LIST, containing something like "1 10 83 4",<br/>one can find the maximum of the numbers in it using this code:<br/> <br/>&amp;MAXLIST_FN object=[fold(MAXTWO_FN,rest(v(list)),first(v(list)))]<br/>&amp;MAXTWO_FN object=[max(%0,%1)]<br/><br/>* * * * *<br/><br/>Recursion is a very natural technique for generating output<br/>which follows a clearly defined pattern. Unfortunately, due to the<br/>function recursion and invocation limits, it is frequently not a<br/>usable for large values (or long lists, etc.), unless you are using<br/>FOLD() or some other technique for reducing the number of functions<br/>on the stack at a given time. Nonetheless, it can be the fastest<br/>and cleanest way to accomplish a task, and it is not a technique<br/>which should be overlooked.<br/><br/><br/>---------------------------------------------------------------------------<br/><br/><br/>15. Efficiency<br/><br/>15.1	Parameter Passing<br/><br/>MUSH evaluates every single expression it receives; it has no<br/>memory of what has already been evaluated. Thus, if you write something<br/>like "[extract(get(#100/list),2,1)] [extract(get(#100/list),5,1)]",<br/>the "get(#100/list)" is evaluated twice. This isn't disastrous, but<br/>if instead of "get(#100/list)", you had something like <br/>"iter(setinter(lattr(#100/DATA_*),lattr(#100/NUM_*)),mid(##,rand(5),rand(2)))"<br/>(probably expressed as a U() function), repeating the same thing twice<br/>would be extremely inefficient.<br/><br/>The best way to avoid evaluating complex expressions multiple times<br/>is to pass them as arguments to a U(). Because having extra function calls<br/>generates more overhead, this is a technique which should be restricted<br/>to those instances where the expressions are either very complex, use<br/>computationally expensive operations (such as SETINTER() and other sorting<br/>functions, ITER(), and large SWITCH() expressions), or are used three or<br/>more times.<br/><br/>The second example above is an excellent candidate for such<br/>reduction. The best way to write it would be something of the form:<br/><br/>&amp;EXPR_FN object=[u(AUX_FN, iter(setinter(lattr(#100/DATA_*),lattr(#100/NUM_*)),<br/>	mid(##, rand(5), rand(2))), 2, 5)]<br/><br/>&amp;AUX_FN object=[extract(%0,%1,1)] [extract(%0,%2,1)]<br/><br/>This might be further improved by putting the ITER() in an expression by<br/>itself; it's still of bearable length, but if that particular ITER()<br/>is used another time in the same MUSH program, it should definitely go<br/>into a U().<br/><br/>			----------<br/><br/>One alternative to using U() parameters to avoid evaluating an<br/>expression twice is the SETQ()/R() function combination. There are ten<br/>"registers", 0 through 9, which can be used for temporary storage.<br/>The registers are local to a command list -- that is, they persist<br/>through more than one queue cycle, within the direct chain of<br/>evaluation, as triggered by a $command, attribute/oattribute/attribute,<br/>or the like.  They are set via the function evaluation<br/>"[setq(&lt;register number&gt;,&lt;expression&gt;)]".  This expression evaluates<br/>to a null string, and therefore can be inserted into a string without<br/>affecting its value. The R() function is used to retrieve the<br/>appropriate register; the %q percent-substitution is equivalent<br/>to this function.<br/><br/>The order of parser evaluation definitely makes a difference<br/>when using SETQ(). It is advisable to put all SETQ() functions at<br/>the beginning of any function evaluation; expressions are evaluated<br/>left to right, outside to inside, and you can check whether or not<br/>values are being set in the order you think they are via use of the<br/>DEBUG flag, but for clarity, SETQ() expressions should be placed<br/>at the beginning of the string. Also, you should make sure that <br/>nested U() functions don't attempt to use the same registers; remember<br/>that registers are local to a command evaluation, _not_ to a function<br/>evaluation.<br/><br/>If you need to have nested U() functions that re-use registers (for<br/>example, you have some extremely complex computations that require<br/>large numbers of temporary variables), you may wish to consider use<br/>of the ULOCAL() function instead. This function is identical to U(),<br/>save that R() registers within it are considered "local variables".<br/>That is, the original values of the registers are restored when the<br/>inner function exits, and the original values _are_ passed into the<br/>inner function. In this respect, they are somewhat like VAL parameters<br/>in Pascal, or like ordinary function parameters in C.<br/><br/>You should, however, avoid the unnecessary use of ULOCAL(). While<br/>syntatically cleaner than U(), the copying of variables which is<br/>necessary to preserve the old values also increases the computational<br/>cost of the function. Do, however, note that any use of SETQ() within<br/>a global-defined @function should ALWAYS be done within ULOCAL() unless<br/>you deliberately intend to change the value of the register for the<br/>remainder of the associated command list; otherwise, you might <br/>inadvertently change a value that the calling user is attempting<br/>to preserve.<br/><br/>* * * * *<br/><br/>Please note that SETQ() is a FUNCTION, not a command. It should thus<br/>be nested within a command, NOT placed on its own. In other words:<br/><br/>RIGHT: $test *: @pemit %#=[setq(0,revwords(%0))][u(A_FN,%q0)]--[u(B_FN,%q0)]<br/>WRONG: $test *: [setq(0,revwords(%0))]; @pemit %#=[u(A_FN,%q0)]--[u(B_FN,%q0)]<br/><br/>The most obvious use for SETQ() is to cut down the number of<br/>times a complex expression is evaluated; all that is needed is a single<br/>evaluation as part of a SETQ(). A secondary use is as temporary storage<br/>for some variable needed by FOLD(), FILTER(), or similar functions that<br/>take a limited number of parameters. For example, it is frequently<br/>desirable for a FILTER() to know the dbref of the enactor. But<br/>because the U()-type function called by FILTER() only knows about<br/>the one element of the list being evaluated, it can't get the enactor<br/>unless that information is stored someplace else. In that case, simply<br/>setting '%#' into an R()-register solves the problem.<br/><br/>* * * * *<br/><br/>Related to intelligent parameter-passing is U()'s usefulness<br/>as a tool for hiding details of implementation. For example, there are<br/>many different ways to count the number of times a word occurs in a list.<br/>If a U() called COUNT_FN is used, instead of writing out the expression <br/>every time, by simply changing the COUNT_FN attribute, different methods<br/>can be tried. For example, any of the following would work, if %0 is the<br/>list and %1 is the word:<br/><br/>&amp;COUNT_FN object=[sub(words(%0),words(edit(%b%0%b,%b%1%b,%b)))]<br/><br/>&amp;COUNT_FN object=[words(iter(%0,switch(%0,%1,%0)))]<br/><br/>&amp;COUNT_FN object=[setq(0,%1)][filter(AUX_FN,%0)]<br/>&amp;AUX_FN object=[eq(comp(%0,%q0),0)]<br/><br/>&amp;COUNT_FN object=[setq(0,%1)][fold(AUX_FN,%0,0)]<br/>&amp;AUX_FN object=[add(%0,eq(comp(%0,%q0),0))]<br/><br/>* * * * *<br/><br/>Sometimes, you will want to use the same complex function evaluation<br/>across several commands. In this case, if you have something sufficiently<br/>large and don't mind the extra queue cycle needed, you can use @trigger<br/>to pass that function evaluation as a parameter. @trigger is extremely<br/>useful for parameter manipulation; this is one of the few ways that the<br/>stack variables %0 through %9 can be directly manipulated. Do not ignore<br/>its use as a method for reducing the number of complicated functions that<br/>need to be evaluated.<br/><br/><br/>15.2	How the Queue Works<br/><br/>The "queue" is the place where all commands are placed before<br/>being run. A queue is exactly what it sounds like; the first command<br/>to be put on the queue is the first command to be executed (the queue<br/>is executed from "head" to "tail"). New commands are always put at<br/>the tail end of the queue.<br/><br/>The mysterious MUSH queue is actually three separate queues.<br/>They are referred to as the "Player", "Object", and "Wait" queues.<br/>The first queue is the where commands that are going to be immediately<br/>executed are placed. This includes anything directly typed by a connected<br/>player, plus the first X commands from the object queue (where X is usually<br/>between 0 and 50. It is 3 by default.)  The second queue is where anything<br/>done by an object is placed; when the commands are due to be executed, they<br/>are placed on the player queue. The third queue is where all objects waiting<br/>for some event to occur are placed; when its wait expires, an action in the<br/>wait queue is moved onto the command queue.<br/><br/>The MUSH executes a loop which can be simplified down to:<br/><br/>1. Check to see if any waits have expired. If so, put those commands<br/>   in the command queue.<br/>2. Check to see if anybody typed anything, and if so, put those commands<br/>   in the player queue.<br/>3. Put X commands from the command queue into the player queue.<br/>4. Execute the player queue. This may cause more commands to be put<br/>   at the end of the command queue.<br/>5. Go to 1.<br/><br/>We can think of the player and command queues as simply being a<br/>single queue, as long as we  keep in mind that something typed from the <br/>keyboard frequently executes before a command issued by an object.<br/><br/>Every command in MUSH is a single item on the queue. For the<br/>purposes of this discussion, we will call a "queue cycle" one such<br/>command (rather than referring to a queue cycle as one iteration of<br/>the loop given above, since that's a purely internal measure). Every<br/>command that an object gives is put on the end of the queue.<br/><br/>* * * * *<br/><br/>Certain commands "nest" other commands. For example, the @switch command<br/>frequently takes the format:<br/><br/>@switch %0=foo, {@pemit %#=Got it.}, {@pemit %#=Failed.}<br/><br/>The game does not queue up the @switch and the @pemit one after another.<br/>Instead, it executes the @switch, then puts the correct action at the<br/>end of the queue. Thus, several other commands may occur between the<br/>@switch and the @pemit.<br/><br/>This is further complicated by the way action lists (commands<br/>of the format "@@ action 1; @@ action 2; @@ action 3") are handled.<br/>Given that expression, those three actions are queued one after another.<br/>However, nested action lists are considered part of command they are<br/>part of, and are not queued up until that command is executed. For<br/>example: "@emit 0; @switch %0=foo, {@emit yes; @emit YES},<br/>{@emit no; @emit NO}; @emit 1" is queued as the following:<br/><br/>@emit 0<br/>@switch %0=foo, {@emit yes; @emit YES}, {@emit no; @emit NO}<br/>@emit 1<br/><br/>The first command is executed as you would expect, and the output is "0".<br/>Next, the @switch is executed. The resulting actions are put at the tail<br/>of the queue, so the queue becomes (assuming %0 is foo):<br/><br/>@emit 1<br/>@emit yes<br/>@emit YES<br/><br/>Note that the "@emit 1" executes BEFORE the @emits associated with the<br/>@switch, despite the fact that when the code is typed, the "@emit 1"<br/>comes after the @switch.<br/><br/>This behavior also applies to @dolist, @force, @wait, @trigger,<br/>and all other commands which execute other commands. This can be acutely <br/>obvious when you have a construction like:<br/><br/>@emit Begin; @dolist a b c=@emit ##; @emit End<br/><br/>This produces:<br/><br/>   Begin<br/>   End<br/>   a<br/>   b<br/>   c<br/><br/>That behavior is extremely important when you have commands which must<br/>execute only _after_ all commands in a @dolist has finished executing;<br/>in that type of case, a @wait, either timed or semaphore, is usually <br/>the best solution.<br/><br/><br/>15.3	Pipelining<br/><br/>"Pipelining" is a term borrowed from the jargon of microprocessors. In<br/>that field, it refers to the practice of feeding the next instruction<br/>to the CPU, before the previous instruction has completed. The<br/>"pipeline" ensures that there will always be an instruction waiting<br/>for the CPU.  If the previous instruction was a branch and the<br/>processor predicts the incorrect next instruction, the processor must<br/>then go fetch the correct next instruction; nonetheless, this is not a<br/>loss, since, had there not been a previous fetch, there would have<br/>been a delay anyway while the processor went hunting for the<br/>instruction.<br/><br/>A similar principle can be applied to MUSH programming. Simply put,<br/>there are many MUSH commands which do something along the lines of<br/>the following:<br/><br/>$test *: @switch/first num(*%0)=#-1, {@pemit %#=No such player.},<br/>         {&amp;TEST_OWNER %#=owner(*%0); @pemit %#=Owner test set.}<br/><br/>Note that no matter what happens, you will always have at least two<br/>commands to queue: the @switch, and the @pemit. In the case of correct<br/>syntax, there'll be three commands: the @switch, the @pemit, and the<br/>attribute set.<br/><br/>This doesn't make sense, from the viewpoint of efficiency. Since the<br/>correct case is going to be the one encountered the most frequently,<br/>it shouldn't, ideally, be any slower than the error case.<br/><br/>You can usually save yourself a queue cycle by doing the following:<br/><br/>$test *: @pemit %#=switch(num(*%0),#-1,No such player.,Owner test set.);<br/>         &amp;TEST_OWNER [switch(num(*%0),#-1,#-1,%#)]=owner(*%0)<br/><br/>Basically, we "assume" that the set is going to succeed, most of the time,<br/>and go ahead and do it anyway; to avoid accidentally scribbling on the<br/>attribute if we've encountered an error, we SWITCH() to make the object<br/>try to set TEST_OWNER on a non-existent object in the case of an error.<br/>We have, granted, added extra wildcard matches by the use of two<br/>SWITCH() statements where before there was a single @switch, but we've<br/>saved on a queue cycle, so we've probably won, overall -- this varies<br/>on a case-by-case basis, of course.<br/><br/>We can do this sort of "pipelining" for @trigger, @dolist, and similar<br/>things. It's no longer more efficient when there are more than two queue<br/>cycles involved, but since many MUSH situations do reduce down to something<br/>of this format, this "pipelining" technique proves extremely useful.<br/><br/><br/>15.4	Queue Cycles vs. CPU Cycles<br/><br/>One of the major drawbacks to the "switchless" coding style is<br/>that it tends to reduce the queue cycles needed to perform an action<br/>at the expense of short evaluation times for a command. While the action<br/>may take less time to execute, because other objects' queued commands are<br/>not getting executed between each stage of the action, the overall <br/>computation time ("CPU cycles") needed by that action group may not be<br/>significantly reduced, or, indeed, may actually be increased.<br/><br/>Switchless coding tends to eliminate @switch and @trigger, two<br/>commands which force a "delay", due to the property of these two commands<br/>described in the earlier section on the workings of the queue. In doing<br/>so, however, the programmer frequently uses complex function evaluations<br/>which take a long time to evaluate, and, worse still, may evaluate the<br/>same expression repeatedly.<br/><br/>One simple example of such a tradeoff is the following:<br/><br/>@va object=$test *: @pemit %#=[extract(v(colors),match(v(list),%0),1)]<br/>	[extract(v(sizes),match(v(list),%0),1)] [match(v(list),%0,1)]<br/><br/>  vs.<br/><br/>@va object=$test *: @trigger me/vb=%#,[match(v(list),%0)]<br/>@vb object=@pemit %0=[extract(v(colors),%1,1)] [extract(v(sizes),%1,1)] %1<br/><br/>The second way is slower, since it takes two commands instead of one,<br/>but it's also more efficient. The best way to do the above would be<br/><br/>@va object=$test *: @pemit %#=<br/>	[setq(0,match(v(list),%0))][extract(v(colors),r(0),1)]<br/>	[extract(v(sizes),r(0),1)] [r(0)]<br/><br/><br/>One must also remember that even if the total time to evaluate<br/>a switchless and non-switchless version of the same action is the same,<br/>other players are forced to wait longer for their commands to execute<br/>under the switchless, because the game is running the big complex <br/>evaluation all at once. While the _total_ time spent waiting remains<br/>constant, the time-between-each command is increased.<br/><br/>Therefore, considerate programmers don't program gigantic<br/>expressions which hog the server for several seconds at a time. Good<br/>programmers find better ways to split up the evaluation, so that it<br/>doesn't take several seconds to evaluate. If you write something which<br/>lags a MUSH running at an ordinary speed, you haven't programmed it well.<br/><br/>As more programmers code switchless style, the amount of time<br/>between each command increases. On a fast MUSH, the difference is not<br/>generally noticeable, but if you really want to know if your code is<br/>any good, try running it on a slow machine (NOT a slow network -- you<br/>should victimize a MicroVAX or something similar). The switchless style<br/>when used intelligently shouldn't slow down the game, but it's far too<br/>easy to abuse. Function invocations should be kept to a minimum. <br/>In general, if an attribute containing a command list exceeds about 12<br/>lines of text, it is Too Large.<br/><br/>Intelligent use of switchless programming usually generates strings to<br/>be outputted. Using massive nested switch() constructs usually implies<br/>that something is not as efficient as it could be; the same is true<br/>with iter(). The way a list is stored is frequently more important<br/>than the way it is accessed; by storing data differently, it's often<br/>possible to cut down on the complexity of retrieval.  The switchless<br/>style is best when it eliminates large numbers of nested @switch's;<br/>other uses, especially those involving recursion, should be carefully<br/>considered before being used.<br/><br/>----------<br/><br/>That's the end of this manual; I hope it's been helpful. Please remember<br/>that this is copyrighted material; I've put a lot of work into this and<br/>am not likely to be pleased by others stealing my work. Please see the<br/>first section of this manual for the terms of the copyright and other<br/>information.<br/><br/>Comments, corrections, and suggestions should be emailed to Amberyl,<br/>at lwl@netcom.com<br/>
    </div>
</div>
<script type="text/javascript">
    var selectText = function(element) {
        var doc = document;
        var text = doc.getElementById(element);

        if (doc.body.createTextRange) { // ms
            var range = doc.body.createTextRange();
            range.moveToElementText(text);
            range.select();
        } else if (window.getSelection) { // moz, opera, webkit
            var selection = window.getSelection();
            var range = doc.createRange();
            range.selectNodeContents(text);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    }

    $('a.select-all').click(function () {
        selectText('code');
    });
</script>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
</body>

</html>
<script src="../Scripts/Google.js" type="text/javascript"></script>