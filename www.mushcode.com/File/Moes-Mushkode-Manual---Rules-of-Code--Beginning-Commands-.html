<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Code: Moe&#39;s Mushkode Manual - Rules of Code. Beginning Commands.</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <!-- Apple devices fullscreen -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <!-- Apple devices fullscreen -->
    <meta names="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <!-- Bootstrap -->
	<link rel="stylesheet" href="../Theme/Flat/html/css/bootstrap.min.css">
	<!-- Bootstrap responsive -->
	<link rel="stylesheet" href="../Theme/Flat/html/css/bootstrap-responsive.min.css">
	<!-- jQuery UI -->
	<link rel="stylesheet" href="../Theme/Flat/html/css/plugins/jquery-ui/smoothness/jquery-ui.css">
	<link rel="stylesheet" href="../Theme/Flat/html/css/plugins/jquery-ui/smoothness/jquery.ui.theme.css">
	<!-- Theme CSS -->
	<link rel="stylesheet" href="../Theme/Flat/html/css/style.css">
	<!-- Color CSS -->
	<link rel="stylesheet" href="../Theme/Flat/html/css/themes.css">


    <link rel="stylesheet" href="../Content/site.css">

    <!-- jQuery -->
    <script src="../Theme/Flat/html/js/jquery.min.js"></script>
    <!-- Nice Scroll -->
    <script src="../Theme/Flat/html/js/plugins/nicescroll/jquery.nicescroll.min.js"></script>
    <!-- jQuery UI -->
    <script src="../Theme/Flat/html/js/plugins/jquery-ui/jquery.ui.core.min.js"></script>
    <script src="../Theme/Flat/html/js/plugins/jquery-ui/jquery.ui.widget.min.js"></script>
    <script src="../Theme/Flat/html/js/plugins/jquery-ui/jquery.ui.mouse.min.js"></script>
    <script src="../Theme/Flat/html/js/plugins/jquery-ui/jquery.ui.resizable.min.js"></script>
    <script src="../Theme/Flat/html/js/plugins/jquery-ui/jquery.ui.sortable.min.js"></script>
    <!-- slimScroll -->
    <script src="../Theme/Flat/html/js/plugins/slimscroll/jquery.slimscroll.min.js"></script>
    <!-- Bootstrap -->
    <script src="../Theme/Flat/html/js/bootstrap.min.js"></script>
    <!-- Form -->
    <script src="../Theme/Flat/html/js/plugins/form/jquery.form.min.js"></script>

    <!-- Theme framework -->
    <script src="../Theme/Flat/html/js/eakroko.min.js"></script>
    <!-- Theme scripts -->
    <script src="../Theme/Flat/html/js/application.min.js"></script>

    <!--[if lte IE 9]>
		<script src="js/plugins/placeholder/jquery.placeholder.min.js"></script>
		<script>
			$(document).ready(function() {
				$('input, textarea').placeholder();
			});
		</script>
	<![endif]-->

    <!-- Favicon -->
    <link rel="shortcut icon" href="http://www.mushcode.com/File/img/favicon.ico" />
    <!-- Apple devices Homescreen icon -->
    <link rel="apple-touch-icon-precomposed" href="http://www.mushcode.com/File/img/apple-touch-icon-precomposed.png" />

</head>

<body class="theme-green">
    <div id="navigation">
        <div class="container-fluid">
            <a href="../index.html" id="brand">MUSHCode.com</a>
        </div>
    </div>
    <div class="container-fluid" id="content">
        <div id="left">
            <div class="subnav">
                <div class="subnav-title">
                    <a href="Moes-Mushkode-Manual---Rules-of-Code--Beginning-Commands-.html#" class='toggle-subnav'>
                        <i class="icon-angle-down"></i>
                        <span>About</span>
                    </a>
                </div>
                <ul class="subnav-menu">
                    <li>
                        <a href="../index.html">Overview</a>
                    </li>
                </ul>
            </div>
            <div class="subnav">
                <div class="subnav-title">
                    <a href="Moes-Mushkode-Manual---Rules-of-Code--Beginning-Commands-.html#" class='toggle-subnav'>
                        <i class="icon-angle-down"></i>
                        <span>Files</span>
                    </a>
                </div>
                <ul class="subnav-menu">
                    <li class='dropdown'>
                        <a href="Moes-Mushkode-Manual---Rules-of-Code--Beginning-Commands-.html#" data-toggle="dropdown">Code</a>
                        
<ul class="dropdown-menu">
        <li>
            <a href="../Category/Administration.html">Administration</a>
        </li>
        <li>
            <a href="../Category/Building.html">Building</a>
        </li>
        <li>
            <a href="../Category/Bulletin-Board.html">Bulletin Board</a>
        </li>
        <li>
            <a href="../Category/Combat.html">Combat</a>
        </li>
        <li>
            <a href="../Category/Dynamic-Space.html">Dynamic Space</a>
        </li>
        <li>
            <a href="../Category/Fonts.html">Fonts</a>
        </li>
        <li>
            <a href="../Category/Functions.html">Functions</a>
        </li>
        <li>
            <a href="../Category/Games.html">Games</a>
        </li>
        <li>
            <a href="../Category/Globals.html">Globals</a>
        </li>
        <li>
            <a href="../Category/Mail-Systems.html">Mail Systems</a>
        </li>
        <li>
            <a href="../Category/Other.html">Other</a>
        </li>
        <li>
            <a href="../Category/Schedulers.html">Schedulers</a>
        </li>
        <li>
            <a href="../Category/Time.html">Time</a>
        </li>
        <li>
            <a href="../Category/Vehicles.html">Vehicles</a>
        </li>
        <li>
            <a href="../Category/Vendors.html">Vendors</a>
        </li>
        <li>
            <a href="../Category/Weather-Systems.html">Weather Systems</a>
        </li>
</ul>
                    </li>
                    <li class='dropdown'>
                        <a href="Moes-Mushkode-Manual---Rules-of-Code--Beginning-Commands-.html#" data-toggle="dropdown">Classes</a>
                        
<ul class="dropdown-menu">
        <li>
            <a href="../Category/Administration.html">Administration</a>
        </li>
        <li>
            <a href="../Category/Building.html">Building</a>
        </li>
        <li>
            <a href="../Category/Globals.html">Globals</a>
        </li>
        <li>
            <a href="../Category/Hardcode.html">Hardcode</a>
        </li>
        <li>
            <a href="../Category/Other.html">Other</a>
        </li>
        <li>
            <a href="../Category/Softcode.html">Softcode</a>
        </li>
</ul>
                    </li>
                    <li>
                        <a href="../Manuals.html">Manuals</a>
                    </li>
                </ul>
            </div>
            <div class="subnav">
                <div class="subnav-title">
                    <a href="Moes-Mushkode-Manual---Rules-of-Code--Beginning-Commands-.html#" class='toggle-subnav'>
                        <i class="icon-angle-down"></i>
                        <span>Misc</span>
                    </a>
                </div>
                <ul class="subnav-menu">
                    <li>
                        <a href="../Ascii2Mu.html">ASCII To MUSHCode</a>
                    </li>
                    <li>
                        <a href="../MushList.html">MUSH/MUX List</a>
                    </li>
                    <li>
                        <a href="../MushRoom.html">MUSHRoom</a>
                    </li>
                </ul>
            </div>
            <div class="subnav">
                <div class="subnav-title">
                    <a href="Moes-Mushkode-Manual---Rules-of-Code--Beginning-Commands-.html#" class='toggle-subnav'>
                        <i class="icon-angle-down"></i>
                        <span>Contribute</span>
                    </a>
                </div>
                <ul class="subnav-menu">
                    <li>
                        <a href="../Submit.html">Submit</a>
                    </li>
                </ul>
            </div>
        </div>
        <div id="main">
            <div class="container-fluid">
                <div class="breadcrumbs">
                    <ul>
                        
    <li>
        <a href="../index.html">Home</a>
        <i class="icon-angle-right"></i>
    </li>
    <li>
        <a href="../Category/Softcode.html">Softcode</a>
        <i class="icon-angle-right"></i>
    </li>
    <li>
        <a href="Moes-Mushkode-Manual---Rules-of-Code--Beginning-Commands-.html#">Moe&#39;s Mushkode Manual - Rules of Code. Beginning Commands.</a>
    </li>

                    </ul>
                </div>
                <div class="row-fluid">
                    <div class="span12">
                        



<div class="box">
    <div class="box-title title">
        <h2>
            Moe&#39;s Mushkode Manual - Rules of Code. Beginning Commands.
        </h2>
    </div>
    <div class="box-content">

        <div class="description">
            <p></p>
        </div>

        <div class="author">
            <strong>Author:</strong>
                <a href="../Author/Moe.html">Moe</a>
        </div>

        <div class="author">
            <strong>Category:</strong>
            <a href="../Category/Softcode.html">Softcode</a>
        </div>

            <div class="commands">
            <strong>Commands:</strong>
                    <a href="http://www.mushcode.com/Command/@pemit" class="command">@pemit</a>,
                    <a href="../Command/@sex.html" class="command">@sex</a>.
            </div>

            <div class="functions">
                <strong>Functions:</strong>
                        <a href="../Function/add.html" class="function">add&#40;&#41;</a>,
                        <a href="../Function/brackets.html" class="function">brackets&#40;&#41;</a>,
                        <a href="../Function/get.html" class="function">get&#40;&#41;</a>,
                        <a href="../Function/iter.html" class="function">iter&#40;&#41;</a>,
                        <a href="../Function/lcstr.html" class="function">lcstr&#40;&#41;</a>,
                        <a href="../Function/lwho.html" class="function">lwho&#40;&#41;</a>,
                        <a href="../Function/name.html" class="function">name&#40;&#41;</a>,
                        <a href="../Function/pmatch.html" class="function">pmatch&#40;&#41;</a>,
                        <a href="../Function/switch.html" class="function">switch&#40;&#41;</a>,
                        <a href="../Function/ucstr.html" class="function">ucstr&#40;&#41;</a>,
                        <a href="../Function/xget.html" class="function">xget&#40;&#41;</a>.
            </div>


            <div class="servers">
                <strong>Compatibility:</strong>
                        <a href="../Server/CobraMUSH.html" class="server">CobraMUSH</a>,
                        <a href="../Server/PennMUSH.html" class="server">PennMUSH</a>,
                        <a href="../Server/RhostMUSH.html" class="server">RhostMUSH</a>,
                        <a href="../Server/TinyBit.html" class="server">TinyBit</a>.
            </div>

    </div>
</div>


<div class="box box-bordered box-condensed">
    <div class="box-title">
        <h3>
	        <i class="icon-reorder"></i>
	        MUSHCode for Moe&#39;s Mushkode Manual - Rules of Code. Beginning Commands.
        </h3>
        <div class="actions">
	        <a class="btn btn-mini select-all" href="Moes-Mushkode-Manual---Rules-of-Code--Beginning-Commands-.html#">
                    <i class="icon-resize-full"></i> Select Content
            </a>
        </div>
    </div>
    <div id="code" class="box-content content">
        ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*<br/>|\    /|       |\    /|         |\    /|<br/>| \  / |       | \  / |         | \  / |<br/>|  \/  |oe's   |  \/  |ushkode  |  \/  |anual<br/>~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*<br/><br/>Lesson 1: SO, YOU WANT TO LEARN TO CODE?<br/><br/>	Mushcode is seen by many as complete gibberish, utter lunacy of<br/>syntax, and a headache just waiting to happen. And there are a whole<br/>/other/ set of people that don't know how to code in it. In an endeavour<br/>to bridge the gap between the savvy and the non-initiated, I want to offer<br/>a short and simple tutorial, and include a few nearly-inalienable rules of<br/>coding on a MUSH, in the hopes that this will help people who are having<br/>trouble.<br/>	As a quick disclaimer, short and simple will mean: I'll try not to<br/>belabour any points, it'll come in managable installments, and I'll leave<br/>it up to you to explore the things I talk about in depth.<br/><br/>RULES!<br/><br/>	When I say rules, I mean rules. These are things that if you<br/>follow them, you will lead a happy and prosperous life as a coder. And if<br/>you break them, there will be punishments, usually in the form of<br/>unexpected results from your coding. These are guidelines, sure. But, they<br/>are rules. Things that will give you comfort if you take them to heart.<br/><br/>1) Mushcode is primarily a list-manipulation language. As such, it is<br/>possible to look at everything on a mush as a list. If everything is a list,<br/>then every list has a separator. A separator is the one-character symbol<br/>used to divide a list into its component parts. This is also called a<br/>delimiter. This sentence is a space-separated list of words.<br/>This|is|a|list|too. There@are@many@ways@to@write@a@list.<br/><br/>2) There are two broad categories of mushcode. Commands and Functions.<br/>Commands produce data. Functions don't. Functions manipulate data.<br/>Commands don't. Commands are things like: @describe, move, look, get, WHO,<br/>@pemit, @switch, and @dolist. Functions are things likes: iter(),<br/>pmatch(), lwho(), xget(), and add(). Think of commands as the big pot you<br/>put over a fire, and functions and data all go into them, get mixed up,<br/>converted, and come out a thick rich stew.<br/>   Functions must be evaluated. This means that you must tell the game<br/>that it needs to operate the function on the stuff inside the parentheses.<br/>In order for a function to be evaluated, it .-=MUST=-. be within a<br/>command. You cannot evaluate a function without it being in a command.<br/>Again, the distinction should be emphasized. Commands produce data,<br/>functions manipulate data. There cannot be data for a function to<br/>manipulate, unless a command has produced it. Or, more specifically, all<br/>of the manipulation of data in the world isn't going to matter if it's<br/>never seen.<br/><br/>3) Mushcode functions work from the inside, out. Their syntax is nested,<br/>meaning one structure, or function, is within another, within another.<br/>This is the primary problem with reading mushcode. The nesting occurs with<br/>parentheses, square brackets( [ ] ), and curly braces( { } ). With<br/>practice, you will learn to decipher the nesting of functions.<br/>   Mushcode commands work from left to right, making them much easier to<br/>read. It is possible to group sets of commands to occur together with<br/>curly braces( { } ). This will be explained later.<br/><br/>4) Square brackets are ONLY needed to separate functions to be evaluated,<br/>from plain text that PRECEDES them, within a command or function. This is<br/>the cardinal sin of mushcoding, and the greatest contributor to making<br/>code utterly and completely unreadable. Quite often, it's the greatest<br/>contributor to making it not work, as well. If you include extra square<br/>brackets, you run the risk of not matching a pair of them. They must all<br/>match if you want your code to work. Square brackets tell the MUSH: Hey!<br/>Evaluate what's inside here, because it's different from what just came<br/>before it!<br/><br/>5) Curly braces are ONLY needed to a) group commands together to run at<br/>the same time OR b) go around a block of text to preserve the commas<br/>inside of it. There is no other use for curly braces, other than ascii<br/>decoration.<br/><br/>EXAMPLE<br/><br/>	In this example, I'm going to introduce you to the process of<br/>writing your own code. All of the functions I will use here will work on<br/>either PennMUSH, TinyMUSH(2.x or 3.0), and TinyMUX. What we will do is<br/>make our own +who command, which will list all of the people connected,<br/>and some other relevant information about each player. And, while we're<br/>doing this, I'll show you how the above rules are your friends, rather<br/>than your foes.<br/>	Another common misconception for a lot of players is that commands<br/>like +finger, +where, and +who are standard, and come with the MUSH.<br/>They're not. They are what are called 'softcoded' commands. There are two<br/>types of code on a MUSH, hardcode and softcode. Hardcode is things like<br/>look, @describe, WHO, and @dig. These are commands that are built into the<br/>mush. Commands like +finger, +where, and +who are called 'softcoded'<br/>commands because they are coded in using mushcode. You can modify their<br/>appearance, their functionality, or eliminate them altogether.<br/>	Softcoded commands are stored in attributes on an object. All<br/>mushcode is stored in attributes, on an object. The attributes can be<br/>named anything you would like, though I do suggest adopting a standard<br/>system, or convention, for your naming. It helps you later, when you want<br/>to go back and edit an attribute, if the purpose of the code is easy to<br/>deduce based on the name of the attribute in which it is stored. For<br/>example, if an attribute is going to hold a +pay command, you could(and<br/>likely should) name that attribute CMD_PAY. You would set that attribute<br/>on an object by typing: &amp;CMD_PAY Object=&lt;text&gt;. If you were storing some<br/>data, for example the names of all of the current players in a card game,<br/>you could name that attribute DATA_PLAYERS.<br/>	Let's look at the anatomy of a very simple command.<br/><br/>&amp;cmd_hello #1234=$hello:@pemit %#=Hello, world!<br/><br/>	Yes, that's a command. What it does is when the player types<br/>'hello', it will send that player the message 'Hello, world!' back.<br/>'Hello, world' is the first message produced when learning almost any<br/>coding language, so here is the mushcode version of it. Let's examine<br/>parts of this command. &amp; is the symbol that tells the mush that we are<br/>setting an attribute on an object. cmd_hello is the name of this<br/>attribute. The name was chosen to show that this attribute has a command<br/>in it, and that command is hello. #1234 is the dbref(database reference)<br/>number of the object on which we are storing this attribute. The = sign<br/>says to the mush 'here is what I want to store'.<br/>	The $ symbol designates the beginning of what the user has to type<br/>in to make the command work. Everything between the $ and the : is the<br/>command, and everything after the : is the code that will be run when the<br/>command is typed. In this case, the user has to type 'hello' in order to<br/>make the code run. If this command were the +where command, it would look<br/>like: $+where:<br/>	The next part of our command is the actual code itself. @pemit is<br/>a command that is hardcoded into the mush which sends the specified<br/>message to just one object. Pemit = Private emit. The next symbol is one<br/>of, if not the most commonly used substitution in mushcode. Mushcode<br/>allows you to substitute simple symbols for things, such as your location,<br/>the name of an object, and in this case, the dbref of the object that used<br/>the command. If a player Mungo with the dbref #99 typed 'hello', %# would<br/>be the same as #99. There are a number of substitutions in mushcode, and I<br/>invite you to type 'help substitutions' on your mush of choice for more<br/>information on them. So, we are going to send a private emit, or pemit, to<br/>the object that used the command. We specify the message to be sent with<br/>the equals sign. In this case, our message is 'Hello, world!'.<br/>	Now, we have examined all of the elements of a command. In short:<br/>&amp;&lt;attribute name&gt; &lt;object&gt;=$&lt;command text&gt;:&lt;code&gt;. Yes, that is all there<br/>is to making your own commands on a mush. A brief sidenote here, is that<br/>mushes require that you have a specific configuration of flags so that the<br/>game knows that the object on which you are storing your commands should<br/>be checked whenever a player types in a command. On PennMUSH, this is @set<br/>&lt;object&gt;=!no_command. That clears the no_command flag, letting the object<br/>have user-defined commands on it. On TinyMUSH, you must @set<br/>&lt;object&gt;=commands, which /puts/ a flag on the object telling the mush to<br/>check it for commands.<br/><br/>A COMMAND<br/><br/>	Now on to making our own command. @create an object for this, or<br/>use one that you already have handy. Make sure the flags on it are<br/>appropriate, as noted above. We are going to call our command +mywho, so<br/>as not to conflict with the possibility of your mush already having a +who<br/>command installed. In the spirit of consistency, we should store this<br/>command in an attribute named cmd_mywho. For the rest of this lesson, I'll<br/>use the abbreviation 'obj' to reference the object on which our code is<br/>stored.<br/>	Like our hello command, we want something that will return our<br/>output to just one player, the one that typed the command. So, our mywho<br/>command is going to start off just the same, with @pemit %#=. Even the<br/>great +finger, +where, and +who commands are structured this way. They<br/>return their output just to the player who typed the command.<br/>	Here you will learn your first function. Again on your mush of<br/>choice, type: help lwho(). The lwho() function, as you will read, returns<br/>the list of dbrefs for all connected players. We'll start with this, as<br/>this is the basis of our mywho. This tells us who is connected, albeit<br/>with only their dbrefs.<br/><br/>&amp;cmd_mywho obj=$+mywho:@pemit %#=lwho()<br/><br/>	Type it out. Don't cut and paste it. Learn what it's like to type<br/>those % signs and parentheses. You'll be doing a lot of it, and you might<br/>as well get used to it, because when you're writing your own code, there<br/>won't be anything from which to cut and paste. Once you have this typed<br/>in, and you're sure the flags are set properly on your object, type:<br/>+mywho<br/>	You should have gotten at least one dbref(yours) in return. If you<br/>didn't, examine your object and make sure that your code matches what is<br/>displayed above, exactly. If it doesn't, redo the attribute. Once you have<br/>it working, give yourself a pat on the back. You just coded your first<br/>command!<br/>	However, it's not overly useful. Typing WHO tells you more than<br/>this command does, so we need to make it better. Now, here is where I go<br/>back to the rules that I talked about at the beginning. Rule #1 says:<br/>Everything is a list. Mushcode is a list-manipulation language. So, let's<br/>learn how to manipulate our list of dbrefs so that we can get some more<br/>information out of our command.<br/>	On your mush of choice, type: help iter(). Read it, and try not to<br/>cry. iter() is a very powerful function, and as such, the developers of<br/>mushes the world around have the difficult job of describing a great deal<br/>of functionality in a small amount of space. I will attempt to provide a<br/>layman's description of what iter() does, without confusing you further.<br/>The abbreviation 'iter' stands for 'iterate', which is a computer term<br/>for: Do the same thing to every member of a list. The dictionary says:<br/>iterate(v.) - to say or do again. This is precisely true. When you iterate<br/>through a list, you do the same thing again, to each member of the list.<br/>	So, we have a list, lwho(), and we have a tool, iter(), to process<br/>that list. Let's start putting them together. The first thing we want to<br/>do is get a name for each of those dbrefs. There is a function for that,<br/>as well, and not surprisingly it is called name(). You can read the<br/>helpfile for the name() function, and it will tell you that the syntax for<br/>it is: name(&lt;dbref&gt;). Here is how we would combine lwho(), name(), and<br/>iter() to get what we want: iter(lwho(),name(##))<br/>	I reference Rule #3 from above now. Mushcode works from the<br/>inside, out. As you read in the help file, iter() takes the form of:<br/>iter(&lt;list&gt;,&lt;actions&gt;,[&lt;delimiter&gt;],[&lt;output separator&gt;]). The last two<br/>are optional parts of the iter(). iter() will assume that your list is<br/>separated with spaces, so you don't have to specify a delimiter(fancy word<br/>for the character that separates a list). iter() also outputs a<br/>space-separated list by default, so you don't have to specify a new output<br/>separator, unless you want something /other/ than a space.<br/>	Now, what is ##? ## is another substitution. The iter() function<br/>requires some way to signify the current member of the list, on which it<br/>is performing the actions. For each member of the list, iter() does its<br/>actions to that member. If our lwho() returned the list: #1 #4 #10, and we<br/>did the iter() from above, it would do the following: name(#1), then<br/>name(#4), and finally, name(#10). Each time, ## represents the current<br/>member of the list.<br/>	Let's apply this newfound knowledge to our +mywho.<br/><br/>&amp;cmd_mywho obj=$+mywho:@pemit %#=iter(lwho(),name(##))<br/><br/>	Again, type it out. Learn how the functions feel under your<br/>fingers. Make sure you get all the parentheses. Once you have it typed in,<br/>type: +mywho. You should get at least one name(yours) back. If you didn't,<br/>examine your object and make sure that your code matches what is above,<br/>exactly. Assuming it worked, be proud of yourself. You just used three<br/>functions, at once. You now have a command at your disposal which will<br/>output the names of all of the connected players on the mush.<br/>	Not enough, you say? Oh, alright. Let's do some more with this<br/>list. First, let's arrange our list so that the names are in a column,<br/>rather than a row. This entails putting a carriage return between the<br/>names. There are two ways to do this, and I will show you both of them and<br/>let you choose which method you want to adopt, for your own. Fortunately,<br/>they are both done using iter(), so are simple to demonstrate.<br/><br/>iter(lwho(),name(##),,%R)  OR iter(lwho(),%R[name(##)])<br/><br/>	I'll explain them in order. The first one takes advantage of the<br/>syntax of iter(). It uses what is called an output separator, which is a<br/>one-character symbol that separates the outputted list. One-character?<br/>There's two there! %R! %R is a substitution for a carriage return, and is<br/>treated as a single character by the MUSH. So, it's valid.<br/>	The second one is a bit more intuitive, but still useful. iter()<br/>by default outputs a space-separated list. And if we wanted to put a<br/>carriage return in between the members of that list, we could either put<br/>the %R at the beginning or end of our action list. There's a reason for<br/>putting it at the beginning, though, and I'll show you what that is. If<br/>you consider this list: Alpha Beta Gamma, and the code: iter(Alpha Beta<br/>Gamma,##%R). From your now vast experience with iter(), you should be able<br/>to make a fair guess at how this will come out. Here is what it would<br/>return:<br/><br/>Alpha<br/> Beta<br/> Gamma<br/><br/>	Accurate, but not what we want. iter() is putting the %R precisely<br/>where you told it to, which is right after each member of the list. iter()<br/>puts a space between each member, so we wind up with the list I showed you<br/>above. If we move the %R to the front of the action list, we will get the<br/>following output.<br/><br/>Alpha <br/>Beta <br/>Gamma<br/><br/>	Which looks much better, because the space that exists is at the<br/>end of each item, and therefore not seen. The carriage return comes before<br/>each element, which brings it down to a new line, left-justified very<br/>nicely.<br/>	Going back to our +mywho command, you should be able to see why we<br/>would do: iter(lwho(),%R[name(##)]). This is the same output you would get<br/>if you used: iter(lwho(),name(##),,%R). However, there is a difference in<br/>this version, because this is our first usage of the square brackets.<br/>	I'll refer you to Rule #4 from above. Square brackets separate<br/>functions to be evaluated from the plain text that precedes them. The %R<br/>is a substitution, that produces a carriage return. But, it comes before<br/>the name() function. If we tried to leave out the square brackets around<br/>the name() function, we would get the following from our list of #1 #4<br/>#10:<br/><br/>name(#1) <br/>name(#4)<br/>name(#10)<br/><br/>	It's interesting, but it's not what we want. We have to tell the<br/>mush to evaluate our name() function. So, since we have a %R before the<br/>function, we have to enclose it in square brackets. For the rest of this<br/>tutorial, I am going to work with the iter(lwho(),name(##),,%R) version of<br/>the code. If you choose to use the other one, the modifications will be<br/>simple to make, between the two. Now, our +mywho should look like:<br/><br/>&amp;cmd_mywho obj=$+mywho:@pemit %#=iter(lwho(),name(##),,%R)<br/><br/>	Which is going to give us the list of connected players, in a<br/>left-justified column on our screen. Not enough, you say? Great. I agree.<br/>We want to know what makes this list of players stand out. For example,<br/>perhaps we would like to know which players have their @sex set to Male,<br/>and which have their @sex set to Female. Other options include<br/>highlighting those players who have a particularly large idle time. There<br/>are many things you can do. We'll start with the gender test, as that<br/>allows us to introduce the functions that fetch information.<br/>	On your mush of choice, read help xget(). If you are on<br/>TinyMUSH2.2, you won't have the xget() function, but you will have get().<br/>xget() is faster, and becoming more widely accepted as the<br/>information-fetching function of choice. In this case, we are going to use<br/>the xget() function to retrieve the value of the player's SEX attribute,<br/>which they set with the @sex me=&lt;Male|Female&gt; command. The xget() function<br/>takes the syntax of: xget(&lt;dbref&gt;,&lt;attribute&gt;).<br/>	Just to give you a hint of how this function works, let's issue<br/>the following command, which looks startlingly like our mywho command:<br/><br/>say iter(lwho(),xget(##,sex),,%R)<br/><br/>	You should get a list of the genders of the people currently<br/>connected on the mush. It's possible some of these people don't have their<br/>@sex attribute set. However, for the most part, this should have returned<br/>a column of text that looked something similar, but not exactly like:<br/><br/>Male<br/>female<br/>m<br/>male<br/>f<br/>female<br/>please<br/><br/>	What this has done is iterated(there's that word again) its way<br/>through the list of connected players, and retrieved the value of their<br/>sex attribute. Pretty simple. Now, how are we going to make this work for<br/>our mywho? Pretty simply, now that we have a grasp of xget().<br/><br/>A STEP FURTHER<br/><br/>	We're going to learn another function, and along with iter(), one<br/>of the two most-used functions in all of mushcode. switch() lets you test<br/>one piece of information against many other cases, and if it matches,<br/>perform an action list, or if none match, you can perform a 'default'<br/>action. This is similar in function to the @switch command, though there<br/>are some small differences.<br/>	@switch will test against all the cases you specify, unless you<br/>use @switch/first. (See 'help @switch' for the gory details). switch()<br/>will always stop after the -first- match it gets. So, here's the syntax of<br/>switch(), for you to know and love, forever'n ever:<br/><br/>switch(test<br/>data,case1,actions1,case2,actions2,case3,actions3,...,defaultactions)<br/><br/>	Here's how it works. Switch() takes the test data, and compares it<br/>to case1. If it matches, it does what is specified in actions1. If it<br/>doesn't, it compares it to case2. If -that- matches, it does what is in<br/>actions2. It keeps going until it either matches a case, or runs out of<br/>cases, in which case it will do the default set of actions, if some have<br/>been specified.<br/>	It sounds like a lot, and yet not much, all at the same time.<br/>Trust me, you'll come to love and treasure switch(). Here's how we're<br/>going to apply it to our mywho command. We're going to capitalize the<br/>names of all the people who have their sex set to female.<br/>	Looking at our syntax for switch() above, we need something that<br/>is test data. This is what we are going to compare to each of our cases.<br/>Our cases, as they are, consist of female, and everything else. We're only<br/>testing to see if their gender is set to female, and then we will put<br/>their name in all upper case. What are we going to test to see if it's<br/>female? The sex attribute of each connected player. We know this will be<br/>done inside of our iter(), so each connected player will be referenced as<br/>##. Therefore, our test data becomes: xget(##,sex)<br/>	So, now we can build our switch this far:<br/><br/>	switch(xget(##,sex),female,<br/><br/>	Now, if it does match at being female, we need to put the name of<br/>the character in all upper case. Mush provides us with a very simple way<br/>to do this, through the use of the ucstr() function. Yes, that means:<br/>upper case string. Give yourself a cookie if you realized that at first<br/>glance. We already know from our existing command that the name of the<br/>character can be retrieved using the name() function, and since we know<br/>from rule #3 above that mushcode works inside out, we can then construct:<br/>ucstr(name(##)) for our action list. Now our switch looks like:<br/><br/>	switch(xget(##,sex),female,ucstr(name(##))<br/><br/>	Not too confusing, right? If it was, do yourself the favour of<br/>going back in this document and re-reading any sections that confused you.<br/>Trust me, it's better for you to understand everything we've done up to<br/>this point than just nodding your head and smiling.<br/>	Foraging onwards, we will now take advantage of switch()'s ability<br/>to take a default actions list, if none of the cases matched. Since we are<br/>only testing against female, anything else would be a default. Everyone<br/>who isn't female will just have their name returned. And our switch() will<br/>be done, so now it looks like this:<br/><br/>	switch(xget(##,sex),female,ucstr(name(##)),name(##))<br/><br/>	Now we want to put this into our mywho command.<br/><br/>&amp;cmd_mywho obj=$mywho:@pemit<br/>%#=iter(lwho(),switch(xget(##,sex),female,ucstr(name(##)),name(##)),,%R)<br/><br/>	Yeah, it's growing, I know. It's only going to get worse, or<br/>better, depending on your viewpoint. Once you've got this typed in(yes,<br/>type it out. Don't just cut and paste. You're not going to be able to cut<br/>and paste original code later, so get used to typing it on your own now.),<br/>run your mywho command again. You should get a column of names, ideally<br/>with some that are presented in all upper-case.<br/><br/>WILDCARDS (No, not jokers or one-eyed jacks, but close)<br/><br/>	Now, there may be the instance that there are some names on that<br/>list that are female characters, but aren't in all-caps. Why is this? It's<br/>likely that these characters have set their @sex to something other than<br/>just 'female'. It may be f, fem, or Female. You have just encountered one<br/>of the oldest problems of being a programmer. The user never types in what<br/>you want them to. Quite often, we have to go to great lengths to make sure<br/>that whatever the user types in will work for us. This is called 'robust<br/>programming'. It's also called 'How to get grey hair'.<br/>	Let's level the playing field here. Let's learn about wildcards.<br/>Wildcards are symbols in mushcode that work identically to a wild card in<br/>a card game such as poker(hence their name: wildcards). As a one-eyed jack<br/>can be used to match any card in the deck, wildcard symbols are things<br/>that can be used to match against any one or many characters. There are<br/>two wildcards in mushcode, ? and *. ? matches against one character, and *<br/>matches against any number. Here's a brief example of how they work. d?g<br/>would match against 'dig', 'dog', and 'dug', but not 'drag'. d*g would<br/>match against 'dig', 'dog', 'dug', 'drag', and 'didn't have a dime so went<br/>walking'.<br/>	switch() will be case sensitive, so in order for us to hopefully<br/>match against any variation of the word 'female', we will have to make<br/>sure that our test data is the same case of letters as our individual<br/>cases in switch(). Lots of 'case' in there, I apologize. Just as there is<br/>a ucstr(), there is a lcstr() as well, and it's quite handy for this<br/>particular situation. I offer the following as an alternative to our<br/>previous attempt at mywho:<br/><br/>&amp;cmd_mywho obj=$mywho:@pemit<br/>%#=iter(lwho(),switch(lcstr(xget(##,sex)),f*,ucstr(name(##)),name(##)),,%R)<br/><br/>	Not much bigger, is it? We added one function, lcstr(), to put<br/>whatever their sex attribute is in all lower case. Then, we changed our<br/>switch() case to f*, in order to trap anything that starts with the letter<br/>'f'. Without going into detail, this obviously can cause some other<br/>problems, if players choose to set their @sex to something<br/>rather...obscene. I'll leave that to you to figure out how to avoid.<br/>	Now, let's exploit switch() a bit more. Let's upper case the names<br/>of the female players, and put a tab before the names of the male players.<br/>Anyone set to anything other than male or female, including Neuter, will<br/>have no change whatsoever. This is simple to accomplish, as it only<br/>involves adding a case to our switch().<br/><br/>&amp;cmd_mywho obj=$mywho:@pemit<br/>%#=iter(lwho(),switch(lcstr(xget(##,sex)),f*,ucstr(name(##)),m*,%t[name(##)],name(##)),,%R)<br/><br/>	Not too bad, right? Now, run the command, by typing: mywho. You<br/>should get a list of characters, some upper-cased, some with a tab in<br/>front of their name, and some with no change at all. You've just written a<br/>relatively useful mushcode command, from start to finish. You've<br/>incorporated functions, attributes, commands, substitutions,<br/>wildcards...and you've made it all work.<br/>	Take a moment to congratulate yourself. Then, ask yourself if you<br/>want to go on and learn some of the more interesting things you can do<br/>with mushcode. If you do, go on to lesson #2 in Moe's Mushcode Manual.<br/>
    </div>
</div>
<script type="text/javascript">
    var selectText = function(element) {
        var doc = document;
        var text = doc.getElementById(element);

        if (doc.body.createTextRange) { // ms
            var range = doc.body.createTextRange();
            range.moveToElementText(text);
            range.select();
        } else if (window.getSelection) { // moz, opera, webkit
            var selection = window.getSelection();
            var range = doc.createRange();
            range.selectNodeContents(text);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    }

    $('a.select-all').click(function () {
        selectText('code');
    });
</script>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
</body>

</html>
<script src="../Scripts/Google.js" type="text/javascript"></script>