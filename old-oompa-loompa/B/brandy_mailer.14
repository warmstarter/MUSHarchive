###############################################################################
#                                            code written by Brandy@CrystalMUSH
#                                            for MUSH 2.2 or later *ONLY*
#                                        
# NOTES AND CAUTIONS:  This file should only be installed on systems
# that do not currently have my mailer installed, or on systems already
# running version 13 (since 13 has been out for a LONG time, this shouldn't
# be a hardship).
#                                        
# Notes on the formating of this file:                                         
#  - is used to separate attributes
#  # in the first column means a comment
#  all leading blanks should be stripped, but tailing ones should not
#
# This +mail code is available via anonymous FTP from
# ftp.visi.com in files:
#   /users/cag/brandy_mailer.14
#   /users/cag/mail_help
#
# A tool that parses this format is available in the same directory in file:
#   amolitor_mush_unformatter.c
#
# Carol 
# a.k.a Brandy@CrystalMUSH
#
# MAILING LIST:
#
# To be kept abreast of patches and upgrades, or if you just want to 
# make comments/suggestions whatever, subscribe to brandy-mail@lupine.org 
# by sending an email message to listserv@lupine.org, with 
# 'subscribe brandy-mail MyNameHere' in the body of the mail message.
#
###############################################################################
#
# Changes since version 14 was released:
#
#   June 25, 1997    fixed problem in +edit text and +edit subject 
#                    (squish where s should be)
#
#   June 26, 1997    fixed problem in store_letter where message 
#                    displayed to mail originator was slightly 
#                    wrong for mailboxes that have a vacation or 
#                    reject set
#
#   June 26, 1997    Modified keyword match to be smarter
#
#   June 26, 1997    changed strlen to words in remove folder command
#                    when checking to see if a folder is empty
#
#   July 22, 1997    Fix bug where global aliases within global aliases
#                    were lost upon startup.
#
#   August 6, 1997   Fixed bug in expand_letter_range where keyword
#                    author:<name> was occasionally matching more than
#                    it should
#
#   August 8, 1997   Added new commands '+replace subject=<text>' and
#                    '+replace subject <letter # or keyword> = <text>
#
#                    changed +status of mail sent to <name> now shows
#                    the outgoing mail number so you can easily +review it.
#
#                    added optional switches to +review <search criteria>
#
#                      /brief or /skim just shows one line per letter that 
#                      matches the search criteria.
#
#                      /full or /read shows the entire mail text of each letter
#                      that matches the search criteria.
#
# Version 14:
#
#  Misc:
#    Updated to use new 2.2 functions:  
#      last(), squish, ulocal, default, hasattr
#    use %q<number> instead of r(<number>)
#
#  Bug fixes.
#   MAJOR BUG fix for +destroy mailbox command
#   fixed bug in +set mail default separator
#   fixed bug in +read, cc line not showing if set
#   fixed bug in +remove filter
#   fixed bug in +status of mail sent to <name>, time read was wrong
#   +edit global aliases and +edit personal alias now filters out 
#     non-player names BEFORE attempting to edit, without bitching about it.
#   fixed +list folders to not crap out on big mailboxes with lots of folders
#     (used to get function limit exceeded)
#    restructured 'expand_letter_range' some to avoid function limit exceeded
#      when +skim author:<name> is done on very large mailboxes.
#   changed 'snag_dbrefs' to verify each dbref is a player 
#      (had a mailbox inconsistency problem when an alias had a player
#      who had an autoforward to someone who wasn't a player anymore)
#   Fixed bug where vacation messages would loop of the mush default
#      switch for @swi is '/all'.
#   Added a restriction for global mail aliases to 14 chars to avoid a
#      server bug
#   Added a restriction for personal mail aliases to 25 chars to avoid a
#      server bug
#
#  Features:
#   forwarded mail now shows up with a FORWARDED flag on a +read, and
#   a F on a skim (request so that people can't fake forwarded messages)
#
#   show 'a' for mailboxes with autoforward set in +mail status
#
#   spell check subject and text when +proof is done (if +spell is installed)
#   (See Andrew Molitor if you're interested in the spell robot)
#
#   +include <letter number or keyword>   (while +replying or writing mail)
#
#   added a debug attribute
#
#   revamped +help per request of Ambar
#
#   removed 'mode' option.  Slimmed enter/finish messages.
#
#   added '+check mail/all' command
#
#   If 'null' is specified as the folder on a mail filter, automatically
#     toss it
#
#   New command:  +set mail option filter reject = <text>.
#   This command comes into play if one or more mail filters have been 
#   defined that point to the 'null' (discard) folder.  If 'filter reject'
#   text is registered, mail containing that text is sent to the originator.
#   (Note that this differs from the pre-existing 'reject' text in that
#   that is when ALL mail is being refused).
#
#   New command:  +verify mail config
#     verifies that @admin space_compress=yes
#     verifies that @swi/first works (don't laugh, I've been called on
#       games to fix 'bugs' where it turned out that certain cases of
#       @swi/first were busted. :P)
#     verifies that @attribute/access mail_config_options=wizard
#     verifies that mail system does not have I or W flags
#     verifies that Wiz-Inherit Object is owned by a wizard and I or W
#     verifies that the mail system is parented to the parent mail object
#     verifies that the mail system is allowed to @create objects
#     NOTE:  I would *like* to verify that 1) remote @pemit's are allowed,
#     2) @attribute/access mail_config_options=!private and 3)
#     @attribute/access mail_sig=!private, but I can't figure out how to
#     do that automatically on generic systems, so y'all will just have to
#     verify that yourself.
#
#   Changed +mail status to show warning message if mailbox is owned by
#     the wrong player.
#
#   Changed hidden command '+sanity check' to automatically fix detected
#   problems
#
#   Added timeout of 'mail-in-progress' stuff (assumes attribute 'last' 
#   is not private, see @list attr_permissions)
#
#   New command:  +set mail option RGA = yes | no
#   (RGA stands for Restrict Global Aliases.  If set to 'yes', only wizards
#   may create global aliases.  Default is no restrictions)
#
#   Added a @startup for the Master Mailbox to automatically clean out
#   dbrefs that no longer are players in global aliases.
#
###############################################################################
#
# The following are the mapping of dbref to object in this file.
# 
#    #300 - Mail System                     
#     #25 - Wiz-Inherit Object         
#      #7 - Master Mailbox                  
#     #13 - Help Text 
#   #4167 - Parent Mail Object   
#
# To modify this file for use on another MUSH, basically, 5 vi commands 
# must be used to change the dbrefs to the ones for the matching objects
# on the MUSH this is being installed on.  Then run it through Andrew 
# Molitor's MUSH code unformatter.  It is then ready for quoting in via 
# tf or whatever.  (For first time installations, see instructions below).
#
#    (brief instructions)
#    create the objects needed 
#    (make sure the mail system and wiz-inherit object has the commands 
#         flag, if your MUSH is configured to care)
#    edit brandy_mailer.14 to reference the relevant dbrefs
#    compile the unformatter:         cc amolitor_mush_unformatter.c
#    then run the mailer through it:  a.out brandy_mailer.14 >mailer
#    and install via tf:              /quote -5 'mailer
#
#   (vi commands to change dbrefs through the file)
#
#   :1,$s/#300/<the dbref on your MUSH for the mail system object>/g
#   :1,$s/#25/<the dbref on your MUSH for the wiz-inherit object>/g
#   :1,$s/#7/<the dbref on your MUSH for the master mailbox object>/g
#   :1,$s/#13/<the dbref on your MUSH for the help text object>/g
#   :1,$s/#4167/<the dbref on your MUSH for the parent mail object>/g
#
# NOTE:
#
#   The personal mail option commands won't work on #1, since there
#   are permission problems with setting attributes on 'god'.  If
#   'god' is so inclined to use +mail and wants personal options
#   set, s/he will need to set the &mail_config_options attribute
#   on him/herself.
#
###############################################################################
#
# For those installing it for the first time....
#
# @create Mail System (must reside in the master room)
# @create Wiz-Inherit Object 
#   (Note: must reside in the master room, this object holds the few mail 
#    commands that need wiz powers)
# @create Master Mailbox
# @create Help Text
# @create Parent Mail Object
#
# @parent Mail System = Parent Mail Object
#
# @set Wiz-Inherit Object=inherit 
#   (Note: the other objects need not and indeed
#   should not be set inherit)
#
# &mail_config_options me=soft
# &mail_config_options me=
# ^_____(just to get that attribute in the list of user attributes)
#
# &mail_sig me=something
# &mail_sig me=
# ^_____(just to get that attribute in the list of user attributes)
#
# @attribute/access mail_config_options=wizard (must be done by god(#1))
# @attribute/access mail_config_options=!private (must be done by god(#1))
# @attribute/access mail_sig=!private (must be done by god(#1))
#
# The Mail System object and the Wiz-Inherit Object must reside
# in the Master Room.  The remaining objects should not be in the
# master room.  Just stick them in a bag somewhere and forget about them. ;)
#
# CAUTION:  In order for the +mailer to work, space compression
# MUST be turned on (@admin space_compress=yes).  This shouldn't
# present a problem since most (all?) MUSHes run this way.
#
# Also, remote @pemit's must be allowed.
#
# The mail system needs to be able to create objects.
#
-
#
# Set the MAILBOXES_NUM_OF_ATTRIBUTEs, only if not previously set by
# a prior installation.
#

@swi hasattr(#7, mailboxes_num_of_attributes) = 0,
  &mailboxes_num_of_attributes #7=1

-
###############################################################################
#
# Data Structures:
#
#  owner_dbref                dbref of who's mailbox this is
#  autoforward                list of players/aliases to autoforward mail to
#  message_timeout            number of seconds (in day multiples) before 
#                             mail will be automatically timed out and deleted.
#  alias-list                 list of personal mail aliases
#  folder-list                list of folder names           
#  out-list                   list of sent letters that have not been deleted
#  out-list-current           current letter of out list (used in +review)
#  current_folder             current folder (default is inbox)
#  mail-in-progress           boolean indicating if mail message in progress
#  author_filter              dbref|folder~dbref|folder~dbref|folder
#  subject_filter             text|folder~text|folder~text|folder
#  vacation                   if set, all incoming mail is stored, but
#                             this text is sent to originator 
#  reject_msg                 if set, all incoming mail is rejected, and
#                             this text is sent to originator
#  filter_reject              message sent to originator of received letter
#                             was filtered to 'null' folder
#  debug_mail                 keep track of last command able to get semaphore  
#  
# per personal distribution list (alias)
#
#   alias-<alias name>        list of dbrefs and/or alias names
#
# per folder
#
#   in-list-<folder>          list of messages in folder
#   current_letter-<folder>   current letter
#
# per mail sent item:
# 
#   out-<num>-time_sent       date/time mail was sent
#   out-<num>-subject         subject of letter (only for 'old' mail)
#   out-<num>-to              TO:    (prettified)
#   out-<num>-cc              CC:    (prettified)
#   out-<num>-bcc             BCC:   (prettified, used in +review)
#   out-<num>-bcc-expanded    dbrefs (used for +read)
#   out-<num>-text            body of mail message
#   out-<num>-replyall_to     sender, to expanded & cc expanded
#   out-<num>-dist            complete distribution list 
#                               <dbref>:<internal # in their mailbox>
#   out-<num>-held            list of who still has a pointer to this letter
#
# per mail received item:
# 
#   in-<num>-time_read        date/time mail was last read
#   in-<num>-flags            U R RR P D M S
#   in-<num>-note             registered via +add note
#   in-<num>-location         <dbref> <number> where letter is stored
#   in-<num>-subject          (only if subject was +replaced)
#
# Note: each player has a mailbox.  On the Master Mailbox, there is an 
# attribute per player of the format &mailbox_<player dbref> which is 
# set to the dbref of their mailbox.
#
###############################################################################
#
# Several people have asked me about the capability to automatically 
# generate +mail during the processing of a command.  This is easily
# done.  The key points to remember are:
#
#   Only Players can use the +mail system, therefore, the code that actually
#   composes and sends the mail will need to be on a Player character.
#
#   The object that does the trigger on the Player character, will either
#   need to be owned by that same player, or it will need to be wiz-owned.
#   It will also have to be set inherit.
#
#   The Player that has the attribute which composes mail will need to 
#   have a permanent mailbox.  There are several ways to accomplish this, 
#   probably the easiest way is to have that player define a personal
#   mail alias.  Mailboxes with personal mail aliases defined do not
#   get automatically deleted when empty.
#
#   Example:
#
#   &wage_command Money System = 
#
#     $+wage *=* reason=*:
#
#       <handle parameter checking and actual wage deposit code deleted>
#
#       @trigger v(ballybran)/wage_notification=
#         %#, 
#         <dbref of who is being paid the wage>,
#         <amount of wage deposited in account>,
#         <reason the wage is being paid>
#
#     (where v(ballybran) holds the dbref of a Player Character and
#      attribute wage_notification holds the code that actually
#      composes and sends the +mail)
#
#   &wage_notification *Ballybran = 
#
#         In this example:
#
#         %0 - dbref of the invoker of the command
#         %1 - dbref of who mail is being sent to
#         %2 - amount of money that %1 received
#         %3 - reason why %0 deposited money in %1's account
#
#    +mail [name(%1)]=Notification of deposit of wage;
#    -[name(%0)] has deposited %2 credits into your account.;
#    -%r%rReason Specified:%b%b%3;
#    --
#
###############################################################################
#
#                  Administrative Configurable Attributes
#
# Feel free to change as desired before installation, or use the provided
# admin commands to change them on the fly later.
#
###############################################################################

#
# 1 - +spell code is installed
# 0 - not available
#

  @swi hasattr(#4167, SPELL_CHECKER_AVAILABLE) = 0,
    &SPELL_CHECKER_AVAILABLE #4167 = 0

#
# dbref of spell checker robot (not applicable if you don't have +spell)
# should be placed into &spell_checker
#
-
#
# This is the mail system-wide default for the 'RGA' option.  There is
# a wiz-only command '+set mail default rga = yes | no'.
#
# 1 - true,  restrict global alias creation to wizards
# 0 - false, global aliases are not restricted         
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make
# upgrades easier for the installer.
#

  @swi hasattr(#7, DEFAULT_RGA_OPTION) = 0,
    &DEFAULT_RGA_OPTION #7 = 0

-
#
# This is the mail system-wide default for the 'delete' option.  There is 
# a wiz-only command '+set mail default delete = hard | soft' to change this 
# and each user may set their own personal default by using command 
# '+set mail option delete = hard | soft'.  Soft deleted messages are just
# marked for deletion and are not actually deleted until a +flush is done.
# They can be recovered by using a +undelete.  Hard deleted messages are
# deleted immediately.
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make 
# upgrades easier for the installer.
#

  @swi hasattr(#7, DEFAULT_DELETE_OPTION) = 0,
    &DEFAULT_DELETE_OPTION #7 = soft

-
#
# This is the mail system-wide default for if mailboxes should be 
# automatically deleted when empty.  This may be changed by wiz-only
# command:  '+set mail option destroy = yes | no | true | false | on | off'.
#
# 1 - true,  mailboxes are deleted
# 0 - false, mailboxes are not deleted 
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make 
# upgrades easier for the installer.
#

  @swi hasattr(#7, DELETE_WHEN_EMPTY) = 0,
    &DELETE_WHEN_EMPTY #7 = 1

-
#
# This is the mail system-wide default for the 'timeout' option.  There is 
# a wiz-only command '+set mail default timeout = <number of days>' to set 
# this.  Wizards may also set a default for an individual mailbox by using 
# the '+set mail option timeout = <number of days> for <name>' command.
#
# Letters that haven't been read within the timeout value span, will be
# automatically deleted.  To further clarify this:   It deletes already-read
# mail that has not been read within the option-set time limit and it also
# deletes mail that has not been read, but was received longer than the
# option-set time limit ago.  If this results in an empty mailbox, the
# mailbox will also be deleted.  Halfway to the timeout value, a
# letter will show up with a 'T' next to it on a +skim to indicate
# it is 1/2 way to the time when it would be deleted.  Simply
# +read'ing the mail again will remove the 'T'.
#
# Users may '+save' letters that they don't want to be timed out.  
# Hopefully, this will be used sparingly.  I didn't particularly
# want to add it, but the user base asked for it, I can see the 
# usefulness of it and Joe Average +mail user likely won't notice 
# the capability is there. ;)
#
# The value is specified in number of days on the commands, but 
# stored in seconds.
#
# Default value is 2 weeks == 1209600 seconds.  
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make
# upgrades easier for the installer.
#

  @swi hasattr(#7, DEFAULT_TIMEOUT_OPTION) = 0,
    &DEFAULT_TIMEOUT_OPTION #7 = 1209600

-
#
# This is the default day of week and time that the periodic letter
# purge will take place.  This value can be changed by admins via
# the '+set mail default purge=<day of week> <hour>:<minute>' 
# It should be set for a day and time that you think the MUSH 
# will be the most idle.  It will take effect the next time 
# the @startup is run on the Master Mailbox.
#
#   <day of week> <hour>:<minute>
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make
# upgrades easier for the installer.
#

  @swi hasattr(#7, DEFAULT_PURGE_TIME) = 0,
    &DEFAULT_PURGE_TIME #7 = Wednesday 04:00

-
#
# This is the mail system-wide default for the 'format' option.  There is 
# a wiz-only command '+set mail default format = standard | compact' to 
# change this and each user may set their own personal default by using 
# command '+set mail option format = standard | compact'.  'compact' mode 
# gives you the same information that 'standard' mode gives you, but 
# without the formatting lines and extra white-space.
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make
# upgrades easier for the installer.
#

  @swi hasattr(#7, DEFAULT_FORMAT_OPTION) = 0,
    &DEFAULT_FORMAT_OPTION #7 = standard

-
#
# This is attribute specifies whether the +save command is enabled
# or disabled for the mail system as a whole.  There is a wiz-only
# command '+set mail default save = enabled | disabled' to change
# this.  This cannot be set for individual mailboxes, although 
# the timeout mechanism can be disabled for a specific mailbox.
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make
# upgrades easier for the installer.
#

  @swi hasattr(#7, DEFAULT_SAVE_OPTION) = 0,
    &DEFAULT_SAVE_OPTION #7 = enabled

-
#
# This is the mail system-wide default for the 'separator' option.  There is
# a wiz-only command '+set mail default separator = space | return' to change
# this and each user may set their own personal default by using command
# '+set mail option separator = space | return'.  'space' means that there is 
# a space inserted between text entered with multiple '-<text>' commands.
# A 'return' means that there is a carriage return inserted.
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make
# upgrades easier for the installer.
#

  @swi hasattr(#7, DEFAULT_SEPARATOR_OPTION) = 0,
    &DEFAULT_SEPARATOR_OPTION #7 = space

-
&DELIVERY_NOTIFICATION #4167=
#
# This is the message which is pemitted to the person who is receiving a 
# new mail message.  Feel free to customize as desired.
#
# Note, this is evaluated, so you can put code in there.  For example:
# 
#   [switch(rand(3), 0, message0, 1, message1, 2, message2)]
#
# Input:
#
# %0 - dbref of who the mail is from
# %1 - urgent flag set? (1 - yes, 0 - no)
# %2 - private flag set? (1 - yes, 0 - no)
# %3 - reply requested flag set? (1 - yes, 0 - no)
# %4 - registered flag set? (1 - yes, 0 - no)
# %5 - folder that letter was stored into
#

  A light blinks on your wrist unit indicating that a new message has been 
  received from [name(%0)] in folder '%5'
  [switch(
    or(%1, %2, %3, %4), 
    1, 
    {
      %b(
      [switch(%1, 1, %b[v(mail_flag_u)])]
      [switch(%2, 1, %b[v(mail_flag_p)])]
      [switch(%3, 1, %b[v(mail_flag_rr)])]
      [switch(%4, 1, %b[v(mail_flag_r)])]
      %b).
    }, 
    .
  )]

-
&PICKUP_NOTIFICATION #4167=
#
# This is the message which is pemitted to the person who is sending a
# mail message.  Feel free to customize as desired.  Yes, it is evaluated
# so code can be put in there.
#

  The mail has been sent.

-
&FORWARD_NOTIFICATION #4167=
#
# This is the message which is pemitted to the person who is forwarding a
# mail message.  Feel free to customize as desired.  Yes, it is evaluated
# so code can be put in there.
#
# %0 - active folder
# %1 - user request
#

  Letter %1 in folder '%0' has been forwarded.

-
&TEXT_ADDED_NOTIFICATION #4167 = 
#
# This is used when a '-<text to add to letter>' command is successfully
# completed.  I know The Way It's Always Been is to not give a prompt,
# but I thought it would be nice to get a response to the command; it
# occasionally freaks me out when I don't.  Feel free to zap this 
# attribute, of course, if y'all'd prefer not having the prompt.  
# That's why it is in its own attribute. :)
#

  Text added.

-

###############################################################################
#
# Miscellaneous attributes:
#
###############################################################################

&MAIL_VERSION #4167=Fri Aug 8, 1997
-
@VM #4167 = #7
-
@VM #25 = #7
-
&MAIL_SYSTEM #4167=#300
-
&MAIL_SYSTEM #25=#300
-
@drain #7
-
@no #7
-
&EQUAL_LINE #4167=repeat(=, 78)
-
&DASH_LINE #4167=repeat(-, 78)
-
#
# Text associated with the various mail flags.  You can change them here
# if you wish.  Putting in commas is not advised.
#

&MAIL_FLAG_RR #4167=REPLY REQUESTED
-
&MAIL_FLAG_P #4167=PRIVATE
-
&MAIL_FLAG_U #4167=URGENT
-
&MAIL_FLAG_R #4167=REGISTERED
-
&MAIL_FLAG_D #4167=MARKED FOR DELETION
-
&MAIL_FLAG_T #4167=TIMEOUT WARNING    
-
&MAIL_FLAG_S #4167=SAVED 
-
&MAIL_FLAG_M #4167=MARKED 
-
&MAIL_FLAG_F #4167=FORWARDED 
-
&SECONDS_IN_DAY #4167 = 86400
-
&SECONDS_IN_DAY #25 = 86400
-
&ENTER_MSG #4167=

  You may now enter the message text.%b%bTo see options, type '-'.

-
&ENTER_MSG_VERBOSE #4167=
-
&ENTER_MSG_TERSE #4167=
-
&FINISH_MSG_VERBOSE #4167=
-
&FINISH_MSG_TERSE #4167=
-
&FINISH_MSG #4167=

  Options: %b+proof, +send, +toss, +cc, +bcc, +edit <part>=<old>/<new> or 
  %r+set mail flag \[!\]<flag>.%b%bTo see expanded option help, type '-'.

-
&NOMAIL #4167=

  There is no mail in folder '[secure(%0)]'.

-
&NO_SENT_MAIL #4167 = 
  
  There is no mail from you remaining in the mail system.

-
&NOFUNC #4167=

  I'm sorry, but function calls are not allowed within an input parameter.

-
&NOT_PLAYER #4167 = 

  You must be a player to use the mail system.

-
&NOT_WRITING_MAIL #4167 = 

  There is not a mail message in progress.

-
&NO_MATCH #4167 = 

  %0:%b%bNo letter matches the specified criteria%1 in folder '%2'.

-
&NO_MAIL_FROM_YOU #4167 = 

  There is no mail from you in %0's mailbox.

-
&overflow_point #7=
#
# This number represent the bytesize (strlen) that a mailboxes_<num>
# can reach before the list of mailbox dbrefs will overflow into the
# next attribute, mailboxes_<num + 1>
#
# Normally set to 3900, just to be safe. This is in an attribute
# exclusively for the reason of ease of testing the overflow code.
#

3900

-
&percent_r #4167=%r
-
&temp_cmd #300=$setnewline *:&newline #4167=%0
-
setnewline %r
-
&temp_cmd #300=
-
###############################################################################
#
# READ related commands:
#
###############################################################################


###############################################################################
#
#                           C H E C K   M A I L
#
###############################################################################
&CHECK_MAIL_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to check to see if there is any unread
#   mail in selected folder of the user's mailbox.  If there is unread 
#   mail, the user is notified of how many unread messages there are 
#   in addition to the total number of letters in the folder.
#
# Command Format:
#
#   +check mail
#
# NOTE:
#
#   A warning is also displayed if the user's 'mail-in-progress' flag
#   is set.
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in current folder
#   2 - name of active folder
#   3 - count of unread letters in current folder
#

  $+check mail: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(%q0),
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#
      @wait %q0 = 
      {
        &debug_mail %q0 = +check mail; 

        @pemit %# = 

           [setq(1, u(get_folder_in_list, %q0))]
           [setq(2, u(get_active_folder, %q0))]
           [setq(3, 
             switch(words(%q1), 0, 0, words(filter(mail_not_read, %q1)))
           )]

          [switch(

            0, 

            words(%q1),
              u(nomail, %q2), 

            %q3, 
              You do not have unread mail in your '%q2' mail folder., 

            You have %q3 unread mail message(s) out of a total of 
              [words(%q1)] in your '%q2' mail folder.
          )]

          [switch(get(%q0/mail-in-progress),
            true, %b%b(Warning:%b Your mail in progress flag is set)
          )];  

         @no %q0
      }
    }

-
&CHECK_MAIL_ALL_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to check to see if there is any unread
#   mail in any mail folders in the user's mailbox.  If there is unread
#   mail, the user is notified of how many unread messages there are
#   in addition to the total number of letters in the folder.
#
# Command Format:
#
#   +check mail/all
#
# NOTE:
#
#   A warning is also displayed if the user's 'mail-in-progress' flag
#   is set.
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in folder
#   2 - name of folder
#   3 - count of unread letters in folder

  $+check mail/a*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER), 
    {
      @pemit %# = u(not_player)
    }, 

    strlen(%q0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    }, 

    {

#
# Snag the semaphore
#
      @wait %q0 = 
      {
        &debug_mail %q0 = +check mail/all; 

        @dolist get(%q0/folder-list) = 
        {
          @pemit %# = 

             [setq(1, get(%q0/in-list-##))]
             [setq(2, secure(##))]
             [setq(3,
               switch(words(%q1), 0, 0, words(filter(mail_not_read, %q1)))
             )]

            [switch(0, 

              words(%q1),,

              %q3,,

              You have %q3 unread message(s) out of 
                [words(%q1)] in mail folder '%q2'.
            )]
        }; 

        @swi 1 = 1, 
        {
          @pemit %# = [switch(get(%q0/mail-in-progress),
            true, %b%b(Warning:%b Your mail in progress flag is set))]; 
          @no %q0
        }
      }
    }

-
&MAIL_NOT_READ #4167 = 

#
# This helper function is used while processing a filter() on a list
# of letters in a mailbox.  Requirements:  return 1 if the letter
# in question has not been read, return 0 otherwise.  Mail that has
# not been read has a time_read field of zero.
#
# NOTE:  strmatch is used here, since field in-<num>-time_read is
# not guaranteed to contain a number, but may contain text as well.
#
# %0 - internal mail number
#
# Assumption:
#
#   %q0 - mailbox dbref
#

  strmatch(get(%q0/in-%0-time_read), 0)

-
###############################################################################
#
#                              S K I M
#
###############################################################################
&SKIM_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to show summary information about mail
#   in selected folder of the user's mailbox.  
#
# Command Format:
#
#   +skim [keyword or letter number]
#
#   The following keywords may be used to limit the output of +skim:
#
#     all (default), current, deleted, first, last, marked, next, previous, 
#     saved, unread author:<name>, subject:<text>, text:<text fragment>
#
#     only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in current folder
#   2 - current letter in active folder
#   3 - user's timeout value                       
#   4 - list of internal letters which match the user specified criteria
#   9 - user's format option
#

  $+skim*: 

    @swi/first 

       [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *[*)),
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +skim%0; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]
          [setq(2, u(get_folder_current_letter, %q0))]
          [setq(3, u(grab_timeout_value, get(%q0/message_timeout), 
            get(%vm/default_timeout_option))
          )]

          [setq(9, u(get_format_option, get(%#/mail_config_options)))]

        1 = eq(words(%q1), 0), 
        {
#
# There is no mail in the mailbox.  Notify the user and release the semaphore.
#

          @pemit %# = [u(nomail, u(get_active_folder, %q0))]
            [switch(get(%q0/mail-in-progress), true,
            %b(Warning:%b Your mail in progress flag is set))];  

          @no %q0
        },

        eq(words(%0), 0),
        {
#
# +skim specified with no params and there IS mail is in the mailbox.
# Simulate the user specifying all letters
#

          @pemit %# = 
            [switch(%q9, standard,
              {[u(equal_line)]%r%r[space(27)]List of Mail Messages%r%r}
            )]
            [space(9)]Sender[space(12)]Subject[space(22)]Size%b%bReceived
            %r[space(9)]------[space(12)]-------[space(22)]----%b%b--------;  

          @dolist %q1 =
          {
            @pemit %# = ulocal(skim_bulk, 
                %#, 
                ##, 
                %q0, 
                %q1, 
                %q2, 
                %q3, 
                u(get_src_dbref, %q0, ##), 
                u(get_src_num, %q0, ##))
          };

          @swi 1 = 1,
          {
#
# Finished showing information about the letter(s) specified. 
# Show the user what the active folder is and release the semaphore.
#
            @pemit %# =

                 [setq(1, u(get_active_folder, %q0))]
                 [setq(2, squish(
                  remove(remove(get(%q0/folder-list), edit(%q1, %b, $)), null))
                 )]

               %rSelected folder:%b%b%q1
               [switch(words(%q2), 0,, 
               %rOther folders:%b%b[u(secure_names, %q2)])]
               [switch(%q9, standard,%r%r[u(equal_line)])]; 

            @no %q0
          }
        },

        {
#
# User specified a parameter.
#

#
# Interpret user input and convert into a list of internal mail numbers
#

          @swi/first 

            [setq(4, 
              ulocal(expand_letter_range, %0, %q1, 
                u(get_folder_current_letter, %q0))
            )]

          1 = strmatch(%q4, *ABORT*),
          {
#
# Error detected in input parameter.  Notify the user and release the semaphore.
#

            @pemit %# = after(before(%q4, ENDABORT), ABORT);  
            @no %q0
          },

          eq(words(%q4), 0),
          {
#
# Could not find any letters to match the specified input parameter.
# Notify the user and release the semaphore.
#

            @pemit %# = u(no_match, +skim, ulocal(format_request, trim(%0)), 
              u(get_active_folder, %q0)); 
            @no %q0
          },

          {
#
# Otherwise, no error and one or more letters match the input criteria.
#

            @pemit %# = 
              [switch(%q9, standard,
                {[u(equal_line)]
                %r%r[space(27)]List of Mail Messages%r%r}
              )]
              [space(9)]Sender[space(12)]Subject[space(22)]Size%b%bReceived
              %r[space(9)]------[space(12)]-------[space(22)]----%b%b--------;  

            @dolist 

#
# Reorder the list of letters to 'skim' into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
              [setq(4, u(filter_list, setunion(%q4, ), %q1))]

            %q4 = 
            {
#
# Display information to user about one letter
# 
              @pemit %# = ulocal(skim_bulk, 
                %#, 
                ##, 
                %q0, 
                %q1, 
                %q2, 
                %q3, 
                u(get_src_dbref, %q0, ##), 
                u(get_src_num, %q0, ##))
            };

            @swi 1 = 1,
            {
#
# Finished showing information about the letter(s) specified. 
# Show the user what the active folder is and release the semaphore.
#

              @pemit %# = 

                 [setq(1, u(get_active_folder, %q0))]
                 [setq(2, 
                   squish(remove(
                   remove(get(%q0/folder-list), edit(%q1, %b, $)), null))
                 )]

               %rSelected folder:%b%b%q1
               [switch(words(%q2), 0,, 
               %rOther folders:%b%b[u(secure_names, %q2)])]
               [switch(%q9, standard,%r%r[u(equal_line)])]; 
              @no %q0
            }
          }
        }
      }
    }

-
&SKIM_BULK #4167=
#
# PURPOSE:
#
#   Obtain summary information for one letter in a mailbox.
#   (This is a helper routine for +skim)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - internal mail message number of letter to obtain information about
#   %2 - dbref of mailbox
#   %3 - list of letters in folder
#   %4 - current letter in active folder
#   %5 - user's timeout value
#   %6 - dbref of where letter is stored
#   %7 - internal mail message where letter is stored
#
# OUTPUT
#
#   A single line of information for the letter specified in %1
#
# Registers Used:
#
#   4 - flags for one letter
#   5 - external letter number
#   6 - name of sender                  
#   7 - subject of letter                          
#   8 - time the letter was read
#
# CAUTION:  use ulocal() when invoking this function
#

  [setq(4, get(%2/in-%1-flags))]
  [setq(5, member(%3, %1))]
  [setq(6, default(%6/out-%7-sender, get(%6/owner_dbref)))]
  [setq(6, switch(type(%q6), PLAYER, name(%q6), destroyed player))]
  [setq(7, get(%2/in-%1-subject))]
  [setq(7, trim(switch(words(%q7), 0, get(%6/out-%7-subject), %q7)))]
  [setq(8, get(%2/in-%1-time_read))]

#
# a '+' is shown before the summary line that represents the current letter
#
  [switch(%1, %4, +, %b)]

#
# a 'M' is shown if the letter is marked (via +mark)
# a 'D' is shown if the letter is marked for deletion (via +delete),
# a 'S' is shown if the letter is marked as 'saved' (via +save)
# a 'T' is shown if the letter is close to being timed out
# A 'U' is shown if the letter has not been read yet,
# A 'F' is shown if the letter was forwarded
# otherwise, just a blank
#
  [switch(
    [gt(match(%q4, m), 0)]+
    [gt(match(%q4, d), 0)]+
    [gt(match(%q4, s), 0)]+
    [gt(match(%q4, f), 0)]+
    %q8+
    [gte(sub(secs(), switch(%q8, 0, 
        convtime(get(%6/out-%7-time_sent)), convtime(%q8))), div(%5, 2))]
    , 1+*+*+*+*+*, M, 
      *+1+*+*+*+*, D, 
      *+*+1+*+*+*, S, 
      0+0+0+*+*+1, T, 
      0+0+0+*+0+*, U, 
      *+*+*+1+*+*, F, 
      %b
  )]

#
# Show a 'n' if there is a note associated with this letter.
#

  [switch(hasattr(%2, in-%1-note), 0, %b, n)]

#
# The letter number
#
  [rjust(%q5\)%b%b, 6)]

#
# The sender of the letter, the name is truncated to sixteen characters
#
  [ljust(mid(%q6, 0, min(16, strlen(%q6))), 18)]

#
# The subject of the letter, truncated to 27 characters
#
  [ljust(mid(%q7, 0, min(27, strlen(%q7))), 29)]

#
# Size of the body of the letter, in bytes
#
  [ljust(strlen(u(%6/out-%7-text)), 6)]

#
# Date and time the letter was received
#
  [mid(get(%6/out-%7-time_sent), 0, 16)]

-
###############################################################################
#
#                      R E P L A C E   S U B J E C T
#
###############################################################################
&REPLACE_SUBJECT_NO_PARAM #300=

  $+replace subject:

    @pemit %# = The syntax is '+replace subject=<text>' or 
      '+replace subject <letter number>=<text>'

-
&REPLACE_THIS_SUBJECT #300=
#
# PURPOSE:
#
#   This command may be used to replace the subject line for a letter 
#   currently stored in your mailbox.
#
#   This way you can replace non-informational mail subjects with ones 
#   that actually indicate to you what the letter is about and make 
#   +skim more useful.
#
# Command Format:
#
#   +replace subject <keyword or letter number>=<text>
#
#   The following keywords are available to specify the scope of 
#   +replace subject:
#
#     current (default), first, last, next, previous
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - internal message number reflecting the specified criteria
#

  $+replace subject=*: 
  
    @swi/first [setq(0, get(%vm/mailbox_%#))]0 = 
    
    strmatch(type(%#), PLAYER),
    {@pemit %# = u(not_player)}, 
    
    not(strmatch(escape(%0), *[*)), {@pemit %# = u(nofunc)},

    strlen(%q0), {@pemit %# = u(nomail, ulocal(get_inbox, %#))}, 
    
    {
      @wait %q0 = 
      {
	&debug_mail %q0 = +replace subject=%0; 
	
	@swi/first 
	
	  [setq(1, u(get_folder_in_list, %q0))]
	  [setq(2, u(get_folder_current_letter, %q0)))]
	  
        1 = 
	
	eq(words(%q1), 0), 
	{
	  @pemit %# = u(nomail, u(get_active_folder, %q0)); 
	  @no %q0
	}, 
	
	{
	  &in-%q2-subject %q0 = %0; 
	  @pemit %# = Subject replaced for message 
	    [u(convert_nums, %q2, %q1)] (%bcurrent%b) in folder 
	    '[u(get_active_folder, %q0)]'.;@no %q0
	}
      }
    }

-
&REPLACE_SUBJECT #300=

  $+replace subject *=*:

    @swi/first [setq(0, get(%vm/mailbox_%#))]0 = 

    strmatch(type(%#), PLAYER), 
    {
      @pemit %# = u(not_player)
    }, 

    not(strmatch(escape(%0), *[*)), 
    {
      @pemit %# = u(nofunc)
    }, 

    strlen(%q0), 
    {
      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    }, 

    {
      @wait %q0 = 
      {
        &debug_mail %q0 = +replace subject %0=%1;

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]
          [setq(2, ulocal(expand_single_letter_range, trim(%0), %q1, 
             u(get_folder_current_letter, %q0)))]1 = 

        eq(words(%q1), 0), 
        {
          @pemit %# = u(nomail, u(get_active_folder, %q0));
          @no %q0
        }, 

        strmatch(%q2, *ABORT*), 
        {
          @pemit %# = after(before(%q2, ENDABORT), ABORT);
          @no %q0
        }, 

        eq(words(%q2), 0), 
        {
          @pemit %# = u(no_match, +replace subject, 
            ulocal(format_request, trim(%0)), u(get_active_folder, %q0));
          @no %q0
        }, 

        {
          &in-%q2-subject %q0 = %1;
          &[u(which_current_letter, %q0)] %q0 = %q2;
          @pemit %# = Subject replaced for message 
            [u(convert_nums, %q2, %q1)][ulocal(format_request, trim(%0))] 
            in folder '[u(get_active_folder, %q0)]'.;
          @no %q0
        }
      
      }
      
    }

-
###############################################################################
#
#                              R E A D
#
###############################################################################
&READ_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to read one or more mail messages in the 
#   selected folder.
#
# Command Format:
#
#   +read [keyword or letter number]
#
#   The following keywords may be used to limit the output of +read:
#
#     all, current, deleted, first, last, marked, next, previous, saved, unread
#     author:<name>, subject:<text>, text:<text fragment>
#
#     Only the first character of the keyword needs to be specified
#
#   A +read with no parameters is equivalent to a +check mail
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - name of active folder           
#   3 - count of unread messages (if no user parameter specified) otherwise,
#       list of internal mail messages which match user criteria
#   4 - user's timeout value                       
#   9 - user's format option                       
#

  $+read*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *[*)),
    {
#
# Function calls are not allowed within an input parameter
#

      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +read%0; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]
          [setq(2, u(get_active_folder, %q0))]

#
# register 9 is used to hold the format option so as not to interfere
# with registers used in read_bulk.
#

          [setq(9, u(get_format_option, get(%#/mail_config_options)))]

        0 = words(%q1), 
        {
#
# There is no mail in the user's mailbox.  Notify the user
# and release the semaphore.
#

          @pemit %# = [u(nomail, %q2)]
            [switch(get(%q0/mail-in-progress), true,
            %b(Warning:%b Your mail in progress flag is set))];  

          @no %q0
        },

        words(%0), 
        {
#
# +read specified with no params, do a +check mail instead
# There IS mail in the user's mailbox.
#

          @pemit %# = 

              [setq(3, switch(words(%q1), 0, 0, 
                words(filter(mail_not_read, %q1))))]

            [switch([words(%q1)]+%q3, 
              0+*, 
                u(nomail, %q2), 

              *+0,
                You do not have unread mail in your '%q2' mail folder., 

              You have %q3 unread mail message(s) out of a total of 
                [words(%q1)] in your '%q2' mail folder.
            )]

            [switch(get(%q0/mail-in-progress),
              true, %b%b(Warning:%b Your mail in progress flag is set)
            )];  

           @no %q0
        },

        {
         
          @swi/first 

#
# Interpret user input and convert into a list of internal mail numbers
# representing the user specified criteria.
#
          [setq(3, 
            ulocal(expand_letter_range,
              %0,
              %q1, 
              u(get_folder_current_letter, %q0)
            )
          )]

          1 = 

          strmatch(%q3, *ABORT*),
          {
#
# Error detected in input parameter.
#
# Notify the user and release the semaphore.
#

            @pemit %# = after(before(%q3, ENDABORT), ABORT);  
            @no %q0
          },

          eq(words(%q3), 0),
          {
#
# Could not find any letters to match the specified input parameter.
#
# Notify the user and release the semaphore.
#
            @pemit %# = 
              u(no_match, +read, ulocal(format_request, trim(%0)), %q2); 
            @no %q0
          },
          {

            @dolist 

#
# Reorder the list of letters to 'read' into the same order as the 
# in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
              [setq(3, u(filter_list, setunion(%q3, ), %q1))]
              [setq(4, u(grab_timeout_value, get(%q0/message_timeout), 
                get(%vm/default_timeout_option))
              )]

            %q3 =
            {
#
# Display information to user about one letter
# 
              @pemit %# = ulocal(read_bulk, 
                %#, 
                %q2, 
                ##, 
                %q1, 
                %q9, 
                %q0, 
                %q4, 
                u(get_src_dbref, %q0, ##), 
                u(get_src_num, %q0, ##)); 

              @tr me/check_if_registered = 
                %#, 
                %q0, 
                ##, 
                u(get_src_dbref, %q0, ##), 
                u(get_src_num, %q0, ##)
            }; 

            @swi 1 = 1, 
            {
#
# Set current letter to be the last letter read
#

              &[u(which_current_letter, %q0)] %q0 = last(%q3); 

#
# Finished showing information about the letter(s) specified.  Release
# the semaphore.  Extra switch is needed to keep the queue accurate.
#
              @swi 1 = 1,
              {
                @no %q0
              }
            }
          }
        }
      }
    }

-
&READ_BULK #4167=
#
# PURPOSE:
#
#   Obtain detailed information for one letter in a mailbox.
#   (This is a helper routine for +read)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - name of active folder
#   %2 - internal mail number of letter to obtain information for
#   %3 - list of letters in active folder
#   %4 - user's format option
#   %5 - dbref of mailbox
#   %6 - user's timeout value
#   %7 - dbref of where letter is stored
#   %8 - internal mail message where letter is stored
#
# OUTPUT
#
#   Detailed display for a single letter
#
# CAUTION:  use ulocal() when invoking this function, therefore ALL
#           registers are available!
#
# Registers Used:
#
#   5 - external letter number
#   6 - cc for one letter               
#   7 - flags for one letter
#   8 - time the letter was read
#

  [setq(5, match(%3, %2))]
  [setq(6, get(%7/out-%8-cc))]
  [setq(7, get(%5/in-%2-flags))]
  [setq(8, get(%5/in-%2-time_read))]

  [switch(%4, standard, {[u(equal_line)]%r})]

#
# Message number
#
  [ljust(Message:%b%b%q5/[words(%3)] in folder %1, 43)]

#
# Date and time received
#
  Received:%b%b[get(%7/out-%8-time_sent)]

#
# Name of sender
#
# (games played here since normally I don't save the 'sender' information
# since it is clear who the sender is by where the mail is stored.  However,
# if the conversion code was used to 'save' mail from older versions, 
# there will be a sender field, which is the only way to determine sender
# at older levels.
#
  %rFrom:[space(5)]

    [setq(9, default(%7/out-%8-sender, get(%7/owner_dbref)))]
    [switch(type(%q9), PLAYER, name(%q9), destroyed player)]

#
# Who the mail was addressed to
#
  %rTo:[space(7)][trim(get(%7/out-%8-to))]

#
# The CC list 
#
  [switch(words(%q6), 0,,%rCc:[space(7)][trim(%q6)])]

#
# If the person reading this mail is on the BCC list, show a BCC line
# with just that person's name.  Other people on the BCC list are not
# identified
#
  [switch(
    match(get(%7/out-%8-bcc-expanded), %0),
    0,,
    %rBcc:[space(6)][name(%0)]
  )]

#
# Subject of the letter
#
  %rSubject:%b%b[trim(get(%7/out-%8-subject))]
  [switch(
    %q7, *A*,%b\( autoforwarded from [name(after(before(%q7, AEND), A))] \)
  )]

#
#
# Private subject of the letter (if a +replace subject was done)
#
  [switch(words(get(%5/in-%2-subject)), 0,,
    %rNew Sub:%b%b[get(%5/in-%2-subject)]
  )]

# If any flags are set, display the flags header text
#
  [switch(words(setinter(%q7, RR P U R D S M F)), 0,, %rFlags:%b%b%b%b)]

#
# check for the URGENT (U) flag
#
  [switch(match(%q7, u), 0,, [v(mail_flag_u)]%b%b)]

#
# check for the REQUEST REPLY (RR) flag
#
  [switch(match(%q7, rr), 0,, [v(mail_flag_rr)]%b%b)]

#
# check for the REGISTERED (R) flag
#
  [switch(match(%q7, r), 0,, [v(mail_flag_r)]%b%b)]

#
# check for the PRIVATE (P) flag
#
  [switch(match(%q7, p), 0,, [v(mail_flag_p)]%b%b)]

#
# check for the MARKED FOR DELETION (D) flag
#
  [switch(match(%q7, d), 0,, [v(mail_flag_d)]%b%b)]

#
# check for the MARKED (M) flag
#
  [switch(match(%q7, m), 0,, [v(mail_flag_m)]%b%b)]

#
# check for the SAVED (S) flag
#
  [switch(match(%q7, s), 0,, [v(mail_flag_s)]%b%b)]

#
# check for the FORWARDED (F) flag
#
  [switch(match(%q7, f), 0,, [v(mail_flag_f)]%b%b)]

  [switch(%4, standard, {%r[u(dash_line)]%r%r},%rText:[space(5)])]

#
# main body of text
#
  [u(%7/out-%8-text)]

#
# If there is a note registered with this mail message, show it.
#
  [switch(
    hasattr(%5, in-%2-note), 
    1,
    {[switch(%4, standard, {%r%r[u(dash_line)]})]
    %rNote:[space(5)][get_eval(%5/in-%2-note)]}
  )]

  [switch(%4, standard, {%r%r[u(equal_line)]})]
  %rOptions:%b +add note=<text>, +delete, +forward, +move, +reply, 
  +replyall, +save

-
&CHECK_IF_REGISTERED #4167=
#
# PURPOSE:
#
#   Determine if a receipt notification needs to be sent.  A receipt
#   notification is sent to the originator of a piece of mail when it
#   has been sent as 'registered' and this is the first time it was
#   read.
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - dbref of mailbox
#   %2 - internal mail number of letter just read
#   %3 - dbref of source mailbox
#   %4 - internal mail number in source mailbox
#
# OUTPUT
#
#   None
#
# Registers used:
#
#   NOTE:  Registers 0, 1, 2, 3, 4 and 9 are set/used in read_command 
#        and shouldn't be stomped on.
#
#   5 - dbref of who to send receipt to            
#   6 - time read
#

  &in-%2-time_read %1 = [setq(6, get(%1/in-%2-time_read))]time(); 

  @swi/first 

    [setq(5, default(%3/out-%4-sender, get(%3/owner_dbref)))]

  1 = 

  and(
    strmatch(%q6, 0), 
    sign(match(get(%1/in-%2-flags), r))
  ), 
  {
#
# The mail was REGISTERED and this is the first time it was read, send an
# acknowledge back to the sender.  
#

    @tr me/store_letter = 
      %1, 
      Receipt Notification, 
      name(%q5), 
      %q5, 
      , 
      , 
      , 
      , 
      , 
      {[name(%0)] has read the message which had a subject 
      line of "[trim(get(%3/out-%4-subject))]" which was originally 
      sent by you on [get(%3/out-%4-time_sent)].}
  }

-
###############################################################################
#
#                                U N R E A D          
#
###############################################################################
&UNREAD_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to mark one or more letters previously
#   read as unread again.
#
# Command Format:
#
#   +unread <keyword or letter number>
#
#   The following keywords are available to specify the scope of +unread:
#
#     all, current, deleted, first, last, marked, next, previous, saved
#     author:<name>, subject:<text>, text:<text fragment>
#
#     only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - list of internal message numbers reflecting the specified criteria
#

  $+unread*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *[*)), 
    {
#
# Function calls are not allowed within input parameters.
#

      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
#
# User does not have a mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +unread%0; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]

#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(2, 
            ulocal(expand_letter_range, %0, %q1, 
              u(get_folder_current_letter, %q0))
          )]

        1 = eq(words(%q1), 0), 
        {
#
# There is no mail in the user's mailbox.  Notify the user and 
# release the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, %q0)); 
          @no %q0
        },

        strmatch(%q2, *ABORT*), 
        {
#
# Error detected in user input.  Notify the user and release the
# semaphore.
#

          @pemit %# = after(before(%q2, ENDABORT), ABORT); 
          @no %q0
        },

        eq(words(%q2), 0),
        {
#
# No letters match the user specified criteria.  Notify the user
# and release the semaphore.
#

          @pemit %# = u(no_match, +unread, ulocal(format_request, trim(%0)), 
             u(get_active_folder, %q0)); 
          @no %q0
        },
        {
#
# Reorder the list of letters to 'unread' into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#

          @dolist 

            [setq(2, u(filter_list, setunion(%q2, ), %q1))]

          %q2 =
          {
#
# Zap the time_read field for the specified letter.  A value of '0'
# for time_read indicates that the letter has not been read yet.
#

            &in-##-time_read %q0 = 0
          }; 

          @swi 1 = 1, 
          {
#
# Finished showing information about the letter(s) specified. 
# Notify user, clean up global variables and release the semaphore.
#

#
# Set 'current letter' to be the last letter marked as unread
#

            &[u(which_current_letter, %q0)] %q0 = last(%q2);  

            @pemit %# = Letter(s) [u(convert_nums, %q2, %q1)]
              [ulocal(format_request, trim(%0))] marked as 'unread' 
                in folder '[u(get_active_folder, %q0)]'.;

            @no %q0
          }
        }
      }
    }

-
###############################################################################
#
#                           A D D   N O T E
#
###############################################################################
&ADD_NOTE_COMMAND #300=
#
# PURPOSE:
#
#
#   This command may be used to store a personal note associated with 
#   the letter specified.  This note will show up on subsequent +read's
#   of this letter.  Warning:  it is also sent along if the letter it
#   is associated with is forwarded to another player.
#
# Command Format:
#
#   +add note to <keyword or letter number>=<text>
#
#   The following keywords are available to specify the scope of +add note:
#
#     current (default), first, last, next, previous 
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - internal message number reflecting the specified criteria
#

  $+add note to *=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *[*)), 
    {
#
# Function calls are not allowed within input parameters
#

      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
#
# User does not have a mailbox
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +add note to %0=%1; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]

#
# Interpret user input and convert into an internal mail number
#
          [setq(2, 
            ulocal(expand_single_letter_range, 
            trim(%0), %q1, u(get_folder_current_letter, %q0))
          )]

        1 = eq(words(%q1), 0), 
        {
#
# Mailbox is empty.  Notify user, clear global variable and release
# the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, %q0));
          @no %q0
        },

        strmatch(%q2, *ABORT*), 
        {
#
# Error detected in user input.  Notify user, clear global variables
# and release the semaphore.
#

          @pemit %# = after(before(%q2, ENDABORT), ABORT); 
          @no %q0
        },

        eq(words(%q2), 0), 
        {
#
# No letter matches the user specified criteria.  Notify the user,
# clear the global variables and release the semaphore.
#

          @pemit %# = u(no_match, +add note, ulocal(format_request, trim(%0)), 
             u(get_active_folder, %q0)); 
          @no %q0
        },

        {
#
# Store the note with the specified letter, update current_letter, 
# notify the user of the action taken and release the semaphore.
#

          &in-%q2-note %q0 = u(clean_text, %1); 
          &[u(which_current_letter, %q0)] %q0 = %q2;
          @pemit %# = Note [switch(words(%1), 0, removed from, added to)] 
            message 
            [u(convert_nums, %q2, %q1)]
            [ulocal(format_request, trim(%0))] 
            in folder '[u(get_active_folder, %q0)]'.;

          @no %q0
        }
      }
    }

-
###############################################################################
#
#                           A D D   N O T E
#
# part 2 (added for user convenience)
#
###############################################################################
&ADD_NOTE_2_COMMAND #300=

  $+add note=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(%q0), 
    {
#
# User does not have a mailbox
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +add note=%0; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]
          [setq(2, u(get_folder_current_letter, %q0)))]

        1 = eq(words(%q1), 0), 
        {
#
# Mailbox is empty.  Notify user, clear global variable and release
# the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, %q0));
          @no %q0
        },

        {
#
# Store the note with the current letter, 
# notify the user of the action taken and release the semaphore.
#

          &in-%q2-note %q0 = u(clean_text, %0); 
          @pemit %# = Note [switch(words(%0), 0, removed from, added to)] 
            message [u(convert_nums, %q2, %q1)] (%bcurrent%b) 
            in folder '[u(get_active_folder, %q0)]'.;

          @no %q0
        }
      }
    }

-
&ADD_NOTE #300 = 

  $+add note: @pemit %# = The syntax is +add note to <number>=<text>.

-
###############################################################################
#
#                              D E L E T E
#
###############################################################################
&DELETE_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to delete one or more of the messages in 
#   a mailbox.  +delete with no parameters will delete the last mail
#   message read.  Either a keyword (listed below) or a list of 
#   mail numbers may be specified.  Example:  +delete 3..5, +delete marked
#
# Command Format:
#
#   +delete <keyword or a list of letter number>
#
#   The following keywords are available to specify the scope of +delete:
#
#     all, current (default), first, last, marked, next, previous, saved, 
#     unread, author:<name>, subject:<text>, text:<text fragment>
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - list of internal message numbers reflecting the specified criteria
#   3 - new current letter
#   4 - external message numbers to delete
#   5 - current folder
#   6 - user's delete option
#

  $+delete*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *[*)), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +delete%0; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]
          [setq(6, u(get_delete_option, %#))]

#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(2, 
            ulocal(expand_letter_range, %0, %q1, 
              u(get_folder_current_letter, %q0))
          )]

          [setq(5, u(get_active_folder, %q0))]

        1 = eq(words(%q1), 0),  
        {
#
# Mailbox is empty.  Notify user and release the semaphore.
#

          @pemit %# = u(nomail, %q5);
          @no %q0
        },

        strmatch(%q2, *ABORT*), 
        {
#
# Error detected in input parameter.  Notify user and release the semaphore.
#

          @pemit %# = after(before(%q2, ENDABORT), ABORT); 
          @no %q0
        },

        eq(strlen(%q0), 0), 
        {
#
# No letters match the specified user input criteria.  Notify user
# and release the semaphore.
#

          @pemit %# = u(no_match, +delete, ulocal(format_request, trim(%0)), 
             %q5); 
          @no %q0
        },

        {

          @dolist 
#
# Reorder the list of letters to delete into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
            [setq(2, u(filter_list, setunion(%q2, ), %q1))]

# Temp variable. List of in-list after deletions.

            [setq(3, squish(u(filter_list, setdiff(%q1, %q2), %q1)))]
#
# Determine what the 'current letter' will be after all requested
# deletions have occurred.  If the last letter in the in-list-<folder> is
# deleted, set 'current letter' to the first letter in the in-list-<folder>.
# Otherwise, set 'current letter' to the letter after the last
# one deleted if hard deleted, and the last letter marked for deletion,
# if soft deleted.
#
            [setq(3, 
              switch(%q6, soft, last(%q2), 
              switch(last(%q2), last(%q1), 
              first(%q3), extract(%q1, add(match(%q1, 
              last(%q2)), 1), 1))))]

#
# Convert the list of internal mail numbers to external mail numbers
# for use in later display to the user.
#
            [setq(4, u(convert_nums, %q2, %q1))]

          %q2 = 
          {

            @swi/first %q6 = soft, 
            {
#
# User has their mail configuration option 'delete' set to soft.  Simply
# mark the bugger for deletion
#
              &in-##-flags %q0 = setunion(get(%q0/in-##-flags) D, )
            }, 

            {
#
# Hard delete.  
#

              @tr me/remove_letter = 
                u(get_src_dbref, %q0, ##), 
                u(get_src_num, %q0, ##), 
                %#, 
                %q0, 
                ##, 
                edit(%q5, %b, $), 
                +delete*
            }
          }; 

          @swi 1 = 1,
          {
#
# Done processing the +delete command.  Notify user of action taken.
#

            &current_letter-%q5 %q0 = %q3; 

            @pemit %# = Message(s) %q4
                [ulocal(format_request, trim(%0))] 
                [switch(u(get_delete_option, %#), 
                hard, deleted from, marked for deletion in)] 
                folder '%q5'.; 

            @no %q0
          }
        }
      }
    }

-
###############################################################################
#
#                             U N D E L E T E      
#
###############################################################################
&UNDELETE_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to remove the 'marked for deletion' flag 
#   previously set by a 'soft' +delete.  Either a keyword (listed below)
#   or a list of letter numbers as shown on a +read or +skim may be
#   specified.  Example:  +undelete 3 or +undelete marked
#
# Command Format:
#
#   +undelete <keyword or a list of letter numbers>
#
#   The following keywords are available to specify the scope of +undelete:
#
#     all, current (default), deleted, first, last, marked, next, previous, 
#     saved, unread, author:<name>, subject:<text>, text:<text fragment>
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - list of internal message numbers reflecting the specified criteria
#

  $+undelete*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *[*)), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +undelete%0; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]
#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(2, 
            ulocal(expand_letter_range, %0, %q1, 
              u(get_folder_current_letter, %q0))
          )]

        1 = eq(words(%q1), 0),  
        {
#
# There is no mail in the user's mailbox.  Notify the user 
# and release the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, %q0));
          @no %q0
        },

        strmatch(%q2, *ABORT*), 
        {
#
# Error detected in input parameter.  Notify the user and release the semaphore.
#

          @pemit %# = after(before(%q2, ENDABORT), ABORT); 
          @no %q0
        },

        eq(words(%q2), 0), 
        {
#
# Could not find any letters to match the specified input parameter.
# Notify the user and release the semaphore.
#

          @pemit %# = u(no_match, +undelete, ulocal(format_request, trim(%0)), 
             u(get_active_folder, %q0)); 
          @no %q0
        },

        {
          @dolist 
#
# Reorder the list of letters to 'undelete' into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
              [setq(2, u(filter_list, setunion(%q2, ), %q1))]

          %q2 = 
          {
            &in-##-flags %q0 = squish(remove(get(%q0/in-##-flags), D))
          }; 

          @swi 1 = 1, 
          {

#
# Finished removing the 'marked for deletion' flag from the letter(s) 
# specified.  Set 'current letter' to be the last letter that had the 
# marked for deletion flag removed from it.  Notify the user and release 
# the semaphore.
#

            &[u(which_current_letter, %q0)] %q0 = last(%q2); 

            @pemit %# = 'Marked for deletion' flag(s) removed from 
              message(s) [u(convert_nums, %q2, %q1)]
              [ulocal(format_request, trim(%0))] 
              in folder '[u(get_active_folder, %q0)]'.; 

            @no %q0
          }
        }
      }
    }

-
###############################################################################
#
#                              C L E A R   
#                          (alias for +delete)
#
###############################################################################
&CLEAR_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to clear one or more of the messages in 
#   a mailbox.  +clear with no parameters will delete the last mail
#   message read.  Either a keyword (listed below) or a list of 
#   mail numbers may be specified.  Example:  +clear 3..5, +clear marked
#
# Command Format:
#
#   +clear <keyword or a list of letter number>
#
#   The following keywords are available to specify the scope of +clear:
#
#     all, current (default), first, last, marked, next, previous, saved, unread
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - list of internal message numbers reflecting the specified criteria
#   3 - new current letter
#   4 - external message numbers to delete
#   5 - current folder
#   6 - user's delete option
#

  $+clear*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *[*)), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +clear%0; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]

#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(2, 
            ulocal(expand_letter_range, %0, %q1, 
              u(get_folder_current_letter, %q0))
          )]

          [setq(5, u(get_active_folder, %q0))]
          [setq(6, u(get_delete_option, %#))]

        1 = eq(words(%q1), 0),  
        {
#
# Mailbox is empty.  Notify user and release the semaphore.
#

          @pemit %# = u(nomail, %q5);
          @no %q0
        },

        strmatch(%q2, *ABORT*), 
        {
#
# Error detected in input parameter.  Notify user and release the semaphore.
#

          @pemit %# = after(before(%q2, ENDABORT), ABORT); 
          @no %q0
        },

        eq(strlen(%q0), 0), 
        {
#
# No letters match the specified user input criteria.  Notify user
# and release the semaphore.
#

          @pemit %# = u(no_match, +clear, ulocal(format_request, trim(%0)), 
             %q5); 
          @no %q0
        },

        {

          @dolist 
#
# Reorder the list of letters to delete into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
            [setq(2, u(filter_list, setunion(%q2, ), %q1))]

# Temp variable. List of in-list after deletions.

            [setq(3, squish(u(filter_list, setdiff(%q1, %q2), %q1)))]
#
# Determine what the 'current letter' will be after all requested
# deletions have occurred.  If the last letter in the in-list-<folder> is
# deleted, set 'current letter' to the first letter in the in-list-<folder>.
# Otherwise, set 'current letter' to the letter after the last
# one deleted.
#
            [setq(3, 
              switch(%q6, soft, last(%q2), 
              switch(last(%q2), last(%q1), 
              first(%q3), extract(%q1, add(match(%q1, 
              last(%q2)), 1), 1))))]

#
# Convert the list of internal mail numbers to external mail numbers
# for use in later display to the user.
#
            [setq(4, u(convert_nums, %q2, %q1))]

          %q2 = 
          {

            @swi/first %q6 = soft, 
            {
#
# User has their mail configuration option 'delete' set to soft.  Simply
# mark the bugger for deletion
#
              &in-##-flags %q0 = setunion(get(%q0/in-##-flags) D, )
            }, 

            {
#
# Hard delete.  
#

              @tr me/remove_letter = 
                u(get_src_dbref, %q0, ##), 
                u(get_src_num, %q0, ##), 
                %#, 
                %q0, 
                ##, 
                edit(%q5, %b, $), 
                +clear*
            }
          }; 

          @swi 1 = 1,
          {
#
# Done processing the +clear command.  Notify user of action taken.
#

            &current_letter-%q5 %q0 = %q3; 

            @pemit %# = Message(s) %q4
                [ulocal(format_request, trim(%0))] 
                [switch(u(get_delete_option, %#), 
                hard, cleared from, marked for deletion in)] 
                folder '%q5'.; 

            @no %q0
          }
        }
      }
    }

-
###############################################################################
#
#                                F L U S H         
#
###############################################################################
&FLUSH_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to flush (delete) all messages that have 
#   been targeted for deletion by doing a soft delete.  These messages
#   show up with a 'D' next to their number on a +skim.  
#
# Command Format:
#
#   +flush
#
# Registers Used:
#
#   0 - dbref of mailbox
#   1 - list of letters in folder
#   2 - count of messages before flush
#   4 - count of messages after flush
#   5 - internal list of letters to flush
#   8 - active folder
#   9 - new current_letter-<folder>
#

  $+flush: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(%q0),
    {
      @pemit %# = There is no mail marked for deletion 
        in folder '[ulocal(get_inbox, %#)]'.
    },
    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +flush; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]
          [setq(5, u(find_letters_to_flush, %q0, %q1))]
          [setq(8, u(get_active_folder, %q0))]
          [setq(9, squish(u(filter_list, setdiff(%q1, %q5), %q1)))]
          [setq(9, 
            switch(
              last(%q5), 
              last(%q1), 
                first(%q9), 
              extract(
                %q1, 
                add(member(%q1, last(%q5)), 1), 
                1
              )
            )
          )]

        0 = words(%q1), 
        {
#
# There is no mail in the user's mailbox.  Notify the user 
# and release the semaphore.
#

          @pemit %# = There is no mail marked for deletion in folder '%q8'.;
          @no %q0
        },

        words(%q5),  
        {
          @pemit %# = There is no mail marked for deletion in folder '%q8'.;
          @no %q0
        },

        {
          @dolist 

#
# Temporarily save away a count of how many messages are in the mailbox.
#
            [setq(2, words(%q1))]

          setunion(%q5,) = 
          {
            @tr me/remove_letter = 
              u(get_src_dbref, %q0, ##), 
              u(get_src_num, %q0, ##), 
              %#, 
              %q0, 
              ##, 
              edit(%q8, %b, $),
              +flush
           }; 

           @swi 1 = 1, 
           {
#
# Done purusing the mailbox, perform cleanup processing.
#

              @pemit %# = 

                  [setq(4, words(%q5))]

                All messages that were marked for deletion have been deleted 
                from folder '%q8'. 
                (%b%q4 deleted, [sub(%q2, %q4)] remain%b); 

              &[u(which_current_letter, %q0)] %q0 = %q9; 
              @no %q0
          }
        }
      }
    }

-
&FIND_LETTERS_TO_FLUSH #4167 = 
#
# PURPOSE:
#
#   This is a helper routine for +flush.  Scan through the list of received 
#   +mail messages, and return a list of internal mail numbers for any
#   that have the 'D' (marked for deletion) flag set.
#
# %0 - mailbox dbref
# %1 - in-list for active folder
#
 
  iter(%1, switch(member(get(%0/in-##-flags), D), 0,, ##))

-
###############################################################################
#
#                             R E P L Y             
#
###############################################################################
&REPLY_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to reply to a received mail message.  A +reply
#   with no parameter specified will reply to the last message read.  A
#   +reply with a <letter # or keyword> specified will reply to the specified
#   message.  The destination will be set to where the original letter came
#   from, the subject will be the same as the original letter, with a 'Re: '
#   prefixed to it.
#
# Command Format:
#
#   +reply [keyword or letter number]
# 
#   The following keywords are available to specify which letter to reply to:
#
#     current (default), first, last, next, previous
#
#   Only the first character of the keyword needs to be specified.
#
# Registers Used:
#
#   0 - dbref of mailbox
#   1 - list of letters in folder
#   2 - internal message number reflecting the specified criteria
#   3 - subject of letter to reply to
#   4 - dbref of source mailbox
#   5 - internal number of source mail in source mailbox
#   6 - originator of mail to reply to
#

  $+reply*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = strmatch(%0, all*),,
#
# +replyall - ignore
#

    not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    strmatch(escape(%0), *[*), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(%q0), 0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +reply%0; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]

#
# Interpret user input and convert into an internal mail number
#
          [setq(2, ulocal(expand_single_letter_range, trim(%0), %q1, 
            u(get_folder_current_letter, %q0)))]

          [setq(4, u(get_src_dbref, %q0, %q2))]

          [setq(5, u(get_src_num, %q0, %q2))]

          [setq(6, default(%q4/out-%q5-sender, get(%q4/owner_dbref)))]

        1 = strmatch(get(%q0/mail-in-progress), true),
        {
#
# Mail message is already in progress.  Notify user 
# and release the semaphore.
#

          @pemit %# = You are already in the middle of sending a message. 
            You must complete that one before you reply to this one.; 

          @no %q0
        },

        eq(words(%q1), 0), 

        {
#
# There is no mail in the user's mailbox.  Notify user and release 
# the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, %q0));
          @no %q0
        },

        strmatch(%q2, *ABORT*), 
        {
#
# Error detected in input parameter.  Notify the user and release the 
# semaphore.
#

          @pemit %# = after(before(%q2, ENDABORT), ABORT); 
          @no %q0
        },

        eq(words(%q2), 0), 
        {
#
# Could not find any letter to match the specified input parameter.
# Notify the user and release the semaphore.
#

          @pemit %# = u(no_match, +reply, ulocal(format_request, trim(%0)), 
             u(get_active_folder, %q0)); 
          @no %q0
        },

        not(strmatch(type(%q6), PLAYER)), 
        {
#
# Original sender is no longer a player.
# Notify the user and release the semaphore.
#

          @pemit %# = Originator of letter 
             [u(convert_nums, %q2, %q1)][ulocal(format_request, trim(%0))] 
             in folder '[u(get_active_folder, %q0)]' is no longer a player.; 
          @no %q0
        },

        {
#
# - Set current letter to the letter being replied to
# - Set mail-in-progress to true
# - Preset 'to' list and 'subject' based on letter being replied to
# - Let user know what to do next
# - Release the semaphore
#

          &[u(which_current_letter, %q0)] %q0 = %q2;
          &mail-in-progress %q0 = true; 
          &mail-in-progress-to %q0 = name(%q6); 
          &mail-in-progress-to-expanded %q0 = %q6; 

          &mail-in-progress-subject %q0 = 

            [setq(3, get(%q4/out-%q5-subject))]
            [setq(7, get(%q0/in-%q2-subject))]

            switch(words(%q7), 0, 
            switch(mid(%q3, 0, 3), Re:, %q3, Re:%b%b%q3), %q7); 

          @pemit %# = u(enter_msg); 

          @no %q0
        }
      }
    }

-
###############################################################################
#
#                             R E P L Y A L L
#
###############################################################################
&REPLYALL_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to send a reply to all recipients of a 
#   specified mail message.  A +replyall with no parameter specified 
#   will reply to the last message read.  A +replyall with a 
#   <letter # or keyword> specified will reply to the specified
#   message.  The subject will be the same as the original letter, 
#   with a 'Re: ' prefixed to it.
#
# Command Format:
#
#   +replyall [keyword or letter number]
# 
#   The following keywords are available to specify which letter to reply to:
#
#     current (default), first, last, next, previous
#
#   Only the first character of the keyword needs to be specified.
#
# Registers Used:
#
#   0 - dbref of mailbox
#   1 - list of letters in folder
#   2 - internal message number reflecting the specified criteria
#   3 - subject of letter to reply to
#   4 - dbref of source mailbox
#   5 - internal number of source mail in source mailbox
#

  $+replyall*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    strmatch(escape(%0), *[*), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(%q0), 0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +replyall%0; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]
 
#
# Interpret user input and convert into an internal mail number
#
          [setq(2, ulocal(expand_single_letter_range, trim(%0), %q1, 
            u(get_folder_current_letter, %q0)))]
 
          [setq(4, u(get_src_dbref, %q0, %q2))]

          [setq(5, u(get_src_num, %q0, %q2))]

        1 = strmatch(get(%q0/mail-in-progress), true),
        {
#
# Mail message is already in progress.  Notify user and release the semaphore.
#

          @pemit %# = You are already in the middle of sending a message. 
            You must complete that one before you reply to this one.; 

          @no %q0
        },

        eq(words(%q1), 0),
        {
#
# There is no mail in the user's mailbox.  Notify user and release the 
# semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, %q0));
          @no %q0
        },

        strmatch(%q2, *ABORT*), 
        {
#
# Error detected in input parameter.  Notify the user and release the semaphore.
#

          @pemit %# = after(before(%q2, ENDABORT), ABORT); 
          @no %q0
        },

        eq(words(%q2), 0), 
        {

# Could not find any letter to match the specified input parameter.
# Notify the user and release the semaphore.
#

          @pemit %# = u(no_match, +replyall, ulocal(format_request, trim(%0)), 
             u(get_active_folder, %q0)); 
          @no %q0
        },

        not(hasattr(%q4, out-%q5-replyall_to)), 
        {
#
# no 'replyall_to' attribute exists for the letter specified, 
# unable to perform a +replyall.
#
          @pemit %# = +replyall:%b%bUnable to perform this function 
            on the specified letter[ulocal(format_request, trim(%0))] 
            in folder '[u(get_active_folder, %q0)]'.;

          @no %q0
        },

        {
#
# - Set current letter to the letter being replied to
# - Set mail-in-progress to true
# - Preset 'to' list and 'subject' based on letter being replied to
# - Let user know what to do next
# - Release the semaphore
#

          &[u(which_current_letter, %q0)] %q0 = %q2;
          &mail-in-progress %q0 = true; 

          &mail-in-progress-to %q0 = 
            u(pretty_dist, get(%q4/out-%q5-replyall_to)); 

          &mail-in-progress-to-expanded %q0 = 
            get(%q4/out-%q5-replyall_to); 

          &mail-in-progress-subject %q0 = 

            [setq(3, get(%q4/out-%q5-subject))]
	    [setq(7, get(%q0/in-%q2-subject))]

            switch(words(%q7), 0, switch(mid(%q3, 0, 3), Re:, 
	    %q3, Re:%b%b%q3), %q7);

          @pemit %# = u(enter_msg); 

          @no %q0
        }
      }
    }

-
###############################################################################
#
#                           I N C L U D E   
#
###############################################################################
&INCLUDE_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to include the text of the specified message
#   in the current letter in progress.
#
# Command Format:
#
#   +include <keyword or letter number>
#
#   The following keywords are available to specify the scope of +include:
#
#     current (default), first, last, next, previous 
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - internal message number reflecting the specified criteria
#

  $+include*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(9, switch(words(%0), 0, current, trim(%0)))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *[*)), 
    {
#
# Function calls are not allowed within input parameters
#

      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
#
# User does not have a mailbox
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +include%0; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]

#
# Interpret user input and convert into an internal mail number
#
          [setq(2, 
            ulocal(expand_single_letter_range, 
            %q9, %q1, u(get_folder_current_letter, %q0))
          )]

        1 = eq(words(%q1), 0), 
        {
#
# Mailbox is empty.  Notify user, clear global variable and release
# the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, %q0));
          @no %q0
        },

        strmatch(%q2, *ABORT*), 
        {
#
# Error detected in user input.  Notify user, clear global variables
# and release the semaphore.
#

          @pemit %# = after(before(%q2, ENDABORT), ABORT); 
          @no %q0
        },

        strmatch(get(%q0/mail-in-progress), false), 
        {
#
# Not writing mail.  Notify the user, and release the semaphore.
#

          @pemit %# = u(not_writing_mail); 
          @no %q0
        }, 

        eq(words(%q2), 0), 
        {
#
# No letter matches the user specified criteria.  Notify the user,
# clear the global variables and release the semaphore.
#

          @pemit %# = u(no_match, +include, ulocal(format_request, %q9), 
             u(get_active_folder, %q0)); 
          @no %q0
        },

        {
#
# Include the text of the specified letter with the current
# mail in progress text.  Notify the user of the action taken 
# and release the semaphore.
#

          &mail-in-progress-body %q0 = 

              [setq(3, u(get_src_dbref, %q0, %q2))]
              [setq(4, u(get_src_num, %q0, %q2))]
              [setq(5, default(%q3/out-%q4-sender, get(%q3/owner_dbref)))]
              [setq(5, switch(type(%q5), PLAYER, name(%q5), 
                destroyed player))]
              [setq(6, get(%q3/out-%q4-time_sent))]
              [setq(7, 
                edit(
                  edit(get(%q3/out-%q4-text), v(newline),v(percent_r)), 
                  v(percent_r), 
                  [v(percent_r)]>%b
                )
              )]
              [setq(3, get(%q0/mail-in-progress-body))]

            %q3
            [switch(words(%q3), 0,, %r)]
            On %q6, %q5 wrote:

#
# The following games done to prevent recursion limit exceeded
#
            [switch(1, 

            gt(strlen(%q7), 3000),
            {
                [setq(8, wordpos(%q7, 1000))]
                [setq(3, wordpos(%q7, 2000))]
                [setq(4, wordpos(%q7, 3000))]

              [u(format_include_text, 0, 76, extract(%q7, 1, sub(%q8, 1)))] 

              [u(format_include_text, 0, 76, 
                 extract(%q7, %q8, sub(%q3, %q8)))];

              [u(format_include_text, 0, 76, 
                 extract(%q7, %q3, sub(%q4, %q3)))];

              [u(format_include_text, 0, 76, 
                 extract(%q7, %q4, add(sub(words(%q7), %q4), 1)))];
            },

            gt(strlen(%q7), 2000),
            {
                [setq(8, wordpos(%q7, 1000))]
                [setq(3, wordpos(%q7, 2000))]

              [u(format_include_text, 0, 76, extract(%q7, 1, sub(%q8, 1)))] 

              [u(format_include_text, 0, 76, 
                 extract(%q7, %q8, sub(%q3, %q8)))];

              [u(format_include_text, 0, 76, 
                 extract(%q7, %q3, add(sub(words(%q7), %q3), 1)))];
            },

            gt(strlen(%q7), 1000),
            {
                [setq(8, wordpos(%q7, 1000))]

              [u(format_include_text, 0, 76, extract(%q7, 1, %q8))] 
              [u(format_include_text, 0, 76, 
                 extract(%q7, add(1, %q8), sub(words(%q7), %q8)))];
            },

            { 
              [u(format_include_text, 0, 76, %q7)]
            }
            )]%r; 

          @pemit %# = Message [u(convert_nums, %q2, %q1)]
            [ulocal(format_request, %q9)] 
            in folder '[u(get_active_folder, %q0)]' has been included.; 

          @no %q0
        }
      }
    }

-
&FORMAT_INCLUDE_TEXT #4167=
#
# %0 - left indent
# %1 - right indent
# %2 - text to format
#
# Register 6 is available
#

  switch(
    gt(strlen(%2), sub(%1, %0)), 

#
# String is longer than would fit on one line.
#
    1, 
      %r[space(%0)]>%b
      [setq(6, sub(wordpos(%2, sub(%1, %0)), 1))]
      [switch(%q6, 0,
      {
#
# Word where break should happen fills the entire line.  Break at mid-word
#
         [setq(6, sub(%1, %0))]
         [mid(%2, 0, %q6)]
         [u(format_include_text, %0, %1, mid(%2, %q6, sub(strlen(%2), %q6)))]
      },
      {
#
# Can break in between words.
#
        [setq(6, wordpos(%2, sub(%1, %0)))]
        [extract(%2, 1, sub(%q6, 1))]
        [u(format_include_text, 
          %0, 
          %1, 
          extract(%2, %q6, add(sub(words(%2), %q6), 1))
        )]
      }
      )], 

#
# String fits on one line
#
    %r[space(%0)]>%b%2)

-
###############################################################################
#
#                             F O R W A R D         
#
###############################################################################
&FORWARD_MAIL #300=
#
# PURPOSE:
#
#   This command may be used to reply to forward a piece of received mail  
#   to a list of destinations.  +forward to <list of destinations> will
#   forward the current letter.  +forward <letter # or keyword> to 
#   <list of destinations> will forward the letter specified.  The
#   subject line will be the same as the original letter, with a 'Fwd: '
#   prefixed to it.  Text within the letter cannot be changed. 
#
# Command Format:
#
#   +forward [keyword or letter number] to <list of destinations>
#
#   The following keywords are available to specify which letter to +forward:
#
#     current (default), first, last, next, previous
#
#   Only the first character of the keyword needs to be specified.
#
# NOTE:
#
#   If a note is registered with the letter (by having previously done
#   a +add note to <letter>=<text>, this note will be carrying along with
#   the forwarded message.  
#
# Registers Used:
#
#   0 - dbref of mailbox
#   1 - list of letters in folder 
#   2 - holds the internal message number of the mail to forward
#   3 - dbrefs of player names use specified to forward to and then later
#       it holds the dbref of a single player to forward the mail to
#   4 - aliases specified of who to forward to, also used to hold
#       the subject, and another time to hold the note
#   5 - player dbrefs + alias names expanded into player dbrefs
#   6 - aliases specified identified as personal or global
#   7 - dbref of mailbox to write into
#   8 - used lots, in one case to hold the subject
#       in another to hold the note, in another to be the internal
#       mail number to write into.
#
# Yuck.
#

  $+forward* to *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    or(
      strmatch(escape(%0), *[*),
      strmatch(escape(%1), *[*)
    ),
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(%q0), 0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +forward%0 to %1; 

        @swi/first 

            [setq(1, u(get_folder_in_list, %q0))]

#
# Interpret user input and convert into an internal mail number
#
            [setq(2, 
              ulocal(expand_single_letter_range, 
                trim(%0), 
                %q1, 
                u(get_folder_current_letter, %q0)
              )
            )]

#
# Convert list of names specified by the user into dbrefs
#
            [setq(3, ulocal(identify_to_list, {%1}, %q0))]

# 4, 7, 8 are just temp/working registers and are stomped on later

            [setq(7, get(%vm/global-mail-aliases))]
            [setq(8, get(%q0/alias-list))]
            [setq(4, u(get_aliases, {%1}, %q0, %q7, %q8))]

# 5 - 'real' list of destinations (dbrefs)

            [setq(5, 
              setunion(%q3 [ulocal(expand_aliases, %q4, %q0, %b, %q7, %q8)], )
            )]

# 6 - 'pretty' list of destinations, for use in display to the user

            [setq(6, 
              [u(pretty_dist, %q4, %q0, %q8, %q7, %q3)]
            )]

        0 = words(%1), 
        {
#
# No destination specified for who to forward the letter to.  Notify user
# and release the semaphore.
#

          @pemit %# = You must specify a destination to forward this piece 
            of mail to.; 
          @no %q0
        },

        words(%q1),
        {
#
# There is no mail in the user's mailbox.  Notify user 
# and release the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, %q0));
          @no %q0
        },

        not(strmatch(%q2, *ABORT*)), 
        {
#
# Error detected in input parameter.  Notify user and release the semaphore.
#

          @pemit %# = after(before(%q2, ENDABORT), ABORT); 
          @no %q0
        },

        words(%q2), 
        {
#
# Could not find a letter to match the specified input parameter.
# Notify user and release the semaphore.
#

          @pemit %# = u(no_match, +forward, ulocal(format_request, trim(%0)), 
            u(get_active_folder, %q0)); 
          @no %q0
        },

        not(strmatch(%q3, *ABORT*)), 
        {
#
# Error detected in input parameter.  Notify user 
# and release the semaphore.
#
          @pemit %# = secure(after(before(%q3, ENDABORT), ABORT)); 
          @no %q0
        },

        {
          @tr me/store_letter =

              [setq(3, u(get_src_dbref, %q0, %q2))]
              [setq(4, u(get_src_num, %q0, %q2))]
              [setq(7, default(%q3/out-%q4-sender, get(%q3/owner_dbref)))]
              [setq(8, get(%q3/out-%q4-subject))]
              [setq(9, get(%q0/in-%q2-note))]

            %q0, 
            switch(mid(%q8, 0, 4), Fwd:, %q8, Fwd:%b%b%q8), 
            %q6, 
            %q5, 
              , 
              , 
              , 
              , 
            F, 
            {Received from:%b%b
             [name(%q7)]
             %r[u(%q3/out-%q4-text)]

             [switch(
               words(%q9),
               0,,
                 %r%r[u(dash_line)]
                 %r%N's comment section:
                 %r%r%q9
             )]}; 

          &[u(which_current_letter, %q0)] %q0 = %q2;

          @pemit %# = 
            u(forward_notification, 
              u(get_active_folder, %q0), 
              [u(convert_nums, %q2, %q1)]
              [ulocal(format_request, trim(%0))]); 

          @no %q0
        }
      }
    }

-
&FORWARD_COMMAND #300=

  $+forward: 

    @pemit %# = u(#13/forward_help)

-
###############################################################################
#
#                             F O R W A R D         
#
# Second version
#
###############################################################################
&FORWARD_MAIL2 #300=
#
# PURPOSE:
#
#   This command may be used to forward a received mail message to one
#   or more destinations.  You will be allowed to add text via '-<text>'
#   before sending it.  The subject will be the same as the original 
#   letter, with a 'Fwd: ' prefixed to it.
#
# This command is being provided for compatibility with Amberyl's
# mailer.
#
# Command Format:
#
#   +forward <list of people>=[keyword or letter number]
# 
#   The following keywords are available to specify which letter to forward:
#
#     current (default), first, last, next, previous
#
#   Only the first character of the keyword needs to be specified.
#
# Registers Used:
#
#   0 - dbref of mailbox
#   1 - list of letters in folder
#   2 - internal message number reflecting the specified criteria
#   3 - list of dbrefs associated with names entered for who to forward to
#   4 - list of aliases to forward to
#   5 - 'real' list of destinations (dbrefs)
#   6 - 'pretty' list of destinations
#   7 - global mail aliases
#   8 - personal mail aliases
#   9 - subject of letter to forward
#

  $+forward *=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = 

    not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    or(
      strmatch(escape(%0), *[*), 
      strmatch(escape(%1), *[*)
    ), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(%q0), 0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +forward %0=%1; 

        @swi/first 

# Get list of letters for the active folder

          [setq(1, u(get_folder_in_list, %q0))]

# Interpret user input and convert into an internal mail number

          [setq(2, ulocal(expand_single_letter_range, trim(%1), %q1, 
            u(get_folder_current_letter, %q0)))]

# Convert list of names specified by the user into dbrefs

          [setq(3, ulocal(identify_to_list, {%0}, %q0))]

# Global mail aliases

          [setq(7, get(%vm/global-mail-aliases))]

# Personal mail aliases

          [setq(8, get(%q0/alias-list))]

# List of aliases specified by the user for who to forward to

          [setq(4, u(get_aliases, {%0}, %q0, %q7, %q8))]

# 'real' list of destinations (dbrefs) 

          [setq(5,
            setunion(%q3 [ulocal(expand_aliases, %q4, %q0, %b, %q7, %q8)], )
          )]

# 'pretty' list of destinations, for use in display to the user

          [setq(6,
            [u(pretty_dist, %q4, %q0, %q8, %q7, %q3)]
          )]

        1 = 

        eq(words(%0), 0), 
        {
#
# No destination specified for who to forward the letter to.  Notify user
# and release the semaphore.
#

          @pemit %# = You must specify a destination to forward this piece
            of mail to.;
          @no %q0
        },

        strmatch(get(%q0/mail-in-progress), true),
        {
#
# Mail message is already in progress.  Notify user 
# and release the semaphore.
#

          @pemit %# = You are already in the middle of sending a message. 
            You must complete that one before you can forward another.; 

          @no %q0
        },

        eq(words(%q1), 0), 

        {
#
# There is no mail in the user's mailbox.  Notify user and release 
# the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, %q0));
          @no %q0
        },

        strmatch(%q2, *ABORT*), 
        {
#
# Error detected in input parameter.  Notify the user and release the 
# semaphore.
#

          @pemit %# = after(before(%q2, ENDABORT), ABORT); 
          @no %q0
        },

        eq(words(%q2), 0), 
        {
#
# Could not find any letter to match the specified input parameter.
# Notify the user and release the semaphore.
#

          @pemit %# = u(no_match, +forward, ulocal(format_request, trim(%1)), 
             u(get_active_folder, %q0)); 
          @no %q0
        },

        strmatch(%q3, *ABORT*),
        {
#
# Error detected in input parameter.  Notify user
# and release the semaphore.
#
          @pemit %# = secure(after(before(%q3, ENDABORT), ABORT));
          @no %q0
        },

        {
#
# - Set current letter to the letter being forwarded
# - Set mail-in-progress to true
# - Preset body and subject based on letter being forwarded
# - Let user know what to do next
# - Release the semaphore
#

          &[u(which_current_letter, %q0)] %q0 = %q2;
          &mail-in-progress %q0 = true; 
          &mail-in-progress-to %q0 = %q6; 
          &mail-in-progress-to-expanded %q0 = %q5; 
          &mail-in-progress-flags %q0 = 
            setunion(get(%q0/mail-in-progress-flags) F, );

          &mail-in-progress-body %q0 = 
              [setq(9, u(get_src_dbref, %q0, %q2))]
            Received from:%b%b[name(get(%q9/owner_dbref))]
            %r[u(%q9/out-[u(get_src_num, %q0, %q2)]-text)]
            %r%r---- Below this line are comments added by %N ----%r; 

          &mail-in-progress-subject %q0 = 

            [setq(9, get(%q9/out-[u(get_src_num, %q0, %q2)]-subject))]

            switch(mid(%q9, 0, 4), Fwd:, %q9, Fwd:%b%b%q9); 

          @pemit %# = You may now enter text to send along with the 
            message to forward.; 

          @no %q0
        }
      }
    }

-
###############################################################################
#
#                               M A R K    
#
###############################################################################
&MARK_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to tag one or more of the messages in
#   a mailbox for future operations.  +mark with no parameter will 
#   mark the last mail message read.  Either a keyword (listed below) 
#   or a list of mail numbers may be specified.  Example:  +mark 3..5, 
#   +mark unread
#
# Command Format:
#
#   +mark [keyword or a list of letter numbers]
#
#   The following keywords are available to specify the scope of +mark:
#
#     all, current (default), deleted, first, last, next, previous, 
#     saved, unread, author:<name>, subject:<text>, text:<text fragment>
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - new current letter
#   3 - name of active folder
#   4 - list of internal message numbers reflecting the specified criteria
#

  $+mark*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    strmatch(escape(%0), *[*), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(%q0), 0),
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +mark%0; 

        @swi/first  

          [setq(1, u(get_folder_in_list, %q0))]
          [setq(2, u(get_folder_current_letter, %q0))]
          [setq(3, u(get_active_folder, %q0))]

#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(4, ulocal(expand_letter_range, %0, %q1, %q2))]

        0 = words(%q1), 
        {
#
# There is no mail in the user's mailbox.  Notify the user and 
# release the semaphore.
#

          @pemit %# = u(nomail, %q3);
          @no %q0
        },

        not(strmatch(%q4, *ABORT*)), 
        {
#
# Error detected in input parameter.  Notify the user 
# and release the semaphore.
#

          @pemit %# = after(before(%q4, ENDABORT), ABORT); 
          @no %q0
        },

        words(%q4), 
        {
#
# Could not find any letters to match the specified input parameter.
# Notify the user and release the semaphore.
#

          @pemit %# = 
            u(no_match, +mark, ulocal(format_request, trim(%0)), %q3); 
          @no %q0
        },
        {

          @dolist 

#
# Reorder the list of letters to mark into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
            [setq(4, u(filter_list, setunion(%q4, ), %q1))]

          %q4 = 
          {
            &in-##-flags %q0 = setunion(get(%q0/in-##-flags) M, )
          }; 

          @swi 1 = 1,
          {
#
# Finished marking the letter(s) specified.  Set the 'current letter' 
# to be the last one marked.  Notify the user and release the semaphore.
#

            &[u(which_current_letter, %q0)] %q0 = last(%q4); 

            @pemit %# = Message(s) [u(convert_nums, %q4, %q1)]
              [ulocal(format_request, trim(%0))] marked in folder '%q3'.; 

            @no %q0
          }
        }
      }
    }

-
###############################################################################
#
#                               U N M A R K          
#
###############################################################################
&UNMARK_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to remove a tag previously set by a call to 
#   +mark. +unmark with no parameter will unmark the last mail message read.  
#   Either a keyword (listed below) or a list of mail numbers may be 
#   specified.  Example:  +unmark 3..5, +unmark marked
#
# Command Format:
#
#   +unmark [<keyword or a list of letter numbers>]
#
#   The following keywords are available to specify the scope of +unmark:
#
#     all, current (default), deleted, first, last, marked, next, previous,
#     saved, unread, author:<name>, subject:<text>, text:<text fragment>
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - new current letter
#   3 - name of active folder
#   4 - list of internal message numbers reflecting the specified criteria
#

  $+unmark*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    strmatch(escape(%0), *[*), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(%q0), 0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +unmark%0; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]
          [setq(2, u(get_folder_current_letter, %q0))]
          [setq(3, u(get_active_folder, %q0))]

#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(4, ulocal(expand_letter_range, %0, %q1, %q2))]

        0 = words(%q1), 
        {
#
# Mailbox is empty.  Notify user and release semaphore.
#

          @pemit %# = u(nomail, %q3);
          @no %q0
        },

        not(strmatch(%q4, *ABORT*)), 
        {
#
# Error detected in input parameter.  Notify user and release semaphore.
#

          @pemit %# = after(before(%q4, ENDABORT), ABORT); 
          @no %q0
        },

        words(%q4), 
        {
#
# Could not find any letters to match the specified input parameter.
# Notify user and release semaphore.
#

          @pemit %# = 
            u(no_match, +unmark, ulocal(format_request, trim(%0)), %q3); 
          @no %q0
        },
        {
#
# Reorder the list of letters to 'unmark' into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#

          @dolist 

            [setq(4, u(filter_list, setunion(%q4, ), %q1))]

          %q4 = 
          {
            &in-##-flags %q0 = squish(remove(get(%q0/in-##-flags), M))
          }; 

          @swi 1 = 1,
          {
#
# Finished removing the 'M' flag from the letter(s) specified. 
# Notify user and release the semaphore.
#

#
# Set the 'current letter' to be the last one unmarked
#

            &[u(which_current_letter, %q0)] %q0 = last(%q4); 

            @pemit %# = Mark(s) removed from message(s) 
              [u(convert_nums, %q4, %q1)]
              [ulocal(format_request, trim(%0))] in folder '%q3'.; 

            @no %q0
          }
        }
      }
    }

-
###############################################################################
#
#                               S A V E    
#
###############################################################################
&SAVE_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to exclude a message from normal mail 
#   timeouts. +save with no parameter will tag the last mail message read.  
#   Either a keyword (listed below) or a list of mail numbers may be 
#   specified.  Example:  +save 3..5, +save current
#
# Command Format:
#
#   +save [keyword or a list of letter numbers]
#
#   The following keywords are available to specify the scope of +save:
#
#     all, current (default), deleted, first, last, marked, next, previous,
#     unread, author:<name>, subject:<text>, text:<text fragment>
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - new current letter
#   3 - name of active folder
#   4 - list of internal message numbers reflecting the specified criteria
#

  $+save*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    strmatch(get(%vm/default_save_option), disabled), 
    {
      @pemit %# = I'm sorry, but the +save command has been disabled 
        by the game administrators.
    },

    strmatch(escape(%0), *[*), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(%q0), 0),
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +save%0; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]
          [setq(2, u(get_folder_current_letter, %q0))]
          [setq(3, u(get_active_folder, %q0))]

#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(4, ulocal(expand_letter_range, %0, %q1, %q2))]

        0 = words(%q1), 
        {
#
# There is no mail in the user's mailbox.  Notify the user and 
# release the semaphore.
#

          @pemit %# = u(nomail, %q3);
          @no %q0
        },

        not(strmatch(%q4, *ABORT*)), 
        {
#
# Error detected in input parameter.  Notify the user 
# and release the semaphore.
#

          @pemit %# = after(before(%q4, ENDABORT), ABORT); 
          @no %q0
        },

        words(%q4), 
        {
#
# Could not find any letters to match the specified input parameter.
# Notify the user and release the semaphore.
#

          @pemit %# = 
            u(no_match, +save, ulocal(format_request, trim(%0)), %q3); 
          @no %q0
        },
        {
#
# Reorder the list of letters to 'save' into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#

          @dolist 
 
            [setq(4, u(filter_list, setunion(%q4, ), %q1))]

          %q4 = 
          {
#
# Only add the 'S' (saved) flag if it is not already there.
#

            &in-##-flags %q0 = setunion(get(%q0/in-##-flags) S, )
          }; 

          @swi 1 = 1, 
          {
#
# Finished saving the letter(s) specified. 
# Set the 'current letter' to be the last one 'saved'.
# Notify user and release the semaphore.
#

            &[u(which_current_letter, %q0)] %q0 = last(%q4); 

            @pemit %# = Message(s) [u(convert_nums, %q4, %q1)]
              [ulocal(format_request, trim(%0))] marked as 'saved' in 
              folder '%q3'.; 
            @no %q0
          }
        }
      }
    }

-
###############################################################################
#
#                               U N S A V E          
#
###############################################################################
&UNSAVE_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to remove a tag previously set by a call to
#   +save.  +unsave with no parameter will unsave the last mail message read.
#   Either a keyword (listed below) or a list of mail numbers may be
#   specified.  Example:  +unsave 3..5, +unsave saved
#
# Command Format:
#
#   +unsave [keyword or a list of letter numbers]
#
#   The following keywords are available to specify the scope of +unsave:
#
#     all, current (default), deleted, first, last, marked, next, previous,
#     saved, unread, author:<name>, subject:<text>, text:<text fragment>
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - current letter
#   3 - list of internal message numbers reflecting the specified criteria
#   4 - name of active folder
#

  $+unsave*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    strmatch(escape(%0), *[*), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(%q0), 0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +unsave%0; 

        @swi/first 

          [setq(1, u(get_folder_in_list, %q0))]
          [setq(2, u(get_folder_current_letter, %q0))]

#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(3, ulocal(expand_letter_range, %0, %q1, %q2))]
          [setq(4, u(get_active_folder, %q0))]

        0 = words(%q1), 
        {
#
# Mailbox is empty.  Notify user and release semaphore.
#

          @pemit %# = u(nomail, %q4);
          @no %q0
        },

        not(strmatch(%q3, *ABORT*)), 
        {
#
# Error detected in input parameter.  Notify user and release semaphore.
#

          @pemit %# = after(before(%q3, ENDABORT), ABORT); 
          @no %q0
        },

        words(%q3), 
        {
#
# Could not find any letters to match the specified input parameter.
# Notify user and release the semaphore.
#

          @pemit %# = u(no_match, +unsave, ulocal(format_request, trim(%0)), %q4); 
          @no %q0
        },
        {
#
# Reorder the list of letters to 'unsave' into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#


          @dolist 

            [setq(3, u(filter_list, setunion(%q3, ), %q1))]

          %q3 = 
          {
            &in-##-flags %q0 = squish(remove(get(%q0/in-##-flags), S))
          }; 

          @swi 1 = 1,
          {
#
# Finished removing the 'S' flag from the letter(s) specified. 
# Set the 'current letter' to be the last one unsaved.
# Notify user and release the semaphore.
#

            &[u(which_current_letter, %q0)] %q0 = last(%q3); 

            @pemit %# = The 'S' flag has been removed from 
              message(s) [u(convert_nums, %q3, %q1)]
              [ulocal(format_request, trim(%0))] 
              in folder '%q4'.; 

            @no %q0
          }
        }
      }
    }

-
###############################################################################
#
# WRITE related commands:
#
###############################################################################


###############################################################################
#
#                                M A I L         
#
###############################################################################
&MAIL_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to start the letter writing process.
#
# Command Format:
#
#   +mail <name1>[,] [<name2> ...]=<Subject line text>
#
#   You may specify any number of players, personal mail aliases, or 
#   global mail aliases to send the letter to, and a subject line.  
#   Both of these may be changed any time before the letter is actually
#   sent, using the commands +edit to and +edit subject.  Once issued,
#   the mail system will respond with instructions for writing your letter.
#
#   Note:  If the players' names contain spaces, each name should be 
#   separated by a comma.  Example:  +mail Joe Jones, Jane Smith, wizards=FYI
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of names specified by the user converted to dbrefs
#   2 - list of mail aliases specified by the user
#   3 - list of dbrefs for all destinations (player and expanded aliases) 
#   4 - mailbox dbref created for user who had no mailbox
#   6 - global mail aliases
#   7 - personal mail aliases
#

  $+mail *=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = or(strmatch(escape(%0), *[*), strmatch(escape(%1), *[*)),
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    eq(strlen(%q0), 0), 
    {
#
# No mailbox exists for user
#

      @swi/first  

#
# Convert list of names specified by the user into dbrefs
#
        [setq(6, get(%vm/global-mail-aliases))]
        [setq(1, ulocal(identify_to_list, {%0}, %vm))]
        [setq(2, u(get_aliases, 
                   {%0}, 
                   #0, 
                   %q6, 
                 ))]
        [setq(3, 
          setunion(
            %q1 
            [ulocal(expand_aliases, %q2, #0, %b, %q6, )], 
          )
        )]
 
      1 = strmatch(%q1, *ABORT*),
      {
#
# Error detected in input parameter.
#
        @pemit %# = secure(after(before(%q1, ENDABORT), ABORT))
      },

      eq(words(%q3), 0),
      {
        @pemit %# = You must specify a destination for this piece of mail.
      },

      {
#
# Create a new mailbox.
#

        @create %N's Mailbox; 
        @set [setq(4, con(me))]%q4 = quiet; 
        @drain %q4; 
        &debug_mail %q4 = +mail %0=%1; 
        @tel %q4 = %vm; 
        &mailbox_%# %vm = %q4; 
        @tr %vm/add_mailbox = %q4; 
        &owner_dbref %q4 = %#; 
        @startup %q4 = {@drain me; @no me}; 
        @set %q4 = safe; 
        &current_folder %q4 = ulocal(get_inbox, %#); 
        &folder-list %q4 = get(%q4/current_folder); 
 
        &mail-in-progress %q4 = true; 
        &mail-in-progress-to %q4 = u(pretty_dist, %q2, #0, , %q6, %q1); 
        &mail-in-progress-to-expanded %q4 = %q3; 
        &mail-in-progress-subject %q4 = %1; 

        @pemit %# = u(enter_msg); 

        @no %q4
      }
    },

    {

#
# User has a mailbox. Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +mail %0=%1; 

        @swi/first 

#
# Convert list of names specified by the user into dbrefs
#
            [setq(1, ulocal(identify_to_list, {%0}, %q0))]
            [setq(7, get(%q0/alias-list))]
            [setq(6, get(%vm/global-mail-aliases))]
            [setq(2, u(get_aliases, {%0}, %q0, %q6, %q7))]

        1 = strmatch(get(%q0/mail-in-progress), true),
        {
#
# User is already in the middle of writing a mail message.
#

          @pemit %# = You are already in the middle of sending a message. %b
            You must complete that one before you begin another.; 
          @no %q0
        },

        eq(words(%0), 0),
        {
#
# No destination specified for this piece of mail.
#

          @pemit %# = You must specify a destination for this piece of mail.; 
          @no %q0
        },

        strmatch(%q1, *ABORT*),
        {
#
# Error detected in input parameter.
#
          @pemit %# = secure(after(before(%q1, ENDABORT), ABORT)); 
          @no %q0
        },

        {
#
# Otherwise, everything looks fine so far, start storing the data 
# in the user's mailbox.
#

          &mail-in-progress %q0 = true; 

          &mail-in-progress-to %q0 = 
            u(pretty_dist, %q2, %q0, %q7, %q6, %q1); 

          &mail-in-progress-to-expanded %q0 = 
              %q1 [ulocal(expand_aliases, %q2, %q0, %b, %q6, %q7)]; 

          &mail-in-progress-subject %q0 = %1; 

          @swi/first hasattr(%q0, mail-in-progress-to-expanded) = 0,
          {
#
# Destinations specified could not be expanded into dbrefs.
#

            @pemit %# = You must specify a destination for this piece of mail.; 
            &mail-in-progress %q0 = false; 
            &mail-in-progress-to %q0 = ; 
            &mail-in-progress-to-expanded %q0 = ; 
            &mail-in-progress-subject %q0 = ; 
            @no %q0
          },
          {
#
# Notify the user of the next step.
#

            @pemit %# = u(enter_msg); 

            @no %q0
          }
        }
      }
    }

-
&MAIL_NO_PARAM #300 = 

  $+mail: 

    @pemit %# = You must specify the name(s) of the individual(s) that you 
      wish to send mail to, and an optional 'subject' line.%b (format: +mail 
      <name1 name2 .. nameN>=<Subject line>)

-
###############################################################################
#
#                              +N O T E                              
#
###############################################################################
&NOTE_COMMAND #300 = 
#
# PURPOSE:
#
#   This command may be used to send a small note to yourself.
#
# Command Format:
#
#   +note <text>
#
# Registers Used:
#
#   0 - dbref of mailbox
#

  $+note*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = 

    words(%0), 
    {
#
# No text specified.
#

      @pemit %# = No text specified for note.%b Syntax:%b +note <text>
    },

    strlen(%q0), 
    {
#
# Mailbox doesn't exist, store_letter requires the 'sender' to have a 
# mailbox.
#
      @create %N's Mailbox;
      @set [setq(0, con(me))]%q0 = quiet;
      @drain %q0;
      &debug_mail %q0 = +note%0; 
      @no %q0;
      @tel %q0 = %vm;
      &mailbox_%# %vm = %q0;
      @tr %vm/add_mailbox = %q0; 
      &owner_dbref %q0 = %#;
      @startup %q0 = {@drain me; @no me};
      @set %q0 = safe;
      &mail-in-progress %q0 = false;
      &current_folder %q0 = ulocal(get_inbox, %#);
      &folder-list %q0 = get(%q0/current_folder); 

      @tr me/store_letter = 
        %q0, 
        Personal Note, 
        %N, 
        %#, 
        , 
        , 
        , 
        , 
        , 
        u(clean_text, %0); 

      @pemit %# = A personal note has been stored in your mailbox.
    },

    {
      @tr me/store_letter = 
        %q0, 
        Personal Note, 
        %N, 
        %#, 
        , 
        , 
        , 
        , 
        , 
        u(clean_text, %0); 

      @pemit %# = A personal note has been stored in your mailbox.
    }

-
###############################################################################
#
#                                   -           
#
###############################################################################
&DASH_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to add text to a body of a letter in progress.
#
# Command Format:
#
#   -<text to add to letter>
#
#   Once a letter has begun, using the +mail, +reply or +forward command, 
#   the '-' command is used to add text to the body of the letter.  
#   Consecutive commands append text to the letter in process. 
#   Whatever is configured for mail option 'separator' is used to
#   separate the text (either a blank or a carriage return).
#
#   Issuing a '-' without any text following it will show the 
#   available options.
#
#   You may perform any other mush actions while you are entering a
#   message, so long as they do not start with the '-' character.
#
#   Standard MUSH substitutions may be used, %r to insert a carriage
#   return, %t to insert a tab character, etc.
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - size of mail in progress
#   4 - body
#
#   register 2 is used in helper function size_of_mail_in_progress
#

  $-*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = strmatch(%0, -),,
#
# Command is '--', ignore and let the $-- handler handle it.
#

    not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    eq(strlen(%q0), 0),
    {
#
# User does not have a mailbox and therefore cannot be writing mail.
#

      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = -%0; 

        @swi/first 

          [setq(4, get(%q0/mail-in-progress-body))]

        1 = strmatch(get(%q0/mail-in-progress), false),
        {
#
# User is not writing mail.
#

          @pemit %# = u(not_writing_mail); 
          @no %q0
        },

        eq(words(escape(%0)), 0),
        {
#
# '-' Single dash specified, show user help information
#

          @pemit %# = Options:%r
            %r%b%b[ljust(-, 40)] ( show this help display )
            %r%b%b[ljust(-<text>, 40)] ( add text to the message )
            %r%b%b[ljust(+proof, 40)] ( proofread the message )
            %r%b%b[ljust(+send, 40)] ( send the message )
            %r%b%b[ljust(--, 40)] ( same as +send )
            %r%b%b[ljust(+toss, 40)] ( discard the message )
            %r%b%b[ljust(+include \[<letter number or keyword>\], 40)] 
                ( include letter into text )
            %r%b%b[ljust(+cc <list of people or aliases>, 40)] 
                ( set carbon copy list )
            %r%b%b[ljust(+bcc <list of people or aliases>, 40)] 
                ( set blind carbon copy list )
            %r%r%b%b[ljust(+edit <mail part>=<old>/<new>, 40)] 
                ( edit your message )
                %r%b%b%b%b(where mail part = to, cc, bcc, subject or text)
            %r%r%b%b[ljust(+set mail flag \[!\]<flag>, 40)] 
                ( set or clear mail flag )
                %r%b%b%b%b(where flag = urgent, private, registered, 
                or reply requested); 

          @no %q0
        },

        {
#
# Add text to mail message in progress.
#

          &mail-in-progress-body %q0 = 
            u(clean_text, 
              switch(words(%q4), 0, %0, %q4[u(get_separator_option, %#)]%0)
            ); 

          @pemit %# = 

              [setq(1, u(size_of_mail_in_progress, %q0))]

            [u(text_added_notification)]
            [switch(
              gt(%q1, 4000), 
              1, 
                %b%bWarning, message is [sub(4000, %q1)] characters 
                  too long and will be truncated.
              ,
            )]; 

          @no %q0
        }
      }
    }

-
&CLEAN_TEXT #4167=
#
# Do NOT put a s() around this attribute, if you do, you lose the
# capability to send code snippets around via +mail.
#

  edit(
   escape(edit(edit(%0, \\,), v(newline), v(percent_r))), 
   [v(backslash)][v(percent_r)],
   [v(percent_r)]
  )

-
&BACKSLASH #4167=\
-
&SIZE_OF_MAIL_IN_PROGRESS #4167 =

#
# This is a helper function for dash_command.
#
# Purpose:  Calculate as close as reasonably possible the size of
# the current mail message in progress (from the perspective of
# the eventual reader).  This is done so the mail writer has
# an idea if the message is getting too long for the reader to
# see it all.  The reader is limited by a 4000 byte pemit.
#
# %0 - dbref of mailbox
#
# 196 comes from:  the message line, the from line, the to line,
# the subject line, the options line, plus some various carriage
# returns.
#
# Need to assume the receiver is reading in standard format since
# we don't know (for sure) at this stage.
#

  add(
    196, 
    mul(strlen(u(equal_line)), 2), 
    strlen(u(dash_line)), 
    strlen(get(%0/mail-in-progress-subject)), 
    strlen(u(%0/mail-in-progress-to)), 

    switch(
      strlen(get(%0/mail-in-progress-cc)), 
      0, 0, 
      {[add(11, strlen(u(%0/mail-in-progress-cc)))]}
    ), 

    switch(
      strlen(get(%0/mail-in-progress-bcc)), 
      0, 0, 
      {[add(11, strlen(u(%0/mail-in-progress-bcc)))]}
    ), 

    strlen(u(%0/mail-in-progress-body)), 

    [setq(2, get(%0/mail-in-progress-flags))]

    switch(
      words(%q2), 
      0, 0, 

      {[add(
        11, 

        switch(match(%q2, RR), 0, 0, strlen(v(mail_flag_rr))), 

        switch(match(%q2, P), 0, 0, strlen(v(mail_flag_p))), 

        switch(match(%q2, U), 0, 0, strlen(v(mail_flag_u))), 

        switch(match(%q2, R), 0, 0, strlen(v(mail_flag_r))
        ), 

        mul(sub(words(%q2), 1), 2)
      )]}
    )
  )

-
###############################################################################
#
#                                   --          
#
###############################################################################
&DOUBLE_DASH_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to send a letter.
#
# Command Format:
#
#   --
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of dbrefs to deliver to (to, cc, bcc)
#

  $--: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(%q0),
    {
      @pemit %# = u(not_writing_mail)
    },
    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = --; 

        @swi/first 

#
# Grab the complete destination list.  Includes TO, CC and BCC.
# Weed out duplicates.
#
          [setq(1, u(get_final_delivery_list, %q0))]

        1 = strmatch(get(%q0/mail-in-progress), false), 
        {
#
# There is no mail in progress to send.
#

          @pemit %# = You do not have a mail message ready to send.; 
          @no %q0
        },

        eq(words(%q1), 0), 
        {  
          @pemit %# = You do not have a destination specified.; 
          @no %q0
        },

        {
          @tr me/store_letter = 
            %q0, 
            get(%q0/mail-in-progress-subject), 
            get(%q0/mail-in-progress-to), 
            get(%q0/mail-in-progress-to-expanded), 
            get(%q0/mail-in-progress-cc), 
            get(%q0/mail-in-progress-cc-expanded), 
            get(%q0/mail-in-progress-bcc), 
            get(%q0/mail-in-progress-bcc-expanded), 
            get(%q0/mail-in-progress-flags), 
            get(%q0/mail-in-progress-body); 

          @tr me/cleanup_send = %#, %q0
        }
      }
    }

-
&STORE_LETTER #4167 = 
#
# PURPOSE:  store an outgoing letter
# 
# INPUT:
#
#   %0 - dbref of mailbox for sender
#   %1 - subject of letter
#   %2 - TO:   (prettified)
#   %3 - TO:   (dbrefs)
#   %4 - CC:   (prettified)
#   %5 - CC:   (dbrefs)
#   %6 - BCC:  (prettified)
#   %7 - BCC:  (dbrefs)
#   %8 - flags
#   %9 - text of letter
#
# OUTPUT:
# 
#   None.
#
# For the sending mailbox:
#
#   Update field:
#
#     out-list
#     out-list-current (possibly)
#
#   Set fields:
# 
#     out-<num>-time_sent      date/time mail was sent
#     out-<num>-subject        subject of letter
#     out-<num>-to             TO:    (prettified)
#     out-<num>-cc             CC:    (prettified)
#     out-<num>-bcc            BCC:   (prettified, used during +review)
#     out-<num>-bcc-expanded   dbrefs (used during +read)
#     out-<num>-text           body of mail message
#     out-<num>-replyall_to    sender, to & cc dbrefs
#     out-<num>-dist           total distribution list
#     out-<num>-held           list of who still has a pointer to this letter
#
# For each receiving mailbox:
#
#   Update field:
# 
#     in-list-<inbox or filter folder>
#
#   Set fields:
#
#     in-<num>-time_read        date/time mail was last read
#     in-<num>-flags            U R RR P D M S A<dbref>AEND
#     in-<num>-note             registered via +add note
#     in-<num>-location         <dbref> <number> where letter is stored
#
# Registers used:
#
#   0 - internal number to store outgoing message in
#   1 - dbref of existing destination mailbox 
#   2 - dbref of newly created destination mailbox
#   3 - dbref of sender
#   4 - mail_sig of sender
#   6 - internal number to store incoming message information in
#   7 - list of messages in in-list-<inbox> for destination mailbox
#   8 - final distribution list
#   9 - inbox
#

#
# Store information about outgoing mail in sender's mailbox.
#

  &[setq(0, u(free_num, get(%0/out-list)))]out-%q0-time_sent %0 = time(); 
  &[setq(3, get(%0/owner_dbref))]out-%q0-subject %0 = %1; 
  &out-list %0 = [get(%0/out-list)] %q0; 
  &out-list-current %0 = 
    switch(words(get(%0/out-list)), 1, %q0, get(%0/out-list-current)); 
  &out-%q0-to %0 = %2; 
  &out-%q0-cc %0 = %4; 
  &out-%q0-bcc %0 = %6; 
  &out-%q0-bcc-expanded %0 = %7; 
  &out-%q0-text %0 = 
      %9
      [switch(
        [setq(4, get(%q3/MAIL_SIG))]
        strlen(%q4), 0,, %r%q4
      )]; 
  &out-%q0-replyall_to %0 = setunion(%q3 %3 %5, ); 
  &out-%q0-held %0 = [setq(8, 
    setunion(iter(setunion(%3 %5 %7, ), ulocal(autoforward_test, ##)), ))]%q8; 
  &out-%q0-dist %0 = iter(%q8, ##:); 

  @dolist %q8 = 
  {

    @swi/first 

      [setq(1, get(%vm/mailbox_##))]
      [setq(9, u(folder_to_store_into, %q1, get(%0/owner_dbref), %1, ##))]

    1 = 
    and(
      strmatch(type(##), PLAYER), 
      eq(strlen(%q1), 0)
    ),
    {
#
# Mailbox doesn't exist for this destination player, create one.
#
      @create [name(##)]'s Mailbox; 
      @set [setq(2, con(me))]%q2 = quiet; 
      @drain %q2; 
      &debug_mail %q2 = store_letter; 
      @tel %q2 = %vm; 
      &mailbox_## %vm = %q2; 
      @tr %vm/add_mailbox = %q2; 
      &owner_dbref %q2 = ##; 
      @startup %q2 = {@drain me; @no me}; 
      @set %q2 = safe; 
      &mail-in-progress %q2 = false; 
      &current_folder %q2 = %q9; 
      &folder-list %q2 = %q9; 

#
# Store information about newly received letter.
#

      &in-list-%q9 %q2 = 0; 
      &current_letter-%q9 %q2 = 0; 
      &in-0-time_read %q2 = 0; 
      &in-0-flags %q2 = %8; 
      &in-0-note %q2 = ; 
      &in-0-location %q2 = %0 %q0; 
      @edit %0/out-%q0-dist = ##:,##:0; 

#
# Notify receiver that mail message has arrived ('cept if it is
# a result of a '+note' command.
#
      @pemit ## = 
        switch(%1, Personal Note,, {u(delivery_notification, 
          %q3, 
          sign(match(%8, u)),
          sign(match(%8, p)),
          sign(match(%8, rr)),
          sign(match(%8, r)), 
          secure(%q9)
        )}); 

      @no %q2
    }, 

    strmatch(type(##), PLAYER), 
    {
#
# Mailbox exists.  Store information about newly received mail.
#

      &folder-list %q1 = setunion(%q9 [get(%q1/folder-list)], ); 

      &in-list-%q9 %q1 = 

          [setq(6, u(free_num, u(get_all_in_lists, %q1)))]
          [setq(7, get(%q1/in-list-%q9))]

        squish(%q7 %q6); 

      &current_letter-%q9 %q1 = 
        switch(words(%q7), 0, %q6, get(%q1/current_letter-%q9)); 

      &in-%q6-time_read %q1 = 0; 
      &in-%q6-flags %q1 = %8; 
      &in-%q6-note %q1 = ; 
      &in-%q6-location %q1 = %0 %q0; 

      @edit %0/out-%q0-dist = ##:,##:%q6; 

#
# Notify receiver that mail message has arrived ('cept if it is
# a result of a '+note' command or rejected).
#

      @pemit ## = 

        switch(1, 
          strmatch(%1, Personal Note),, 
          hasattr(%q1, reject_msg),, 
          {u(delivery_notification, 
          %q3, 
          sign(match(%8, u)),
          sign(match(%8, p)),
          sign(match(%8, rr)),
          sign(match(%8, r)), 
          secure(%q9)
        )}); 

      @swi/first 1 = 

      strmatch(%1, On Vacation),,
#
# Avoid looping 'vacation' messages.
#

      strmatch(%1, Letter Rejected),,
#
# Avoid looping 'reject' messages.
#

      and(strmatch(%q9, null), hasattr(%q1, filter_reject)),
      {
#
# Filter set up to automatically discard this letter.
# There *is* a filter_reject message for this mailbox,
# therefore send a response back to the originator.
#
        @tr me/remove_letter =
          %0, %q0, get(%q1/owner_dbref), %q1, %q6, %q9, discard;

        @tr me/store_letter =
          %q1,
          Letter Rejected,
          name(get(%0/owner_dbref)),
          get(%0/owner_dbref),
          ,
          ,
          ,
          ,
          ,
          {Message with subject line "%1" has been rejected 
          by [name(get(%q1/owner_dbref))]'s mailbox.
          %r%r----- Reject Message -----
          %r%r[get(%q1/filter_reject)]
          }; 

        @pemit ## = Discarded due to personal mail filter.
      },

      strmatch(%q9, null),
      {
#
# Filter set up to automatically discard this letter.
#
        @tr me/remove_letter = 
          %0, 
          %q0, 
          get(%q1/owner_dbref), 
          %q1, 
          %q6, 
          %q9,
          discard; 

        @pemit ## = Discarded due to personal mail filter. 
      },

      hasattr(%q1, reject_msg), 
      {
#
# Reject set, remove the letter from the mailbox.
#
        @tr me/remove_letter = 
          %0, 
          %q0, 
          get(%q1/owner_dbref), 
          %q1, 
          %q6, 
          %q9,
          reject; 

#
# Store a letter in originator's mailbox indicating that the
# mail was rejected, and why.
#
        @tr me/store_letter = 
          %q1, 
          Letter Rejected, 
          name(get(%0/owner_dbref)), 
          get(%0/owner_dbref), 
          ,  
          , 
          ,  
          , 
          , 
          {Message with subject line "%1" has been rejected 
          by [name(get(%q1/owner_dbref))]'s mailbox.
          %r%r----- Reject Message -----
          %r%r[get(%q1/reject_msg)]
          }
      },

      hasattr(%q1, vacation), 
      {
#
# Store a letter in the originator's mailbox with the
# registered vacation text from the destination mailbox.
#
        @tr me/store_letter = 
          %q1, 
          On Vacation, 
          name(get(%0/owner_dbref)), 
          get(%0/owner_dbref), 
          ,  
          , 
          ,  
          , 
          , 
          {Message with subject line "%1" has been stored in 
          [name(get(%q1/owner_dbref))]'s mailbox.
          %r%r----- Vacation Message -----
          %r%r[get(%q1/vacation)]
          }
      }
    }, 
    
    {
      @pemit get(%0/owner_dbref) = Unable to deliver message.
    } 
  }

-
&REMOVE_LETTER #4167 = 

#
# PURPOSE:  Remove a letter from an incoming mailbox
#
# DESCRIPTION:
#
#   Remove all references to the letter in the received (IN) mailbox.
#   Remove this single reference in the originator's (OUT) mailbox.
#   If all references to this letter have been removed, entirely
#   remove letter from OUT mailbox.  Check to see if either the
#   IN or OUT mailbox may be deleted.
#
# %0 - dbref of mailbox (OUT)
# %1 - internal letter number to remove (OUT)
# %2 - dbref of 'holder'
# %3 - dbref of mailbox (IN)
# %4 - internal letter number to remove (IN)
# %5 - folder (IN)
#

#
# Nail attributes, incoming side.
#

  &[setq(4, trim(%4))][setq(1, trim(%1))]
    in-list-%5 %3 = squish(remove(get(%3/in-list-%5), %q4)); 
  @wipe %3/in-%q4-*; 

#
# Remove 'holder' from the -held list for this letter.
#

  &out-%q1-held %0 = squish(remove(get(%0/out-%q1-held), %2)); 

#
# If the 'held' is now none, no other players have a 'pointer' to
# this mail message.  Nail the attributes on the source mail object.
#

  @swi get(%0/out-%q1-held) = ,
  {
    @wipe %0/out-%q1-*; 
    &out-list %0 = squish(remove(get(%0/out-list), %q1)); 
    &out-list-current %0 = 
      switch(
        member(get(%0/out-list), get(%0/out-list-current)), 
        0, 
          last(get(%0/out-list)), 
        get(%0/out-list-current)
      ); 

    @swi 1 = u(ok_to_dest_mailbox, %0),
    {
      @tr %vm/destroy_mailbox = 
        get(%0/owner_dbref), num(me), %0, remove_letter_a
    } 
  }; 
 
  @swi 1 = u(ok_to_dest_mailbox, %3),
  {
    @tr %vm/destroy_mailbox = 
      get(%3/owner_dbref), num(me), %3, remove_letter_b
  }

-
###############################################################################
#
#                               P R O O F       
#
###############################################################################
&PROOF_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to proof read the mail message that you 
#   are currently writing.  It will show all information that is
#   registered for the piece of mail in progress.
#
# Command Format:
#
#   +proof
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - cc  
#   2 - bcc
#   3 - flags
#   4 - user's format option
#

  $+proof: 
   
    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(%q0),
    {
      @pemit %# = You are not currently writing a mail message.
    },
    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +proof; 

        @pemit %# = 

          switch(
            get(%q0/mail-in-progress),
            false, You are not currently writing a mail message.,
            {
              [setq(1, get(%q0/mail-in-progress-cc))]
              [setq(2, get(%q0/mail-in-progress-bcc))]
              [setq(3, get(%q0/mail-in-progress-flags))]
              [setq(4, u(get_format_option, get(%#/mail_config_options)))]

              [switch(%q4, standard, {[u(equal_line)]%r})]

              To:[space(7)][trim(get(%q0/mail-in-progress-to))]

              [switch(words(%q1), 0,, %rCc:[space(7)][trim(%q1)])]

              [switch(words(%q2), 0,, %rBcc:[space(6)][trim(%q2)])]

              %rSubject:%b%b[trim(get(%q0/mail-in-progress-subject))]

              [switch(words(%q3), 0,, %rFlags:%b%b%b%b)]

              [switch(match(%q3, u), 0,, [v(mail_flag_u)]%b%b)]

              [switch(match(%q3, rr), 0,, [v(mail_flag_rr)]%b%b)]

              [switch(match(%q3, r), 0,, [v(mail_flag_r)]%b%b)]
          
              [switch(match(%q3, p), 0,, [v(mail_flag_p)]%b%b)]

              [switch(%q4, standard, {%r[u(dash_line)]%r%r},%rText:[space(5)])]

              [get_eval(%q0/mail-in-progress-body)]

              [switch(%q4, standard, {%r%r[u(equal_line)]})]

              %r[u(finish_msg)]
            }
          ); 

        @swi and(
          v(spell_checker_available), 
          hasflag(v(spell_checker), connect), 
          strmatch(get(%q0/mail-in-progress), true)
        ) = 1,
        {
          @pemit v(spell_checker) = StartSpelling %# 0 0 subject 0; 
          @pemit v(spell_checker) = get(%q0/mail-in-progress-subject); 
          @pemit v(spell_checker) = StopSpelling; 
          @pemit v(spell_checker) = StartSpelling %# 0 0 text 0; 
          @pemit v(spell_checker) = get(%q0/mail-in-progress-body); 
          @pemit v(spell_checker) = StopSpelling
        }; 

        @no %q0
      }
    }

-
###############################################################################
#
#                               T O S S 
#
###############################################################################
&TOSS_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to discard the current mail message in 
#   progress.
#
# Command Format:
#
#   +toss
#
# Registers Used:
#
#   0 - user's mailbox dbref
#

  $+toss: 
   
    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(%q0),
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +toss; 

        @swi/first get(%q0/mail-in-progress) = false,
        {
          @pemit %# = u(not_writing_mail); 
          @no %q0
        },
        {
          @pemit %# = The mail message has been discarded.; 

          &mail-in-progress %q0 = false; 
          &mail-in-progress-subject %q0; 
          &mail-in-progress-to %q0; 
          &mail-in-progress-to-expanded %q0; 
          &mail-in-progress-cc %q0; 
          &mail-in-progress-cc-expanded %q0; 
          &mail-in-progress-bcc %q0; 
          &mail-in-progress-bcc-expanded %q0; 
          &mail-in-progress-flags %q0; 
          &mail-in-progress-body %q0; 

          @swi/first 1 = u(ok_to_dest_mailbox, %q0),
          {
            @tr %vm/destroy_mailbox = %#, num(me), %q0, +toss; 
            @no %q0
          },

          {
            @no %q0
          }
        }
      }
    }

-
###############################################################################
#
#                                C C
#
###############################################################################
&CC_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to register a list of people to carbon
#   copy the current piece of mail being written.  The list may 
#   include player names, personal aliases and global aliases.
#
# Command Format:
#
#   +cc <list of people> 
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of dbrefs matching names specified for who to CC to
#   2 - global mail alias names
#   3 - personal mail alias names
#   4 - list of aliases specified
#

  $+cc*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *[*)), 
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +cc%0; 

        @swi/first 

          [setq(1, ulocal(identify_to_list, {%0}, %q0))]
          [setq(2, get(%vm/global-mail-aliases))]
          [setq(3, get(%q0/alias-list))]
          [setq(4, u(get_aliases, {%0}, %q0, %q2, %q3))]

        1 = 

        strmatch(get(%q0/mail-in-progress), false),
        {
          @pemit %# = u(not_writing_mail); 
          @no %q0
        },

        strmatch(%q1, *ABORT*),
        {
#
# Error detected in input parameter.
#

          @pemit %# = secure(after(before(%q1, ENDABORT), ABORT)); 
          @no %q0
        },
        {
#
# Set user displayable text for who to CC the letter to.
#

          &mail-in-progress-cc %q0 = 
            u(pretty_dist, %q4, %q0, %q3, %q2, %q1); 
#
# Set the list of raw dbrefs for who to CC the letter to.
#

          &mail-in-progress-cc-expanded %q0 = 
            setunion(%q1 [ulocal(expand_aliases, %q4, %q0, %b, %q2, %q3)], ); 

          @pemit %# = 
            switch(
              hasattr(%q0, mail-in-progress-cc-expanded), 
              0, 
                No carbon copy (cc) set., 
              The carbon copy (cc) line now reads:
                %b%b[get(%q0/mail-in-progress-cc)]
            ); 

          @no %q0
        }
      }
    }

-
&CC_NO_PARAM #300=

  $+cc: 

    @pemit %# = You must specify the name of the individual(s) that you 
      wish to be carbon copied on this piece of mail.

-
###############################################################################
#
#                            E D I T   C C
#
###############################################################################
&EDIT_MAIL_CC #300=
#
# PURPOSE:
#
#   This command may be used to edit the current 'CC' that is registered
#   for this piece of mail (originally registered via the +cc command).
#   The standard '^' and '$' may be used for <old text> to prepend and
#   append <new text> respectively.
#
# Command Format:
#
#   +edit cc=<old text>/<new text>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - old text with leading and trailing spaces removed
#   2 - new text with leading and trailing spaces removed
#   3 - user displayable CC before edit
#

  $+edit cc*=*/*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%2), *[*)),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +edit cc%0=%1/%2; 

        @swi/first 

          [setq(1, lcstr(trim(%1)))]
          [setq(2, trim(%2))]
          [setq(3, lcstr(get(%q0/mail-in-progress-cc)))]

        1 = strmatch(get(%q0/mail-in-progress), false), 
        {
#
# No mail message is in progress. 
#

          @pemit %# = u(not_writing_mail); 
          @no %q0
        },

        not(hasattr(%q0, mail-in-progress-cc)),
        {

          @swi/first or(
                 strmatch(%q1, $), 
                 strmatch(%q1, ^), 
                 eq(strlen(%q1), 0)
               ) = 1, 
          {
#
# There is no CC currently set.  Make the value of CC to be <new text>.
# User requested text to be either appended ($) or prefixed (^), or
# did not specify <old text> to replace.
#
            @tr me/cleanup_edit_mail_cc = %#, u(clean_dist, %q2), %q0
          },
          {
#
# There is no CC currently set and therefore <old text> is not present.
#
            @pemit %# = Unable to find '%q1' in current value for CC.; 
            @no %q0
          }
        },

        strmatch(%q1, $), 
        {
#
# Append <new text> to the end of the current CC.
#

          @tr me/cleanup_edit_mail_cc = 
            %#, 
            u(clean_dist, {%q3, %q2}), 
            %q0
        },

        strmatch(%q1, ^), 
        {
#
# Add <new text> to the beginning of the current CC.
#

          @tr me/cleanup_edit_mail_cc = 
            %#, 
            u(clean_dist, {%q2, %q3}), 
            %q0
        },

        strmatch(%q3, *%q1*),
        {
#
# Replace <old text> with <new text>
#
          @tr me/cleanup_edit_mail_cc = 
            %#, u(clean_dist, edit(%q3, %q1, %q2)), %q0
        },

        {
          @pemit %# = Unable to find '%q1' in current value for CC.%b 
          Please check the exact format of the current value for CC by 
          doing a +proof.; 
          @no %q0
        }
      }
    }

-
&CLEAN_DIST #4167 = 

  squish(remove(edit(edit(%0, \(personal mail alias\), ), 
  \(global mail alias\), ), and))

-
&CLEANUP_EDIT_MAIL_CC #4167=
#
# PURPOSE:
#
#   This routine does cleanup processing for the +edit cc command.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - list of dbrefs and alias names
#   %2 - dbref of invoker's mailbox
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of dbrefs of who to CC to
#   2 - global mail aliases
#   3 - personal mail aliases
#   4 - aliases in %1
#

#
# Convert list of names specified by the user into dbrefs
#

  @swi/first 
  
    [setq(1, ulocal(identify_to_list, {%1}, %2))]
    [setq(2, get(%vm/global-mail-aliases))]
    [setq(3, get(%2/alias-list))]
    [setq(4, u(get_aliases, {%1}, %2, %q2, %q3))]

  %q1 = *ABORT*, 
  {
#
# Error detected in final CC list, no change.  
#

    @pemit %0 = secure(after(before(%q1, ENDABORT), ABORT)); 
    @no %2
  },
  {
#
# Set user displayable text for who to CC the letter to.
#

    &mail-in-progress-cc %2 = u(pretty_dist, %q4, %2, %q3, %q2, %q1); 

#
# Set the list of raw dbrefs for who to CC the letter to.
#

    &mail-in-progress-cc-expanded %2 = 
      setunion(%q1 [ulocal(expand_aliases, %q4, %2, %b, %q2, %q3)], ); 

    @swi/first words(get(%2/mail-in-progress-cc-expanded)) = 0,
    {
#
# CC cleared.
#

      @pemit %0 = No carbon copy set.; 
      @no %2
    },
    {
#
# Show current value of CC
#

      @pemit %0 = The carbon copy (cc) line now reads:
        %b%b[get(%2/mail-in-progress-cc)]; 
      @no %2
    }
  }

-

  &edit_cc_blank #300 = $+edit cc: @pemit %# = The syntax is 
    +edit cc=<old text>/<new text>.

-
###############################################################################
#
#                               B C C
#
###############################################################################
&BCC_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to register a list of people to blind 
#   carbon copy the current piece of mail being written.  The list may
#   include player names, personal aliases and global aliases.
#
# Command Format:
#
#   +bcc <list of people>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of dbrefs matching names specified for who to BCC to
#   2 - global mail alias names
#   3 - personal mail alias names
#   4 - list of aliases specified
#

  $+bcc*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *[*)), 
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +bcc%0; 

        @swi/first 
 
#
# Convert list of names specified by the user into dbrefs
#
          [setq(1, ulocal(identify_to_list, {%0}, %q0))]
          [setq(2, get(%vm/global-mail-aliases))]
          [setq(3, get(%q0/alias-list))]
          [setq(4, u(get_aliases, {%0}, %q0, %q2, %q3))]

        1 = strmatch(get(%q0/mail-in-progress), false),
        {
          @pemit %# = u(not_writing_mail); 
          @no %q0
        },

        strmatch(%q1, *ABORT*),
        {
#
# Error detected in input parameter.
#

          @pemit %# = secure(after(before(%q1, ENDABORT), ABORT)); 
          @no %q0
        },
        {
#
# Set user displayable text for who to BCC the letter to.
#

          &mail-in-progress-bcc %q0 = 
            u(pretty_dist, %q4, %q0, %q3, %q2, %q1); 

#
# Set the list of raw dbrefs for who to BCC the letter to.
#

          &mail-in-progress-bcc-expanded %q0 = 
            setunion(%q1 [ulocal(expand_aliases, %q4, %q0, %b, %q2, %q3)], ); 

          @pemit %# = 
            switch(
              hasattr(%q0, mail-in-progress-bcc-expanded), 
              0,
                No blind carbon copy (bcc) set.,
              The blind carbon copy (bcc) line now reads:
                %b%b[get(%q0/mail-in-progress-bcc)]
            ); 

          @no %q0
        }
      }
    }

-
&BCC_NO_PARAM #300=

  $+bcc: 

    @pemit %# = You must specify the name of the individual(s) that you 
      wish to be blind carbon copied on this piece of mail.

-
###############################################################################
#
#                            E D I T   B C C
#
###############################################################################
&EDIT_MAIL_BCC #300=
#
# PURPOSE:
#
#   This command may be used to edit the current 'BCC' that is registered
#   for this piece of mail (originally registered via the +bcc command).
#   The standard '^' and '$' may be used for <old text> to prepend and
#   append <new text> respectively.
#
# Command Format:
#
#   +edit bcc=<old text>/<new text>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - old text with leading and trailing spaces removed
#   2 - new text with leading and trailing spaces removed
#   3 - list of names of current BCC before edit (names separated by commas)
#

  $+edit bcc*=*/*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%2), *[*)),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +edit bcc%0=%1/%2; 

        @swi/first 

          [setq(1, lcstr(trim(%1)))]
          [setq(2, trim(%2))]
          [setq(3, lcstr(get(%q0/mail-in-progress-bcc)))]

        1 =  strmatch(get(%q0/mail-in-progress), false), 
        {
#
# No mail message is in progress.
#

          @pemit %# = u(not_writing_mail); 
          @no %q0
        },

        not(hasattr(%q0, mail-in-progress-bcc)),
        {

          @swi/first or(
                 strmatch(%q1, $), 
                 strmatch(%q1, ^), 
                 eq(strlen(%q1), 0)
               ) = 1, 
          {
#
# There is no BCC currently set.  Make the value of BCC to be <new text>.
# User requested text to be either appended ($) or prefixed (^), or
# did not specify <old text> to replace.
#
            @tr me/cleanup_edit_mail_bcc = %#, u(clean_dist, %q2), %q0
          },
          {
#
# There is no BCC currently set and therefore <old text> is not present.
#
            @pemit %# = Unable to find '%q1' in current value for BCC.; 
            @no %q0
          }
        },

        strmatch(%q1, $),
        {
#
# Append <new text> to the end of the current BCC.
#

          @tr me/cleanup_edit_mail_bcc = 
            %#, 
            u(clean_dist, {%q3, %q2}), 
            %q0
        },

        strmatch(%q1, ^),
        {
#
# Add <new text> to the beginning of the current BCC.
#

          @tr me/cleanup_edit_mail_bcc = 
            %#, 
            u(clean_dist, {%q2, %q3}), 
            %q0
        },

        strmatch(%q3, *%q1*),
        {
#
# Replace <old text> with <new text>
#

          @tr me/cleanup_edit_mail_bcc = 
            %#, u(clean_dist, edit(%q3, %q1, %q2)), %q0
        },

        {
          @pemit %# = Unable to find '%q1' in current value for BCC.%b 
          Please check the exact format of the current value for CC by
          doing a +proof.; 
          @no %q0
        }
      }
    }

-
&CLEANUP_EDIT_MAIL_BCC #4167=
#
# PURPOSE:
#
#   This routine does cleanup processing for the +edit bcc command.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - user displayable value for BCC after action taken
#   %2 - dbref of invoker's mailbox
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of dbrefs of who to BCC to
#   2 - global mail aliases
#   3 - personal mail aliases
#   4 - aliases in %1
#

  @swi/first 
#
# Convert list of names specified by the user into dbrefs
#
    [setq(1, ulocal(identify_to_list, {%1}, %2))]
    [setq(2, get(%vm/global-mail-aliases))]
    [setq(3, get(%2/alias-list))]
    [setq(4, u(get_aliases, {%1}, %2, %q2, %q3))]

  %q1 = *ABORT*,
  {
#
# Error detected in final BCC list.  No change.
#

    @pemit %0 = secure(after(before(%q1, ENDABORT), ABORT)); 
    @no %2
  },
  {
#
# Set user displayable text for who to BCC the letter to.
#

    &mail-in-progress-bcc %2 = u(pretty_dist, %q4, %2, %q3, %q2, %q1); 

#
# Set the list of raw dbrefs for who to BCC the letter to.
#

    &mail-in-progress-bcc-expanded %2 = 
      %q1 [ulocal(expand_aliases, %q4, %2, %b, %q2, %q3)]; 

    @swi/first words(get(%2/mail-in-progress-bcc-expanded)) = 0,
    {
#
# BCC cleared.
#

      @pemit %0 = No blind carbon copy set.; 
      @no %2
    },
    {
#
# Show current value of BCC
#

      @pemit %0 = The blind carbon copy (bcc) line now reads:
        %b%b[get(%2/mail-in-progress-bcc)]; 
      @no %2
    }
  }

-
&EDIT_BCC_BLANK #300 =

  $+edit bcc: @pemit %# = The syntax is +edit bcc=<old text>/<new text>.

-
###############################################################################
#
#                            E D I T   T O 
#
###############################################################################
&EDIT_MAIL_TO #300=
#
# PURPOSE:
#
#   This command may be used to edit the current 'TO' that is registered
#   for this piece of mail (originally registered via the +mail command).
#   The standard '^' and '$' may be used for <old text> to prepend and
#   append <new text> respectively.
#
# Command Format:
#
#   +edit to=<old text>/<new text>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - old text with leading and trailing spaces removed
#   2 - new text with leading and trailing spaces removed
#   3 - list of names of current TO before edit (names separated by commas)
#

  $+edit to*=*/*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%2), *[*)),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +edit to%0=%1/%2; 

        @swi/first 

          [setq(1, lcstr(trim(%1)))]
          [setq(2, trim(%2))]
          [setq(3, lcstr(get(%q0/mail-in-progress-to)))]

        1 = strmatch(get(%q0/mail-in-progress), false),
        {
#
# No mail message is in progress.
#

          @pemit %# = u(not_writing_mail); 
          @no %q0
        },

        not(hasattr(%q0, mail-in-progress-to)),
        {

          @swi/first or(
                 strmatch(%q1, $), 
                 strmatch(%q1, ^), 
                 eq(strlen(%q1), 0)
               ) = 1, 
          {
#
# There is no TO currently set.  Make the value of TO to be <new text>.
# User requested text to be either appended ($) or prefixed (^), or
# did not specify <old text> to replace.
#
            @tr me/cleanup_edit_mail_to = %#, u(clean_dist, %q2), %q0
          },
          {
#
# There is no TO currently set and therefore <old text> is not present.
#
            @pemit %# = Unable to find '%q1' in current value for TO.; 
            @no %q0
          }
        },

        strmatch(%q1, $),
        {
#
# Append <new text> to the end of the current TO.
#

          @tr me/cleanup_edit_mail_to = 
            %#, 
            u(clean_dist, {%q3, %q2}), 
            %q0
        },

        strmatch(%q1, ^),
        {
#
# Add <new text> to the beginning of the current TO.
#

          @tr me/cleanup_edit_mail_to = 
            %#, 
            u(clean_dist, {%q2, %q3}), 
            %q0
        },

        strmatch(%q3, *%q1*),
        {
#
# Replace <old text> with <new text>
#

          @tr me/cleanup_edit_mail_to = 
            %#, u(clean_dist, edit(%q3,%q1, %q2)), %q0
        },
        {
          @pemit %# = Unable to find '%q1' in current value for TO.%b 
          Please check the exact format of the current value for TO by
          doing a +proof.; 
          @no %q0
        }
      }
    }

-
&CLEANUP_EDIT_MAIL_TO #4167=
#
# PURPOSE:
#
#   This routine does cleanup processing for the +edit to command.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - user displayable value for TO after action taken
#   %2 - dbref of invoker's mailbox
#
# Registers Used:
#
#   1 - list of dbrefs for TO list     
#   2 - global mail aliases
#   3 - personal mail aliases
#   4 - aliases in %1
#

  @swi/first 
 
#
# Convert list of names specified by the user into dbrefs
#
    [setq(1, ulocal(identify_to_list, {%1}, %2))]
    [setq(2, get(%vm/global-mail-aliases))]
    [setq(3, get(%2/alias-list))]
    [setq(4, u(get_aliases, {%1}, %2, %q2, %q3))]

  %q1 = *ABORT*, 
  {
#
# Error detected in input parameter.
#

    @pemit %0 = secure(after(before(%q1, ENDABORT), ABORT)); 
    @no %2
  },

  {
#
# Set user displayable text for who to TO the letter to.
#

    &mail-in-progress-to %2 = u(pretty_dist, %q4, %2, %q3, %q2, %q1); 

#
# Set the list of raw dbrefs for who to send the letter to.
#

    &mail-in-progress-to-expanded %2 = 
      %q1 [ulocal(expand_aliases, %q4, %2, %b, %q2, %q3)]; 

    @swi/first words(get(%2/mail-in-progress-to-expanded)) = 0,
    {
#
# TO cleared.
#

      @pemit %0 = No destination set.; 
      @no %2
    },
    {
#
# Show current value of TO
#

      @pemit %0 = The 'TO' line now reads:%b%b[get(%2/mail-in-progress-to)]; 
      @no %2
    }
  }

-
&EDIT_TO_BLANK #300 = 

  $+edit to: @pemit %# = The syntax is +edit to=<old text>/<new text>.

-
###############################################################################
#
#                        E D I T   S U B J E C T                     
#
###############################################################################
&EDIT_MAIL_SUBJECT #300=
#
# PURPOSE:
#
#   This command may be used to edit the current subject line that is 
#   registered for this piece of mail (originally registered via the 
#   +mail command). The standard '^' and '$' may be used for <old text> 
#   to prepend and append <new text> respectively.
#
# Command Format:
#
#   +edit subject=<old text>/<new text>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - old text with leading and trailing spaces removed
#   2 - new text with leading and trailing spaces removed
#

  $+edit sub*=*/*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%2), *[*)),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +edit sub%0=%1/%2; 

        @swi/first 

          [setq(1, s(u(clean_text, %1)))]
          [setq(2, s(u(clean_text, %2)))]

        1 = strmatch(get(%q0/mail-in-progress), false),
        {
          @pemit %# = u(not_writing_mail); 
          @no %q0
        },

        not(hasattr(%q0, mail-in-progress-subject)),
        {

          @swi/first or(
                 strmatch(%q1, $), 
                 strmatch(%q1, ^), 
                 eq(words(%q1), 0)
               ) = 1, 
          {
#
# There is no SUBJECT currently set.  Make the value of SUBJECT to be 
# <new text>.  User requested text to be either appended ($) or 
# prefixed (^), or did not specify <old text> to replace.
#
            &mail-in-progress-subject %q0 = %q2; 
            @pemit %# = The subject line now reads:
              %b%b[get_eval(%q0/mail-in-progress-subject)]; 
            @no %q0
          },
          {
#
# There is no SUBJECT currently set and therefore <old text> is not present.
#
            @pemit %# = Unable to find '%q1' in current value for 
              SUBJECT.; 
            @no %q0
          }
        },
 
        strmatch(%q1, $),
        {
          @edit %q0/mail-in-progress-subject = %q1, {%q2}; 
          @pemit %# = The subject line now reads:
            %b%b[get_eval(%q0/mail-in-progress-subject)]; 
          @no %q0
        },

        strmatch(%q1, ^),
        {
          @edit %q0/mail-in-progress-subject = %q1, {%q2}; 
          @pemit %# = The subject line now reads:
            %b%b[get_eval(%q0/mail-in-progress-subject)]; 
          @no %q0
        },

        strmatch(get(%q0/mail-in-progress-subject), *%q1*), 
        {
          @edit %q0/mail-in-progress-subject = {%q1}, {%q2}; 
          @pemit %# = The subject line now reads:
            %b%b[get_eval(%q0/mail-in-progress-subject)]; 
          @no %q0
        },
        {
          @pemit %# = Unable to find '%q1' in current value for 
            SUBJECT.; 
          @no %q0
        }
      }
    }

-
&EDIT_SUBJECT_BLANK #300=

  $+edit subject: @pemit %# = The syntax is +edit subject=<old text>/<new text>.

-
###############################################################################
#
#                            E D I T   T E X T 
#
###############################################################################
&EDIT_MAIL_TEXT #300=
#
# PURPOSE:
#
#   This command may be used to edit the text for the mail message in 
#   progress.  The standard '^' and '$' may be used for <old text>
#   to prepend and append <new text> respectively.
#
# Command Format:
#
#   +edit text=<old text>/<new text>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - old text with leading and trailing spaces removed
#   2 - new text with leading and trailing spaces removed
#

  $+edit text*=*/*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(%q0),
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +edit text%0=%1/%2; 

        @swi/first 

          [setq(1, s(u(clean_text, %1)))]
          [setq(2, squish(u(clean_text, %2)))]

        1 = strmatch(get(%q0/mail-in-progress), false),
        {
          @pemit %# = u(not_writing_mail); 
          @no %q0
        }, 

        not(hasattr(%q0, mail-in-progress-body)), 
        {

          @swi/first or(
                 strmatch(%q1, $), 
                 strmatch(%q1, ^), 
                 eq(words(%q1), 0)
               ) = 1, 
          {
#
# There is no TEXT currently set.  Make the value of TEXT to be 
# <new text>.  User requested text to be either appended ($) or 
# prefixed (^), or did not specify <old text> to replace.
#
            &mail-in-progress-body %q0 = %q2; 
            @tr me/cleanup_edit_mail_text = %#, %q0
          },
          {
#
# There is no TEXT currently set and therefore <old text> is not present.
#
            @pemit %# = Unable to find '%q1' in current value for TEXT.; 
            @no %q0
          }
        }, 

        strmatch(%q1, $),
        {
          @edit %q0/mail-in-progress-body = %q1, {%q2}; 
          @tr me/cleanup_edit_mail_text = %#, %q0
        },

        strmatch(%q1, ^),
        {
          @edit %q0/mail-in-progress-body = %q1, {%q2}; 
          @tr me/cleanup_edit_mail_text = %#, %q0
        },

        strmatch(get(%q0/mail-in-progress-body), *%q1*),
        {
          @edit %q0/mail-in-progress-body = {%q1}, {%q2}; 
          @tr me/cleanup_edit_mail_text = %#, %q0
        },

        {
          @pemit %# = Unable to find '%q1' in current value for TEXT.; 
          @no %q0
        }
      }
    }

-
&CLEANUP_EDIT_MAIL_TEXT #4167=
#
# PURPOSE:
#
#   This routine does cleanup processing for the +edit text command.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - dbref of invoker's mailbox
#
# Registers Used:
#
#   0 - user's format option
#   1 - cc
#   2 - bcc
#   3 - flags
#

  &mail-in-progress-body %1 = u(clean_text, get(%1/mail-in-progress-body)); 

  @pemit %0 = 

    [setq(0, u(get_format_option, get(%0/mail_config_options)))]
    [setq(1, get(%1/mail-in-progress-cc))]
    [setq(2, get(%1/mail-in-progress-bcc))]
    [setq(3, get(%1/mail-in-progress-flags))]

    [switch(%q0, standard, {[u(equal_line)]%r})]

    To:[space(7)][trim(get(%1/mail-in-progress-to))]

    [switch(words(%q1), 0,, %rCc:[space(7)][trim(%q1)])]

    [switch(words(%q2), 0,, %rBcc:[space(6)][trim(%q2)])]

    %rSubject:%b%b[get(%1/mail-in-progress-subject)]

    [switch(words(%q3), 0,, %rFlags:%b%b%b%b)]

    [switch(match(%q3, u), 0,, [v(mail_flag_u)]%b%b)]

    [switch(match(%q3, rr), 0,, [v(mail_flag_rr)]%b%b)]

    [switch(match(%q3, r), 0,, [v(mail_flag_r)]%b%b)]

    [switch(match(%q3, o), 0,, [v(mail_flag_p)]%b%b)]

    [switch(%q0, standard, {%r[u(dash_line)]%r%r},%rText:%b%b)]

    [get_eval(%1/mail-in-progress-body)]

    [switch(%q0, standard, {%r%r[u(equal_line)]})]

    %r
    [u(finish_msg)]; 

  @no %1

-
&EDIT_TEXT_BLANK #300=

  $+edit text: @pemit %# = The syntax is +edit text=<old text>/<new text>.

-
&EDIT_BLANK #300=

  $+edit: 

    @pemit %# = You must specify what you wish to edit. The syntax of the 
      command is +edit <mail part>=<old text>/<new text>, where mail part 
      may be one of the following:%b%bto, cc, bcc, subject or text.

-
###############################################################################
#
#                         S E T   M A I L   F L A G
#
###############################################################################
&SET_MAIL_FLAG #300=
#
# PURPOSE:
#
#   This command may be used to set or clear flags associated with the
#   mail message in progress.                                      
#
# Command Format:
#
#   +set mail flag <flag>  - sets the flag
#   +set mail flag !<flag> - clears the flag
#
#   Flags available:
#
#     URGENT (U)
#
#             Assigns an urgent priority to the mail
#
#     REPLY REQUESTED (RR)
#
#             Indicates the sender wishes a reply from the receiver of
#             the mail
#
#     PRIVATE (P)
#
#             Indicates the sender is requesting that the mail contents be
#             viewed in a 'for your eyes only' mode by the receiver
#
#     REGISTERED (R)
#
#             Perhaps the most intriguing flag. Mail sent with this flag
#             set will result in a mail message being sent back to the
#             originator when the person the mail was addressed to reads it.
#             This 'receipt notification' mail will tell you the date and
#             time the mail was read by the recipient, in addition to the
#             date and time of the original mail and the subject line.
#
# Registers Used:
#
#   0 - user's mailbox dbref
#

  $+set mail flag *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(%q0),
    {
      @pemit %# = u(not_writing_mail)
    },
    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +set mail flag %0; 

        @swi/first 1 = 

        strmatch(get(%q0/mail-in-progress), false),
        {
          @pemit %# = u(not_writing_mail); 
          @no %q0
        },

#
# Set the flag
#
        strmatch(%0, r), 
        {
          @tr me/set_flag_guts = %#, R, v(mail_flag_r) (R), %q0
        },

        strmatch(%0, rr), 
        {
          @tr me/set_flag_guts = %#, RR, v(mail_flag_rr) (RR), %q0
        },

        strmatch(%0, u*), 
        {
          @tr me/set_flag_guts = %#, U, v(mail_flag_u) (U), %q0
        },

        strmatch(%0, p*), 
        {
          @tr me/set_flag_guts = %#, P, v(mail_flag_p) (P), %q0
        },

        strmatch(%0, rep*), 
        {
          @tr me/set_flag_guts = %#, RR, v(mail_flag_rr) (RR), %q0
        },

        strmatch(%0, reg*), 
        {
          @tr me/set_flag_guts = %#, R, v(mail_flag_r) (R), %q0
        }, 

#
# Clear the flag
#

        strmatch(%0, !r), 
        {
          @tr me/clear_flag_guts = %#, R, v(mail_flag_r) (R), %q0
        },

        strmatch(%0, !rr), 
        {
          @tr me/clear_flag_guts = %#, RR, v(mail_flag_rr) (RR), %q0
        },
 
        strmatch(%0, !u*), 
        {
          @tr me/clear_flag_guts = %#, U, v(mail_flag_u) (U), %q0
        },
 
        strmatch(%0, !p*), 
        {
          @tr me/clear_flag_guts = %#, P, v(mail_flag_p) (P), %q0
        },

        strmatch(%0, !rep*), 
        {
          @tr me/clear_flag_guts = %#, RR, v(mail_flag_rr) (RR), %q0
        },

        strmatch(%0, !reg*), 
        {
          @tr me/clear_flag_guts = %#, R, v(mail_flag_r) (R), %q0
        },

        {
          @pemit %# = That is not a valid mail flag. Available flags 
            are: 
            [v(mail_flag_u)] (U), 
            [v(mail_flag_rr)] (RR), 
            [v(mail_flag_p)] (P), 
            [v(mail_flag_r)] (R);  

          @no %q0
        }
      }
    }

-
&CLEAR_FLAG_GUTS #4167=
#
# PURPOSE:
#
#   This is a helper routine for 'set mail flag !<flag>'.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - flag to clear
#   %2 - user displayable value of flag to clear
#   %3 - dbref of user's mailbox
#
# Registers Used:
#
#   0 - flags
#

  @pemit %0 = 

      [setq(0, get(%3/mail-in-progress-flags))]

    switch(
      match(%q0, %1), 
      0, The %2 flag is not currently set for this mail message.,
      The %2 flag has been cleared.
    ); 

  &mail-in-progress-flags %3 = squish(remove(%q0, %1)); 

  @no %3

-
&SET_FLAG_GUTS #4167=
#
# PURPOSE:
#
#   This is a helper routine for 'set mail flag <flag>'.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - flag to set
#   %2 - user displayable value of flag to set
#   %3 - dbref of user's mailbox
#
# Registers Used:
#
#   0 - flags
#

  @pemit %0 = 

      [setq(0, get(%3/mail-in-progress-flags))]

    switch(
      match(%q0, %1), 
      0, The %2 flag has been set., 
      The %2 flag is already set for this mail message.
    ); 

  &mail-in-progress-flags %3 = setunion(get(%3/mail-in-progress-flags) %1, ); 

  @no %3

-
&SET_MAIL_FLAG_BLANK #300=

  $+set mail flag: 

    @pemit %# = You must specify which flag you wish to set. 
      Current options are: Private (P), Urgent (U), Registered (R) 
      and Reply Requested (RR).

-
###############################################################################
#
#                                S E N D         
#
###############################################################################
&SEND_COMMAND #300=
#
# PURPOSE:
#
#   This command may be used to send a letter.
#
# Command Format:
#
#   +send
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of dbrefs to deliver to (to, cc, bcc)
#

  $+send: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER), 
    {
      @pemit %# = u(not_player)
    }, 

    strlen(%q0), 
    {
      @pemit %# = u(not_writing_mail)
    }, 
    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +send; 

        @swi/first 

#
# Grab the complete destination list.  Includes TO, CC and BCC.
# Weed out duplicates.
#
          [setq(1, u(get_final_delivery_list, %q0))]

        1 = strmatch(get(%q0/mail-in-progress), false), 
        {
#
# There is no mail in progress to send.
#

          @pemit %# = You do not have a mail message ready to send.; 
          @no %q0
        }, 

        eq(words(%q1), 0), 
        {  
          @pemit %# = You do not have a destination specified.; 
          @no %q0
        }, 

        {
          @tr me/store_letter = 
            %q0, 
            get(%q0/mail-in-progress-subject), 
            get(%q0/mail-in-progress-to), 
            get(%q0/mail-in-progress-to-expanded), 
            get(%q0/mail-in-progress-cc), 
            get(%q0/mail-in-progress-cc-expanded), 
            get(%q0/mail-in-progress-bcc), 
            get(%q0/mail-in-progress-bcc-expanded), 
            get(%q0/mail-in-progress-flags), 
            get(%q0/mail-in-progress-body); 

          @tr me/cleanup_send = %#, %q0
        }
      }
    }

-
&GET_FINAL_DELIVERY_LIST #4167=
#
# PURPOSE:
#
#   This is a helper routine for '+send' and '--'. 
#
#   Basically, all it does it put together a single list of dbrefs that
#   a mail message is to be sent to, including all TO, CC and BCC
#   recipients (with duplicates weeded out).
#
# INPUT:
#
#   %0 - dbref of user's mailbox
#
# OUTPUT:
# 
#   list of dbrefs of who to send the message to
#

  trim(setunion(
    [get(%0/mail-in-progress-to-expanded)] 
    [get(%0/mail-in-progress-cc-expanded)] 
    [get(%0/mail-in-progress-bcc-expanded)], 
  ))

-
&CLEANUP_SEND #4167=
#
# PURPOSE:
#
#   This routine does cleanup processing for the '+send' and '--' commands.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - dbref of invoker's mailbox
#

#
# Notify user that mail has been sent.
#

  @pemit %0 = u(pickup_notification); 

#
# Clear temporary attributes in mailbox that are used during mail message
# composition.
#

  &mail-in-progress-subject %1; 
  &mail-in-progress-to %1; 
  &mail-in-progress-to-expanded %1; 
  &mail-in-progress-cc %1; 
  &mail-in-progress-cc-expanded %1; 
  &mail-in-progress-bcc %1; 
  &mail-in-progress-bcc-expanded %1; 
  &mail-in-progress-flags %1; 
  &mail-in-progress-body %1; 
  &mail-in-progress %1 = false; 

  @no %1

-
###############################################################################
#
#                         R E T R A C T
#
###############################################################################
&RETRACT_MAIL #300=
#
# PURPOSE:
#
#   This command may be used to retract, or in other words, delete a 
#   letter you have previously sent but changed your mind about.  You
#   can only retract a letter if no one on the distribution has read 
#   it yet.
#
# Command Format:
#
#   +retract <letter number or keyword>
#
#   allowed keywords are:  first, next, previous, last, current
#
# Registers Used:
#
#   0 - dbref of invoker's mailbox 
#

  $+retract*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *[*)), 
    {
#
# Function calls are not allowed within input parameters
#

      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
#
# No mailbox, therefore, no messages to retract.
#
      @pemit %# = There is no mail to retract in your mailbox.
    },

    {

      @wait %q0 = 
      {
        &debug_mail %q0 = +retract%0; 
          
        @swi/first 

          [setq(1, get(%q0/out-list))]

#
# Interpret user input and convert into an internal mail number
#
          [setq(2,
            ulocal(expand_single_letter_range,
            trim(%0), %q1, get(%q0/out-list-current))
          )]

        1 = eq(words(%q1), 0), 
        {
#
# Previously sent mail list is empty.  
# Notify user, clear global variable and release the semaphore.
#

          @pemit %# = There is no mail to retract in your mailbox.; 
          @no %q0
        }, 

        strmatch(%q2, *ABORT*), 
        {
#
# Error detected in user input.  Notify user, clear global variables
# and release the semaphore.
#

          @pemit %# = after(before(%q2, ENDABORT), ABORT); 
          @no %q0
        },

        u(any_read, %q0, %q2), 
        {
          @pemit %# = One or more recipients of the designated letter 
            has already read it, therefore it cannot be retracted.; 
          @no %q0
        }, 

        {
#
# Call RETRACT_MAIN to do the actual processing of the retract letter
#

          @tr me/retract_main = 
            %#, 
            %q0, 
            %q2, 
            [u(convert_nums, %q2, %q1)][ulocal(format_request, trim(%0))] 
        }
      }
    }

-
&ANY_READ #4167 = 
#
# PURPOSE:
# 
#   Determine if a previously sent letter has been read by any of
#   the recipients.  This is a helper routine for +retract.
#
# %0 - dbref of mailbox
# %1 - internal number of sent mail
#
# Returns a 1 if any of the distributed copies of the specified 
# letter has been read.  A 0 otherwise.
#
# Registers used:
#
#   3 - dbref of destination
#   4 - internal mail number of destination
#

  strmatch(
    iter(
      get(%0/out-%1-dist), 
       
          [setq(3, get(#7/mailbox_[before(##, :)]))]
          [setq(4, after(##, :))]

        and(
          strmatch(
            get(%q3/in-%q4-time_read), 
            0
          ), 
          strmatch(first(get(%q3/in-%q4-location)), %0), 
          strmatch(rest(get(%q3/in-%q4-location)), %1)
        )
    ), 
    *0*
  )

-
&RETRACT_MAIN #4167=
#
# PURPOSE:
#
#   This is a helper routine for '+retract' and '+destroy mailbox'.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - dbref of mailbox
#   %2 - internal number of letter to retract
#   %3 - formatted user request (or %b if called from destroy mailbox)
#
# Registers used:
#
# 0 - mail list
# 1 - current letter
# 2 - mailbox dbref for receiving mailbox
# 3 - internal number in receiving mailbox
#

  @dolist get(%1/out-%2-dist) = 
  {
    @tr 

        [setq(2, get(%vm/mailbox_[before(##, :)]))]
        [setq(3, after(##, :))]

      me/remove_letter
      [switch(member(get(%1/out-%2-held), before(##, :)), 0,-NO-OP,2)] 
      = %q2, %q3, %0, %1, %2, %3
  }; 

  @swi 1 = 1, 
  {
    &out-list-current %1 = 
  
        [setq(0, get(%1/out-list))]
        [setq(1, get(%1/out-list-current))]

      switch(
        %q1+[last(%q0)], 
        %2+%2, first(rest(revwords(%q0))), 
        %2+*, extract(%q0, add(member(%q0, %2), 1), 1), 
        %q1
      );  
    
    &out-list %1 = squish(remove(%q0, %2)); 
    @wipe %1/out-%2-*; 
    @pemit %0 = Letter %3 has been retracted.; 
    @no %1
  }

-
&REMOVE_LETTER-NO-OP #4167=@@ do nothing
#  @pemit #2=Hit remove_letter-no-op debug: 
#  [get(%3/debug_mail)], src mailbox: %3, dest mailbox: %0,
#  out #:%4, in #: %1 invoker: %2; @@ do nothing

-
&REMOVE_LETTER2 #4167 =
#
# %0 - dbref of mailbox
# %1 - internal letter number
#

  @dolist get(%0/folder-list) = 
  {
    &current_letter-## %0 = 
  
        [setq(0, get(%0/in-list-##))]
        [setq(1, get(%0/current_letter-##))]

      switch(
        %q1+[last(%q0)], 
        %1+%1, first(rest(revwords(%q0))), 
        %1+*, extract(%q0, add(member(%q0, %1), 1), 1), 
        %q1
      );  
    
    &in-list-## %0 = squish(remove(get(%0/in-list-##), %1))
  };

  @swi 1 = 1, {@wipe %0/in-%1-*}

-
###############################################################################
#
#                         R E V I E W   L E T T E R S
#
###############################################################################
&REVIEW_LETTERS #300=
#
#   This command may be used to review (skim), all previously sent letters
#   that have not been deleted by all recipients.
#
#   Command Format:
#
#     +review 
#
#   The following keywords may be used to specify the scope of +review:
#
#     all, current, first, last, next, previous, to:<name>, subject:<text>,
#       text:<text fragment>
#
#   Registers Used:
#
#     0 - dbref of mailbox
#     1 - list of previously sent letters
#     2 - current letter (outgoing)
#     9 - user's format option
#

  $+review: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(1, get(%q0/out-list))]
      [setq(2, get(%q0/out-list-current))]
      [setq(9, u(get_format_option, get(%#/mail_config_options)))]

    0 = strlen(%q0),
    {
#
# User has no mailbox.
#

      @pemit %# = u(no_sent_mail)
    },

    words(%q1), 
    {
      @pemit %# = u(no_sent_mail)
    }, 

    {
      @pemit %# =
        [switch(%q9, standard,
          {[u(equal_line)]
          %r%r[center(List of Previously Sent Mail Messages, 78)]%r%r}
        )]
        [space(8)][ljust(Subject, 46)]%b%bSize%b%bSent
        %r[space(8)]-------[space(41)]----%b%b--------;

      @dolist get(%q0/out-list) =
      {
        @pemit %# = u(review_brief, %#, ##, %q0, %q1, %q2)
      };

      @swi 1 = 1,
      {
        @pemit %# = switch(%q9, standard, %r[u(equal_line)],,)
      }
    }

-
&REVIEW_BRIEF #4167 = 
#
# PURPOSE:
#
#   Obtain summary information for one previously sent letter.
#   (This is a helper routine for +review)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - internal mail message number of letter to obtain information about
#   %2 - dbref of mailbox
#   %3 - list of previously sent letters
#   %4 - current letter
#
# OUTPUT
#
#   A single line of information for the letter specified in %1
#
# Registers Used:
#
#   2 - external letter number
#   3 - subject of letter                          
#

  [setq(2, member(%3, %1))]
  [setq(3, trim(get(%2/out-%1-subject)))]

#
# a '+' is shown before the summary line that represents the current letter
#
  [switch(%1, %4, +, %b)]

#
# The letter number
#
  [rjust(%q2\)%b%b, 7)]

#
# The subject of the letter, truncated to 46 characters
#
  [ljust(mid(%q3, 0, min(46, strlen(%q3))), 48)]

#
# Size of the body of the letter, in bytes
#
  [ljust(strlen(u(%2/out-%1-text)), 6)]

#
# Date and time the letter was sent
#
  [mid(get(%2/out-%1-time_sent), 0, 16)]

-
###############################################################################
#
#                               R E V I E W 
#
###############################################################################
&REVIEW_LETTER #300=
#
#   This command may be used to review, or read a letter you have   
#   previously sent to the specified person.  Mainly just to refresh
#   your mind about what you sent if you didn't +cc or +bcc yourself
#   on it.  It also is a reasonable thing to do before doing a +retract
#   letter.
#
#   The following keywords are available to specify the scope of +review:
#
#     all, current, first, last, next, previous, to:<name>, 
#       subject:<text>, text:<text fragment>
#
#   Only the first character of the keyword needs to be specified.
#
#   This command also accepts a list of numbers including ranges.%b 
#   For example:%b +review 1 3-5 8.%b Either a '-' or '..' may be used to 
#   indicate a range specification.  The numbers to be used are those
#   shown on +review letters output.
#
# Command Format:
#
#   +review <number or keyword>
#
# Registers Used:
#
#   0 - dbref of mailbox for <person>
#

  $+review*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(2, switch(%0, /b*, skim, /s*, skim, /f*, read, /r*, read, read))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    words(%0),,
#
# Let +review cmd handle it
#
   
    not(strmatch(escape(%0), *[*)),
    {
#
# Function calls are not allowed within an input parameter
#

      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(no_sent_mail)
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +review%0; 

        @swi/first 

          [setq(1, get(%q0/out-list))]
          [setq(9, u(get_format_option, get(%#/mail_config_options)))]

        0 = words(%q1), 
        {
#
# There is no stored (outgoing) mail in the user's mailbox.  
# Notify the user and release the semaphore.
#

          @pemit %# = u(no_sent_mail); 
          @no %q0
        },

        {
         
          @swi/first 

#
# Interpret user input and convert into a list of internal mail numbers
# representing the user specified criteria.
#
          [setq(3, 
            ulocal(expand_outgoing_letter_range, 
	      switch(%0, /*, rest(%0), %0), 
              %q1, 
              get(%q0/out-list-current), 
              %q0
            )
          )]

          1 = 

          strmatch(%q3, *ABORT*),
          {
#
# Error detected in input parameter.
#
# Notify the user and release the semaphore.
#

            @pemit %# = after(before(%q3, ENDABORT), ABORT);  
            @no %q0
          },

          eq(words(%q3), 0),
          {
#
# Could not find any letters to match the specified input parameter.
#
# Notify the user and release the semaphore.
#
            @pemit %# = 
	      u(no_match, +review, ulocal(format_request, trim(
                switch(%0, /*, rest(%0), %0), )), u(get_active_folder, %q0));
            @no %q0
          },
          {

          @pemit %# =
            switch(%q2, read,,skim,{
            [switch(%q9, standard,
              {[u(equal_line)]
              %r%r[center(List of Previously Sent Mail Messages, 78)]%r%r}
            )]
            [space(8)][ljust(Subject, 46)]%b%bSize%b%bSent
            %r[space(8)]-------[space(41)]----%b%b--------});

            @dolist 

#
# Reorder the list of letters to 'review' into the same order as the 
# out-list attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
              [setq(3, u(filter_list, setunion(%q3, ), %q1))]

            %q3 =
            {
#
# Display information to user about one outgoing letter
# 
              @pemit %# = switch(%q2, read, 
                ulocal(read_bulk_private, %#, %q0, ##, %q9), 
                ulocal(review_brief, %#, ##, %q0, %q1, 
                    get(%q0/out-list-current)))
            }; 

            @swi 1 = 1, 
            {
#
# Set out-list-current to be the last letter reviewed
#

              &out-list-current %q0 = switch(%q2, read, last(%q3), 
                get(%q0/out-list-current));

#
# Finished showing information about the letter(s) specified.  Release
# the semaphore.  Extra switch is needed to keep the queue accurate.
#
              @swi 1 = 1,
              {
                @pemit %# = switch(%q2, read,,skim, u(equal_line)); 
                @no %q0
              }
            }
          }
        }
      }
    }

-
&READ_BULK_PRIVATE #4167=
#
# PURPOSE:
#
#   Obtain detailed information for one letter in a mailbox.
#   (This is a helper routine for +review <number or keyword>)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - dbref of mailbox
#   %2 - internal number of letter
#   %3 - user's format option
#
# OUTPUT
#
#   Detailed information for one previously sent letter.
#
# Registers used:
#
#   4 - cc list
#   5 - bcc list
#   6 - external number
#   7 - out-list
#
# CAUTION:  use ulocal() when invoking this function
#
 
    [setq(4, get(%1/out-%2-cc))]
    [setq(5, get(%1/out-%2-bcc))]
    [setq(7, get(%1/out-list))]
    [setq(6, member(%q7, %2))]

  [switch(%3, standard, {[u(equal_line)]%r})]

  [ljust(Message:, 10)][ljust(%q6/[words(%q7)], 9)]

#
# Date and time sent
#
  [rjust(Sent:%b%b[get(%1/out-%2-time_sent)], 59)]

#
# Who the mail was addressed to
#
  %r[ljust(To:, 10)][trim(get(%1/out-%2-to))]

#
# The CC list
#
  [switch(words(%q4), 0,,%r[ljust(Cc:, 10)][trim(%q4)])]

#
# The BCC list
#
  [switch(words(%q5), 0,,%r[ljust(Bcc:, 10)][trim(%q5)])]

#
# Still held by
#

  %r[ljust(Held By:, 10)][u(pretty_dist, get(%1/out-%2-held))]

#
# Subject of the letter
#
  %r[ljust(Subject:, 10)][trim(get(%1/out-%2-subject))]

#
# line of dashes
#
  [switch(%3, standard, {%r[u(dash_line)]%r%r},%rText:[space(11)])]

#
# main body of text
#
  [u(%1/out-%2-text)]

  [switch(%3, standard, {%r%r[u(equal_line)]})]

-
###############################################################################
#
#           S T A T U S   O F   M A I L   S E N T   T O   <P E R S O N>
#
###############################################################################
# ==============================================================================
#
#             Status of messages you have sent to Brandy
#
# Subject                            Sent on           Read
# ------------------------------------------------------------------------------
# mail code                          Sun Jan 24 22:24  Sun Jan 24 23:00
# Re: The medical facilities         Mon Mar  1 12:46  Message has not been read
# ==============================================================================

&STATUS_OF_MAIL_SENT #300=
#
# PURPOSE:
#
#   This command may be used to see the status of any messages from 
#   you in <person>'s mailbox.  If the message has been read, it will
#   show the date and time, if it has not been read, it will simply say
#   'Message has not been read'.  The display shows you the subject
#   line of the original mail message and the time it was sent.  
#   Obviously, once the mail has been deleted from <person>'s mailbox,
#   status for that letter will no longer be shown.
#
# Command Format:
#
#   +status of mail sent to <person>
#
# Registers Used:
#
#   0 - dbref of user's mailbox
#   1 - dbref of <person>'s mailbox
#   2 - list of letters in <person>'s mailbox
#   3 - list of letters in <person>'s mailbox from invoker
#   4 - user's format option
#   5 - subject
#   6 - time_read
#   7 - internal number of letter
#

  $+status of mail sent to *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(1, get(%vm/mailbox_[num(*%0)]))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strmatch(type(*%0), PLAYER),
    {
      @pemit %# = [capstr(%0)] is not a player.
    }, 

    strlen(%q0), 
    {
      @pemit %# = u(no_mail_from_you, [name(*%0)])
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +status of mail sent to %0; 

        @swi/first 

          [setq(2, get(%q0/out-list))]
          [setq(3, 
            squish(iter(%q2, 
              switch(
                get(%q0/out-##-dist), 
                *[num(*%0)]:*, ##
              )
            ))
          )]

        0 = words(%q2),
        {
          @pemit %# = u(no_mail_from_you, [name(*%0)]); 
          @no %q0
        },

        words(%q3), 
        {
#
# No letters from invoker in <person>'s mailbox.
#

          @pemit %# = u(no_mail_from_you, [name(*%0)]); 
          @no %q0
        },

        {
#
# Show header info
#

          @pemit %# = 

              [setq(4, u(get_format_option, get(%#/mail_config_options)))]

            [switch(%q4, standard, 
              {[u(equal_line)]
              %r%r[space(13)]Status of messages you have sent 
                to [name(*%0)]%r%r}
            )]
            #%b%b%b%bSubject[space(23)]Sent on[space(11)]Read

            [switch(%q4, standard, {%r[u(dash_line)]})]; 

#
# For each letter sent by invoker, show one line of information.
#

          @dolist %q3 = 
          {
            @pemit %# = 

              [setq(5, trim(get(%q0/out-##-subject)))]
              [setq(6, get(%q1/in-[after(extract(get(%q0/out-##-dist), 
                match(get(%q0/out-##-dist), [num(*%0)]:*), 1), :)]-time_read)
              )]

              [rjust(member(get(%q0/out-list), ##), 3)]%b%b
#
# The subject of the letter, truncated to 28 characters
#
              [ljust(mid(%q5, 0, min(28, strlen(%q5))), 30)]

#
# Time letter was originally received.
#

              [mid(get(%q0/out-##-time_sent), 0, 16)]%b%b

#
# Indication if the letter has been deleted, or has not been read yet.
#

              [switch(%q6+[words(%q6)], *+0, Message has been deleted, 
                0+*, Message has not been read, mid(%q6, 0, 16))]
          }; 

          @swi 1 = 1, 
          {
#
# Done, release semaphore.
#
            @pemit %# = switch(%q4, standard, u(equal_line),,); 
            @no %q0
          }
        }
      }
    }

-
&STATUS_OF_MAIL_SENT_BLANK #300=

  $+status of mail sent: 

    @pemit %# = The syntax is +status of mail sent to <person>.

-
###############################################################################
#
#                         A D M I N I S T R A T I O N
#
###############################################################################

###############################################################################
#
#                            M A I L   S T A T U S                           
#
###############################################################################
&MAIL_ADMIN_COMMAND #300=
#
# PURPOSE:
#
#   This Wizard-only command may be used to obtain summary information 
#   about all mailboxes.  Information shown includes:  dbref, person
#   whose mailbox it is, if mail is in progress, how many letters have
#   between received total, how many personal mail aliases are defined, 
#   how many folders are defined, how many filters are defined, 
#   and how many letters are currently stored in the mailbox.  This 
#   command is slow, but 'queue nice'.
#
#   If the semaphore is off on a mailbox, this will be flagged as an
#   error.  An attempt is made to also flag if it is an invalid mailbox
#   and/or if the person that the mailbox is for, is no longer a player.
#
# Command Format:
#
#   +mail status
#
# Registers Used:
#
#   0 - user's format option
#

  $+mail status: 

    @swi/first hasflag(%#, wizard) = 1,
    {
      @pemit %# = 

          [setq(0, u(get_format_option, get(%#/mail_config_options)))]

        [switch(%q0, standard, 
          {[u(equal_line)]%r[space(26)]Summary status of mailboxes%r%r}
        )]
        Mailbox%b%bOwner[space(12)]Writing? %b Filters%b 
          Aliases%b Folders%b Sent%b Received
        [switch(%q0, standard, {%r[u(dash_line)]})]; 
        
        @tr me/continue_mail_status = 
          %#, 1, %q0, get(%vm/mailboxes_num_of_attributes)
    }, 

    {
      @pemit %# = Permission denied.
    }

-
&CONTINUE_MAIL_STATUS #4167=
#
# PURPOSE:
#
#   If the current MAILBOXES_%1 is empty:
#
#     If there are no more MAILBOXES_* to try, terminate display.
#
#     Otherwise, call this function recursively to process the next list
#     of mailbox dbrefs.
#
#   Otherwise, MAILBOXES_%1 is NOT empty:
#
#     Call SHOW_ONE_MAILBOX to begin processing the list of mailbox dbrefs.
#
#   (This is a helper routine for the +mail status command)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - index of which list of mailbox dbrefs to try next
#   %2 - u(get_format_option, %0)
#   %3 - get(%vm/mailboxes_num_of_attributes)
#
# Registers Used:
#
#   0 - list of mailboxes for the current mailboxes_* being worked on
#

    @swi/first 

      [setq(0, get(%vm/mailboxes_%1))]

    [strlen(%q0)]+[gt(%3, %1)] = 

    0+0,
    {
#
# The attribute mailboxes_%1 is empty.  If there are no more
# mailboxes_*'s to check, terminate display, otherwise move
# on to the next attribute containing a list of mailboxes.
#
      @pemit %0 = switch(%2, standard, u(equal_line), )
    },

    0+*, 
    {
      @tr me/continue_mail_status = %0, add(1, %1), %2, %3
    }, 

    {
      @tr me/show_one_mailbox = 
        %0, 
        %q0, 
        1, 
        words(%q0),
        continue_mail_status, 
        0, 
        %1, 
        %2, 
        %3
    }

-
&EVALUATE_NEXT_LIST #4167 = 
#
# PURPOSE:
#
#   For a list of mailbox dbrefs, apply the received test function
#   to the mailbox and return a list of dbrefs which pass the test.
#
#   (This is a helper routine for all the +mail status commands)
#
# INPUT
#
#   %0 - number indicating which mailboxes_* to process
#   %1 - test function
#   %2 - parameter to test function
#
# OUTPUT
#
#   Returns a list of mailbox dbrefs which pass the test function
#

  iter(
    get(%vm/mailboxes_%0),
    switch(
      u(%1, ##, %2),
        1,
      ##,

    )
  )

-
&SHOW_ONE_MAILBOX #4167 = 
#
# PURPOSE:
#
#   For the given input parameters, process the indicated mailbox 
#   and then 'do the appropriate thing'. I.e., move to the next
#   mailbox in the current list, or move to the next list of 
#   mailboxes.  This is tediously slow, but queue nice, which
#   is important if there are a bazillion mailboxes.
#
#   (This is a helper routine for all the +mail status commands)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - list of mailbox dbrefs to process
#   %2 - positional reference for which mailbox to show
#   %3 - count of mailbox dbrefs in list (%1)
#   %4 - attribute name of continuation processor
#   %5 - parameter to pass along to continuation processor
#   %6 - number indicating which mailboxes_* thang is being worked on
#   %7 - u(get_format_option, %0)
#   %8 - get(%vm/mailboxes_num_of_attributes)
#

     @swi/first %3+[gt(%8, %6)] = 

     0+0,
     {
#
# No mailboxes to process.
# No more mailboxes_*'s to try, terminate display.
#

       @pemit %0 = switch(%7, standard, u(equal_line), )
     },

     0+*,
     {
#
# Call continuation processor to process the mailboxes in the next
# mailboxes_* attribute.
#

       @tr me/%4 = %0, add(1, %6), %5, %7, %8
     },

     {
#
# Show information for a single mailbox.
#

       @pemit %0 = u(get_info_for_one_mailbox, extract(%1, %2, 1)); 

       @swi/first %2+[gt(%8, %6)] = 

       %3+0, 
       {
#
# This is the last mailbox in the current list to process.
# There are no more mailboxes_*'s to try, terminate display.
#

         @pemit %0 = switch(%7, standard, u(equal_line), )
       },

       %3+*, 
       {
#
# Call continuation processor to process the mailboxes in the next
# mailboxes_* attribute.
#

         @tr me/%4 = %0, add(1, %6), %7, %8
       },

       {
#
# Move to the next mailbox in the current set of mailboxes to display.
#

         @tr me/show_one_mailbox = %0, %1, add(%2, 1), %3, %4, %5, %6, %7, %8
       }
     }

-
&GET_INFO_FOR_ONE_MAILBOX #4167 = 
#
# PURPOSE:
#
#   Obtain formatted information about the specified mailbox.
#
#   (This is a helper routine for all the +mail status commands)
#
# INPUT
#
#   %0 - dbref for mailbox to show one line information about
#
# OUTPUT
#
#   One formatted line containing summary information about the 
#   mailbox indicated in %0
#
# Registers Used:
#
#   0 - dbref of whose mailbox this is 
#   1 - current value of semaphore for mailbox in question
#   2 - mail-in-progress flag
#   3 - displayable value of semaphore
#
 
    [setq(0, get(%0/owner_dbref))]
    [setq(1, get(%0/semaphore))]
    [setq(2, get(%0/mail-in-progress))]
    [setq(3, [switch(%q1, -1,, {[switch(strlen(%q1), 0,
      %bsem 0, %bsem%q1)]})]
    )]

  [ljust(%0, 7)]
  [switch(hasattr(%0, autoforward), 0, %b%b, a%b)]

  [switch(0, 

  strmatch(owner(%0), owner(#7)), 
  {%b-- WARNING -- This mailbox object is not owned by the right player!},

  strlen(%q2),
  {%b-- WARNING -- This does not seem to be a valid mailbox.},

  strmatch(type(%q0), PLAYER), 
  {
    %b-- INFORMATIVE -- Mailbox for dest'ed player 
      (do a +destroy mailbox for %q0.  Caution:%b all mail sent by 
      that player will be removed from the destination mailboxes)
  },

  {
    [ljust(name(%q0), 17)]
    [ljust(%q2%q3, 11)]
    [rjust(
      add(
        words(get(%0/author_filter), ~), 
        words(get(%0/subject_filter), ~)
      ), 
      7
    )]
    [rjust(words(get(%0/alias-list)), 9)]
    [rjust(words(remove(get(%0/folder-list), null)), 9)]
    [rjust(words(get(%0/out-list)), 6)]
    [rjust(words(u(get_all_in_lists, %0)), 10)]
  }
  )]

-
###############################################################################
#
#                   M A I L   S T A T U S   S P E C I F I C         
#
###############################################################################
&MAIL_ADMIN_COMMAND_SPECIFIC #300 = 
#
# PURPOSE:
#
#   This Wizard-only command may be used to obtain detailed information
#   about a specific mailbox.  
#
#   Information shown includes:  
#     mailbox dbref, 
#     if mail is in progress
#     how many letters have been received total 
#     how many letters are currently stored in the mailbox
#     how many personal mail aliases are defined
#     how many folder are defined
#     if autoforward is set
#     value of message timeout, if set
#     value of the semaphore on the mailbox
#     value of the 'current letter'
#
# Also, do a 'sanity check' on the mailbox.
#
# Command Format:
#
#   +mail status for <person>
#
# Registers Used:
#
#   0 - dbref of mailbox for <person>
#

  $+mail status for *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_[num(*%0)]))]

    0 = hasflag(%#, wizard),
    {
#
# Invoked by non-Wiz
#

      @pemit %# = Permission denied.
    },

    strmatch(type(*%0), PLAYER),
    {
#
# Person specified is not currently a player.
#

      @pemit %# = [capstr(%0)] is not a player.
    },

    strlen(%q0),
    {
#
# Person specified does not have a mailbox.
#

      @pemit %# = [name(*%0)] does not currently have a mailbox.
    },
  
    {
      @tr me/display_mail_admin = %#, %q0
    }

-
&DISPLAY_MAIL_ADMIN #4167 = 
#
# PURPOSE:
#
#   Obtain detailed information about a specific mailbox.
#
#   (This is a helper routine for the +mail status for <person> command)
#
# INPUT
#
#   %0 - dbref of invoker  
#   %1 - dbref of mailbox
#
# Registers Used:
#
#   0 - user's format option
#   1 - dbref of owner whose mailbox it is
#   2 - mail-in-progress flag
#

  &folder-list %0 = squish(remove(get(%0/folder-list), null)); 

  @pemit %0 = 

      [setq(0, u(get_format_option, get(%0/mail_config_options)))]
      [setq(1, get(%1/owner_dbref))]
      [setq(2, get(%1/mail-in-progress))]

    [switch(%q0, standard, 
      {[u(equal_line)]
      %rDetailed status for [name(%q1)]'s mailbox:
      %r[u(dash_line)]%r}
    )]

    [rjust(Mailbox dbref:, 20)]%b%b%1
    [switch(strlen(%q2), 0,
    {
      %r-- WARNING --  This does not seem to be a valid mailbox.
    })]
    %r[rjust(Mail-in-progress:, 20)]%b%b%q2
    %r[rjust(Received:, 20)]%b%b[words(u(get_all_in_lists, %1))]
    %r[rjust(Sent:, 20)]%b%b[words(get(%1/out-list))]
    %r[rjust(Personal aliases:, 20)]%b%b[words(get(%1/alias-list))] 
      [switch(hasattr(%1, alias-list), 0,,
      ([u(list_names, trim(get(%1/alias-list)))]))]
    %r[rjust(Filters:, 20)]%b%b[ulocal(get_filter_count, %q1)]
    %r[rjust(Folders:, 20)]%b%b[words(get(%1/folder-list))] 
      [switch(hasattr(%1, folder-list), 0,,{
      ([u(secure_names, trim(get(%1/folder-list)))])})]
    %r[rjust(Autoforward:, 20)]%b%b[ulocal(get_autoforward_option, %q1)]
    %r[rjust(Message Timeout:, 20)]%b%b[ulocal(get_timeout_option, %q1)]
    %r[rjust(Semaphore:, 20)]%b%b[get(%1/semaphore)]
    %r[rjust(Current Letter:, 20)]%b%b[get(%1/[u(which_current_letter, %1)])]
    %r[rjust(Current Folder:, 20)]%b%b[secure(get(%1/current_folder))]
    %r[rjust(Inbox:, 20)]%b%b[secure(ulocal(get_inbox, %q1))]
    %r[rjust(Vacation:, 20)]%b%b[u(%1/vacation)]
    %r[rjust(Reject:, 20)]%b%b[u(%1/reject_msg)]
    %r[rjust(Filter reject:, 20)]%b%b[u(%1/filter_reject)]

    [switch(%q0, standard, {%r[u(equal_line)]})]; 

-
###############################################################################
#
#                   C H E C K   F O R   M E M O R Y   H O G S       
#
###############################################################################
&MAIL_MEMORY_HOGS #300 = 
#
# PURPOSE:
#
#   This Wizard-only command may be used to show all mailboxes that 
#   have greater than <number> messages stored.
#
# Command Format:
#
#   +mail status > <number>
#
# Registers Used:
#
#   0 - user's format option
#

  $+mail status >*: 

    @swi/first hasflag(%#, wizard) = 1,
    {
      @pemit %# = 

        [setq(0, u(get_format_option, get(%#/mail_config_options)))]

        [switch(%q0, standard, 
          {[u(equal_line)]
          %r[space(8)]Summary status of mailboxes with greater than [trim(%0)] 
          messages%r%r}
        )]

        Mailbox%b%bOwner[space(12)]Writing? %b Filters%b 
          Aliases%b Folders%b Sent%b Received

        [switch(%q0, standard, {%r[u(dash_line)]})]; 

        @tr me/continue_memory_hogs = 
            %#, 1, %0, %q0, get(%vm/mailboxes_num_of_attributes)

    }, 

    {
      @pemit %# = Permission denied.
    }

-
&CONTINUE_MEMORY_HOGS #4167 = 
#
# PURPOSE:
#
#   If the current MAILBOXES_%1 is empty:
#
#     If there are no more MAILBOXES_* to try, terminate display.
#
#     Otherwise, call this function recursively to process the next list
#     of mailbox dbrefs.
#
#   Otherwise, MAILBOXES_%1 is NOT empty:
#
#     Call SHOW_ONE_MAILBOX to begin processing the list of mailbox dbrefs.
#
#   (This is a helper routine for the +mail status > <number> command)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - index of which list of mailbox dbrefs to try next
#   %2 - threshold
#   %3 - u(get_format_option, %0)
#   %4 - get(%vm/mailboxes_num_of_attributes)
#
# Registers Used:
#
#   0 - list of mailboxes for the current mailboxes_* being worked on that
#       match the test criteria (letters > <number>)
#

    @swi/first [strlen(get(%vm/mailboxes_%1))]+[gt(%4, %1)] = 

    0+0,
    {
      @pemit %0 = switch(%3, standard, u(equal_line), )
    },

    0+*, 
    {
      @tr me/continue_memory_hogs = %0, add(1, %1), %2, %3, %4
    },

    {

      @tr me/show_one_mailbox =

          [setq(0, u(evaluate_next_list, %1, memory_hog_test, %2))]

        %0, 
        %q0, 
        1, 
        words(%q0), 
        continue_memory_hogs, 
        %2, 
        %1,  
        %3, 
        %4
    }

-
&MEMORY_HOG_TEST #4167 = 
#
# PURPOSE:
#
#   Given a mailbox dbref, return a boolean indicating if the mailbox
#   has greater than <number> letters stored.
#
#   (This is a helper routine for the +mail status > <number> command)
#  
#
# INPUT
#
#   %0 - mailbox dbref 
#   %1 - <number>
#

  gt(words(u(get_all_in_lists, %0)), %1)

-
###############################################################################
#
#                   C H E C K   F O R   M A I L B O X E S   
#         with less than the admin specified number of messages
#
###############################################################################
&MAIL_STATUS_LESS_THAN #300 = 
#
# PURPOSE:
#
#   This Wizard-only command may be used to show all mailboxes that
#   have less than than <number> messages stored.
#
# Command Format:
#
#   +mail status < <number>
#
# Registers Used:
#
#   0 - user's format option
#

  $+mail status <*: 

    @swi/first hasflag(%#, wizard) = 1,
    {
      @pemit %# = 

          [setq(0, u(get_format_option, get(%#/mail_config_options)))]

        [switch(%q0, standard, 
          {[u(equal_line)]
          %r[space(8)]Summary status of mailboxes with less than [trim(%0)] 
          messages%r%r}
        )]

        Mailbox%b%bOwner[space(12)]Writing? %b Filters%b 
          Aliases%b Folders%b Sent%b Received

        [switch(%q0, standard, {%r[u(dash_line)]})]; 

        @tr me/continue_less_than = 
            %#, 1, %0, %q0, get(%vm/mailboxes_num_of_attributes)

    }, 

    {
      @pemit %# = Permission denied.
    }

-
&CONTINUE_LESS_THAN #4167 = 
#
# PURPOSE:
#
#   If the current MAILBOXES_%1 is empty:
#
#     If there are no more MAILBOXES_* to try, terminate display.
#
#     Otherwise, call this function recursively to process the next list
#     of mailbox dbrefs.
#
#   Otherwise, MAILBOXES_%1 is NOT empty:
#
#     Call SHOW_ONE_MAILBOX to begin processing the list of mailbox dbrefs.
#
#   (This is a helper routine for the +mail status < <number> command)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - index of which list of mailbox dbrefs to try next
#   %2 - threshold
#   %3 - u(get_format_option, %0)
#   %4 - get(%vm/mailboxes_num_of_attributes)
#
# Registers Used:
#
#   0 - list of mailboxes for the current mailboxes_* being worked on that
#       match the test criteria (letters > <number>)
#

    @swi/first [strlen(get(%vm/mailboxes_%1))]+[gt(%4, %1)] = 

    0+0, 
    {
      @pemit %0 = switch(%3, standard, u(equal_line), )
    },

    0+*, 
    {
      @tr me/continue_less_than = %0, add(1, %1), %2, %3, %4
    },

    {
      @tr me/show_one_mailbox =

          [setq(0, u(evaluate_next_list, %1, letters_less_than_test, %2))]

        %0,
        %q0, 
        1,
        words(%q0),
        continue_less_than,
        %2, 
        %1, 
        %3, 
        %4
    }

-
&LETTERS_LESS_THAN_TEST #4167 = 
#
# PURPOSE:
#
#   Given a mailbox dbref, return a boolean indicating if the mailbox
#   has less than <number> letters stored.
#
#   (This is a helper routine for the +mail status < <number> command)
#
# INPUT
#
#   %0 - mailbox dbref
#   %1 - <number>
#

  lt(words(u(get_all_in_lists, %0)), %1)

-
###############################################################################
#
#                   C H E C K   F O R   M A I L B O X E S   
#                           with bad semaphores
#
###############################################################################
&MAIL_STATUS_BAD_SEM #300 =
#
# PURPOSE:
#
#   This Wizard-only command may be used to show all mailboxes that
#   have semaphore that are not -1.
#
# Command Format:
#
#   +mail status bad sem[aphore]
#
# Registers Used:
#
#   0 - user's format option
#

  $+mail status bad sem*:

    @swi/first hasflag(%#, wizard) = 1,
    {
      @pemit %# =

          [setq(0, u(get_format_option, get(%#/mail_config_options)))]

        [switch(%q0, standard, 
          {[u(equal_line)]
          %r[space(8)]Summary status of mailboxes with semaphores that 
          are off%r%r}
        )]

        Mailbox%b%bOwner[space(12)]Writing? %b Filters%b 
          Aliases%b Folders%b Sent%b Received

        [switch(%q0, standard, {%r[u(dash_line)]})];

        @tr me/continue_semaphore_off = 
          %#, 1, %q0, get(%vm/mailboxes_num_of_attributes)

    }, 

    {
      @pemit %# = Permission denied.
    }

-
&CONTINUE_SEMAPHORE_OFF #4167 =
#
# PURPOSE:
#
#   If the current MAILBOXES_%1 is empty:
#
#     If there are no more MAILBOXES_* to try, terminate display.
#
#     Otherwise, call this function recursively to process the next list
#     of mailbox dbrefs.
#
#   Otherwise, MAILBOXES_%1 is NOT empty:
#
#     Call SHOW_ONE_MAILBOX to begin processing the list of mailbox dbrefs.
#
#   (This is a helper routine for the +mail status bad sem command)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - index of which list of mailbox dbrefs to try next
#   %2 - u(get_format_option, %0)
#   %3 - get(%vm/mailboxes_num_of_attributes)
#
# Registers Used:
#
#   0 - list of mailboxes for the current mailboxes_* being worked on that
#       match the test criteria (bad semaphore)
#

    @swi/first [strlen(get(%vm/mailboxes_%1))]+[gt(%3, %1)] = 

    0+0, 
    {
      @pemit %0 = switch(%2, standard, u(equal_line), )
    },

    0+*, 
    {
      @tr me/continue_semaphore_off = %0, add(1, %1), %2, %3
    },

    {

      @tr me/show_one_mailbox =

          [setq(0, u(evaluate_next_list, %1, semaphore_off_test))]

        %0, 
        %q0, 
        1, 
        words(%q0), 
        continue_semaphore_off, 
        0, 
        %1,
        %2,
        %3
    }

-
&SEMAPHORE_OFF_TEST #4167 = 
#
# PURPOSE:
#
#   Given a mailbox dbref, return a boolean indicating if the mailbox
#   has a bad semaphore (not -1).
#
#   (This is a helper routine for the +mail status bad semaphore command)
#
# INPUT
#
#   %0 - mailbox dbref
#

  switch(get(%0/semaphore), -1, 0, 1)

-
&SANITY_CHECK #300 = 
#
# This is mainly for my use, to help in shakedown of this release.
#

  $+sanity check: 

    @swi/first hasflag(%#, wizard) = 1,
    {
      &last_sanity_checked me = time(); 
      @tr me/continue_sanity_check =
        %#, 1, get(%vm/mailboxes_num_of_attributes)
    },

    {
      @pemit %# = Permission denied.
    }

-
&CONTINUE_SANITY_CHECK #4167 = 
#
#   %0 - dbref of invoker
#   %1 - index of which list of mailbox dbrefs to try next
#   %2 - get(%vm/mailboxes_num_of_attributes)
#

    @swi/first [strlen(get(%vm/mailboxes_%1))]+[gt(%2, %1)] =

    0+0,
    {
      @pemit %0 = Sanity check complete.
    },

    0+*,
    {
      @tr me/continue_sanity_check = %0, add(1, %1), %2
    },

    {
      @tr #7/sanity_check_one_mailbox =
        first(get(%vm/mailboxes_%1)), 
        %0, 
        %1,
        %2, 
        get(%vm/mailboxes_%1), 
        words(get(%vm/mailboxes_%1)), 
        1
    }

-
&SANITY_CHECK_ONE_MAILBOX #7 = 

#
# %0 - mailbox dbref
# %1 - invoker dbref
# %2 - which mailboxes_* is being currently worked on
# %3 - get(%vm/mailboxes_num_of_attributes)
# %4 - mailboxes_*
# %5 - words(mailboxes_*)
# %6 - which mailbox in mailboxes_* is currently being worked on
#

   @pemit %1 = Sanity checking [name(get(%0/owner_dbref))]'s mailbox.; 

   @dolist u(#300/get_all_in_lists, %0) = 
   {
     @swi/first 
 
       [setq(0, get(%0/in-##-location))]

     1 = 

     and(
       eq(member(get(first(%q0)/out-list), rest(%q0)), 0),
       not(strmatch(rest(%q0), a*))
     ), 
     {
       @pemit %1 = Error detected in mailbox %0.%b 
         Internal mail number ## is not present in source mailbox.
     }, 

     and(
       eq(member(get(first(%q0)/out-[rest(%q0)]-held), 
         get(%0/owner_dbref)), 0), 
       not(strmatch(rest(%q0), a*))
     ), 
     {
       @pemit %1 = Error detected in mailbox %0.%b 
         Internal mail number ## is not in the 'held' list in source mailbox.
     }, 

     and(
       or(
         eq(words(get(%0/in-##-time_read)), 0), 
         eq(words(get(%0/in-##-location)), 0)
       ), 
       strmatch(rest(%q0), a*)
     ), 
     {
       @pemit %1 = Error detected in mailbox %0.%b 
         Internal mail number ## for 'old' mail does not have matching in-* 
         attributes.
     }, 

     and(
       eq(words(get(%0/out-a##-time_sent)), 0), 
       strmatch(rest(%q0), a*)
     ), 
     {
       @pemit %1 = Error detected in mailbox %0.%b 
         Internal mail number ## for 'old' mail does not have matching out-a* 
         attributes.
     }
   }; 

   @dolist get(%0/out-list) = 
   {
     @tr me/sanity_check_outgoing_mail = %0, %1, ##
   };

   @swi 1 = 1, {@swi 1 = 1, {@swi 1 = 1, 
   {
     @swi %6 = %5,
     {
       @tr #300/continue_sanity_check = %1, add(1, %2), %3
     },
     {
       @tr #7/sanity_check_one_mailbox =
          extract(%4, add(1, %6), 1), 
          %1, 
          %2, 
          %3, 
          %4, 
          %5, 
          add(1, %6)
     }
   }}}

-
&SANITY_CHECK_OUTGOING_MAIL #7 = 

#
# %0 - mailbox dbref
# %1 - invoker dbref
# %2 - internal number of outgoing mail
#

  @dolist 

      [setq(0, get(%0/out-%2-dist))]

  get(%0/out-%2-held) = 
  {
    @swi/first 

      [setq(1, match(%q0, ##:*))]
      [setq(2, extract(%q0, %q1, 1))]
      [setq(3, v(mailbox_[before(%q2, :)]))]
      [setq(4, after(%q2, :))]
      [setq(5, get(%q3/in-%q4-location))]
      [setq(6, u(#300/get_all_in_lists, %q3))]
      [setq(7, name(get(%q3/owner_dbref)))]

    0 = 

    %q1,
    {
       @pemit %1 = Error detected in mailbox %0.%b 
         Outgoing mail number %2 has a 'held' member (##) which isn't in 
         the 'dist' list.
    },

    words(%q7),
    {
       @pemit %1 = Error detected in mailbox %0.%b 
         Outgoing mail number %2 has a 'held' member (##) who is a 
         dested player.%b Fixed.;
       &out-%2-held %0 = squish(remove(get(%0/out-%2-held), ##)) 
    },

    words(%q5),
    {
       @pemit %1 = Error detected in mailbox %0.%b 
         Outgoing mail number %2 does not exist in destination mailbox 
         %q3 \(%q7\).%b Fixed.;
       &out-%2-held %0 = squish(remove(get(%0/out-%2-held), ##)) 
    },

    strmatch(first(%q5), %0),
    {
       @pemit %1 = Error detected in mailbox %0.%b 
         Outgoing mail number %2 'dist' does not match in-%q4-location 
         in mailbox %q3 \(%q7\)%b Fixed.;
       &out-%2-held %0 = squish(remove(get(%0/out-%2-held), ##)) 
    }, 

    strmatch(rest(%q5), %2), 
    {
       @pemit %1 = Error detected in mailbox %0.%b 
         Outgoing mail number %2 'dist' does not match in-%q4-location 
         in mailbox %q3 \(%q7\).%b Fixed.;
       &out-%2-held %0 = squish(remove(get(%0/out-%2-held), ##)) 
    }, 

    member(%q6, %q4), 
    {
       @pemit %1 = Error detected in mailbox %0.%b 
         Outgoing mail number %2 exists in destination mailbox 
         %q3 \(%q7\), but is not in any of its IN lists.
    }
  };

  @swi 1 = 1,
  {
    @swi 2 = 2,
    {
      @swi hasattr(%0, out-%2-held) = 0,
      {
        @wipe %0/out-%2-*;
        &out-list %0 = squish(remove(get(%0/out-list), %2))
      }
    }
  }

-
###############################################################################
#
#                        M A K E   M A I L B O X                               
#
###############################################################################
&WIZ_MAKE_MAILBOX #300 = 
#
# PURPOSE:
#
#   This Wizard-only command may be used to make a mailbox for the
#   specified player (if one does not exist already).
#
# Command Format:
#
#   +make mailbox for <person>
#
# Note:
#
#   Mailboxes are automatically created when needed, therefore, this
#   command should not be needed.
#

  $+make mailbox for *: 

    @swi/first hasflag(%#, wizard) = 1,
    {
      @tr %vm/make_mailbox = %0, %#
    }, 
 
    {
      @pemit %# = Permission denied.
    }

-
###############################################################################
#
#                        D E S T R O Y   M A I L B O X                     
#
###############################################################################
&WIZ_DESTROY_MAILBOX #300=
#
# PURPOSE:
#
#   This Wizard-only command may be used to destroy a mailbox for the
#   specified player.
#
# Command Format:
#
#   +destroy mailbox for <person>   
#            - or - 
#   +destroy mailbox for <player dbref>
#

  $+destroy mailbox for *: 

    @swi/first hasflag(%#, wizard) = 1,
    {
      @tr %vm/destroy_mailbox = %0, %#, 0, +destroy_mailbox
    }, 

    {
      @pemit %# = Permission denied.
    }

-
###############################################################################
#
#                   + M A I L   C O N F I G U R A T I O N             
#
###############################################################################
&MAIL_CONFIGURATION #300=
#
# PURPOSE:
#
#   This Wizard-only command may be used to see how the mail system
#   is configured on the system.
#
#   Information shown:
#
#     destroy when empty (true or false)
#     default delete option (hard or soft)
#     default format option (standard or compact)
#     default timeout option (0-disabled, or number of days)
#     the configured text for:  delivery, pickup, forward and text_added
#       notifications, enter_msg, finish_msg
#     current number of mailboxes
#     number of global mail aliases defined
#     the number of attributes used to hold the list of mailboxes
#
# Command Format:
#
#   +mail configuration
#
# Registers Used:
#
#   0 - user's format option
#   1 - default timeout option
#

  $+mail config*: 

    @swi hasflag(%#, wizard) = 1,
    {
      @pemit %# = 

          [setq(0, u(get_format_option, get(%#/mail_config_options)))]
          [setq(1, get(%vm/default_timeout_option))]

        [switch(%q0, standard, 
          {[u(equal_line)]
          %rCurrent mail configuration:
          %r[u(dash_line)]%r}
        )]

        Defaults:%r%r
        %b%bdestroy:%b%b[ljust(switch(get(%vm/delete_when_empty), 
          0, no, yes), 16)]
        [rjust(\(+set mail option destroy = yes or no\), 50)]

        %r%b%b%b%b%b%bRGA:%b%b
        [ljust(switch(get(%vm/default_rga_option), 0, no, yes), 16)]
        [rjust(\(+set mail default RGA = yes or no\), 50)]

        %r%b%b%bdelete:%b%b[ljust(get(%vm/default_delete_option), 16)]
        [rjust(\(+set mail default delete = hard or soft\), 50)]

        %r%b%b%bformat:%b%b[ljust(get(%vm/default_format_option), 16)]
        [rjust(\(+set mail default format = standard or compact\), 50)]

        %r%b%b%b%b%bsave:%b%b[ljust(get(%vm/default_save_option), 16)]
        [rjust(\(+set mail default save = enabled or disabled\), 50)]

        %rseparator:%b%b[ljust(get(%vm/default_separator_option), 16)]
        [rjust(\(+set mail default separator = space or return\), 50)]

        %r%b%btimeout:%b%b[ljust(
          switch(%q1, 0, <disabled>,
          {[div(%q1, v(seconds_in_day))] days})
        , 16)]
        [rjust(\(+set mail default timeout = <number of days>\), 50)]

        %r%b%b%b%bpurge:%b%b[ljust(get(%vm/default_purge_time), 16)]
        [rjust(\(+set mail default purge = <day> <hour>:<minute>\), 50)]

        %r%rNotifications:  \(set on Parent Mail Object/#4167\)
 
        %r%r%b%bENTER_MSG:
          %b%b[get(#4167/enter_msg)]

        %r%r%b%bFINISH_MSG:
          %b%b[get(#4167/finish_msg)]

        %r%r%b%bDELIVERY_NOTIFICATION:
          %b%b[get(#4167/delivery_notification)]

        %r%r%b%bPICKUP_NOTIFICATION:
          %b%b[get(#4167/pickup_notification)]

        %r%r%b%bFORWARD_NOTIFICATION:
          %b%b[get(#4167/forward_notification)]

        %r%r%b%bTEXT_ADDED_NOTIFICATION:
          %b%b[get(#4167/text_added_notification)]

        %r%rCurrent Status:
        %r%r%b%bThere are [words(get(%vm/global-mail-aliases))] 
        global mail aliases.

        %r%b%bThere are 
        [words(
          iter(
            lnum(get(%vm/mailboxes_num_of_attributes)),
            get(%vm/mailboxes_[add(1, ##)])
          )
        )] mailboxes.

        %r%b%b[switch(get(#7/mailboxes_num_of_attributes), 1, 
          One attribute is, [get(#7/mailboxes_num_of_attributes)] are)] 
          used to hold the list of mailboxes. 

        [switch(%q0, standard, {%r[u(equal_line)]})]
    }

-
&VERIFY_MAIL_CONFIG #300=

  $+verify mail config*:

    @swi hasflag(%#, wizard) = 1,
    {
      &mail_config_options me=this is a test;
      &test_space_compression me = z%b%b%b%b%bz;
      @create Test Object; 
      &new_object me = switch(name(con(me)), Test Object, con(me), #-1);  

      @swi/first 0+0 = 0+0,, 0+*, {@pemit %# = @swi/first is broken! 
        Don't bother trying to run the mailer until it is fixed.}, {}; 

      @pemit %# =
        [switch(
          words(v(mail_config_options)), 0,,%r%rWARNING:%b%b
          have [name(#1)]\(#1\) do a
          @attribute/access mail_config_options=wizard
        )]
        [switch(
          flags(#300), *I*, %r%rWARNING:%b%b
          The [name(#300)] object \(#300\) should not be inherit.
        )]
        [switch(
          [flags(#25)]+[flags(owner(#25))],
          *I*+*W*,, *W*+*W*,, %r%rFATAL:%b%b
          The [name(#25)] object \(#25\)
          should be inherit and owned by a Wizard.
        )]
        [switch(
          parent(me), #4167,, %r%rFATAL:%b%b
          The [name(me)] object \([num(me)]\) should be parented to
            the [name(#4167)] \(#4167\).
        )]
        [switch(
          strlen(u(test_space_compression), 3,,
          {%r%rFATAL:%b%b have [name(#1)]\(#1\) do a @admin
            space_compress=yes})
        )]

        [switch(
          isdbref(v(new_object)), 1,, 0, {FATAL:%b%b
          The Mail System must be allowed to create objects, but a 
          @create failed!}
        )]

        ; 

      @swi 1 = 1, @pemit %# = Verify complete.;

      &test_space_compression me = ;
      @dest v(new_object); 
      &new_object me = ; 
      &mail_config_options me =
    }

-
###############################################################################
#
#          W i z a r d   C o n f i g u r a t i o n   C o m m a n d s
#
###############################################################################

###############################################################################
#
#           + S E T   M A I L   O P T I O N   D E S T R O Y   
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_OPTION_DESTROY #300=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system option
#   for if mailboxes are automatically deleted when empty.
#
# Command Format:
#
#   +set mail option destroy=yes | on | true | t | 1 | no | off | false | f | 0
#

  $+set mail option destroy*=*: 

    @swi/first hasflag(%#, wizard) = 1,
    {

      @swi/first 1 = 

        or(
          strmatch(%1, *yes), 
          strmatch(%1, *on), 
          strmatch(%1, *true), 
          strmatch(%1, *t), 
          strmatch(%1, *1)
        ),
        {
          &delete_when_empty %vm = 1; 
          @pemit %# = Mailboxes will 
             be automatically destroyed when they are empty.
        },

        or(
          strmatch(%1, *no), 
          strmatch(%1, *off), 
          strmatch(%1, *false), 
          strmatch(%1, *f), 
          strmatch(%1, *0)
        ),
        {
          &delete_when_empty %vm = 0; 
          @pemit %# = Mailboxes will 
            not be automatically destroyed when they are empty.
        }, 

        {
          @pemit %# = The value for this option must be specified as a 
            boolean. For example: %bon, off, yes, no, true, false are all 
            acceptable values.
        } 
    }, 

    {
      @pemit %# = Permission denied.
    }

-
&SET_MAIL_OPTION_RGA #300=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system option
#   for if global mail alias creation is restricted to wizards or not.
#
#   (FYI:  RGA stands for Restrict Global Aliases)
#
# Command Format:
#
#   +set mail option destroy=yes | on | true | t | 1 | no | off | false | f | 0
#

  $+set mail option RGA*=*:

    @swi/first hasflag(%#, wizard) = 1,
    {

      @swi/first 1 =

        or(
          strmatch(%1, *yes),
          strmatch(%1, *on),
          strmatch(%1, *true),
          strmatch(%1, *t),
          strmatch(%1, *1)
        ),
        {
          &default_rga_option #7 = 1;
          @pemit %# = Adding global mail aliases is now restricted to wizards.
        },

        or(
          strmatch(%1, *no),
          strmatch(%1, *off),
          strmatch(%1, *false),
          strmatch(%1, *f),
          strmatch(%1, *0)
        ),
        {
          &default_rga_option #7 = 0;
          @pemit %# = Adding global mail aliases is no longer restricted.
        },

        {
          @pemit %# = The value for this option must be specified as a
            boolean. For example: %bon, off, yes, no, true, false are all
            acceptable values.
        }
    },

    {
      @pemit %# = Permission denied.
    }

-
&SET_MAIL_OPTION_BLANK #300=

  $+set mail option: 

    @swi/first hasflag(%#, wizard) = 1,
    {
      @pemit %# = You must specify which option you wish to set and the 
      desired value. The current options are:

      %r%r%b%bdelete=hard | soft
      %r%r%b%bdestroy=on | off
      %r%r%b%bformat=compact | standard
      %r%r%b%bseparator=space | return
      %r%r%b%binbox=<folder name>
      %r%r%b%bvacation=<text>
      %r%r%b%breject=<text>
      %r%r%b%bfilter reject=<text>
      %r%r%b%bautoforward=<list of people and/or mail aliases>
      %r%r%b%btimeout=<number of days> for <player>
      %r%r%b%bRGA=yes | no  (RGA stands for Restrict Global Aliases)
    },
    {
      @pemit %# = You must specify which option you wish to set and the 
      desired value. The current options are:

      %r%r%b%bdelete=hard | soft
      %r%r%b%bformat=compact | standard
      %r%r%b%bseparator=space | return
      %r%r%b%binbox=<folder name>
      %r%r%b%bvacation=<text>
      %r%r%b%breject=<text>
      %r%r%b%bfilter reject=<text>
      %r%r%b%bautoforward=<list of people and/or mail aliases>
    }

-
###############################################################################
#
#           + S E T   M A I L   O P T I O N   T I M E O U T         
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_OPTION_TIMEOUT #25=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the timeout option for
#   a specific player.  This value will override the mail system
#   default timeout value.
#
# Command Format:
#
#   +set mail option timeout = <days> for <person>
#
# Registers Used:
#
#   0 - dbref of <person>'s mailbox
#

  $+set mail option timeout*=* for *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_[num(*%2)]))]

    0 = hasflag(%#, wizard), 
    {
#
# Non-wiz invoked
#

      @pemit %# = Permission denied.
    },

    strmatch(type(*%2), PLAYER),
    {
#
# Name specified is not that for a valid Player.
#

      @pemit %# = [capstr(%2)] is not a player.
    },

    strlen(%q0),
    {
#
# Player does not have a mailbox.
#

      @pemit %# = [name(*%2)] does not currently have a mailbox.
    },

    %1,
    {
#
# Timeout value of '0' specified.  This means that letters will not
# expire for this player.
#

      &message_timeout %q0 = 0; 

      @pemit %# = The message timeout has been set to 0 days 
        (indicating that the timeout option has been turned 
        off for [name(*%2)]).
    },

    lt(%1, 7),
    {
#
# Timeout greater than or equal to 7 days specified, store 
# value in mailbox.
#

      &message_timeout %q0 = mul(%1, v(seconds_in_day));

      @pemit %# = The message timeout value for [name(*%2)] has been set to 
          [add(%1, 0)] days.
    },

    {
#
# Timeout value of less than 7 specified. Value must be greater than or
# equal to 7 days.
#

      @pemit %# = The value specified for the message timeout 
        must be either a '0' (indicating the timeout option 
        has been turned off) or a value greater than or equal to 7 days.
    }

-
###############################################################################
#
#           + S E T   M A I L   D E F A U L T  D E L E T E     
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_DEFAULT_DELETE #25=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system default
#   for the delete option.
#
# Command Format:
#
#   +set mail default delete = hard | soft
#

  $+set mail default delete*=*: 

    @swi/first 1 = 

    eq(hasflag(%#, wizard), 0),
    {
#
# Non-Wiz invoked
#

      @pemit %# = Permission denied.
    },

    strmatch(%1, *s*),
    {
#
# Soft specified
#
      @pemit %# = switch(get(%vm/default_delete_option), 
          hard, The mail system default for 'delete' is now 'soft'., 
          The mail system default for 'delete' is already 'soft'.); 
      &default_delete_option %vm = soft; 
    },

    strmatch(%1, *h*),
    {
#
# Hard specified
#
      @pemit %# = switch(get(%vm/default_delete_option), 
          soft, The mail system default for 'delete' is now 'hard'., 
          The mail system default for 'delete' is already 'hard'.); 
      &default_delete_option %vm = hard; 
    },

    {
#
# Invalid value for delete default specified
#

      @pemit %# = The value specified for the mail system default for 'delete', 
        must be either 'soft' or 'hard'.
    }

-
&SET_MAIL_DEFAULT_MODE #25=
-
###############################################################################
#
#           + S E T   M A I L   D E F A U L T  F O R M A T     
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_DEFAULT_FORMAT #25=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system default
#   for the format option.
#
# Command Format:
#
#   +set mail default format = standard | compact
#

  $+set mail default format*=*: 

    @swi/first 1 = 

    eq(hasflag(%#, wizard), 0),
    {
#
# Non-Wiz invoked
#

      @pemit %# = Permission denied.
    },

    strmatch(%1, *s*),
    {
#
# 'standard' specified
#

      @pemit %# = switch(get(%vm/default_format_option), 
        compact, The mail system default for 'format' is now 'standard'., 
        The mail system default for 'format' is already 'standard'.); 
      &default_format_option %vm = standard
    },

    strmatch(%1, *c*),
    {
#
# 'compact' specified
#

      @pemit %# = switch(get(%vm/default_format_option), 
        standard, The mail system default for 'format' is now 'compact'., 
        The mail system default for 'format' is already 'compact'.); 
      &default_format_option %vm = compact
    },

    {
#
# Invalid value for 'format' default specified
#

      @pemit %# = The value specified for the mail system default for 'format', 
        must be either 'standard' or 'compact'.
    }

-
###############################################################################
#
#           + S E T   M A I L   D E F A U L T   S A V E         
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_DEFAULT_SAVE #25=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system default
#   for the save option (enable or disable the +save command).
#
# Command Format:
#
#   +set mail default save = enabled | disabled
#

  $+set mail default save*=*: 

    @swi/first 

      [setq(0, trim(%1))]

    1 = eq(hasflag(%#, wizard), 0),
    {
#
# Non-Wiz invoked
#

      @pemit %# = Permission denied.
    },

    strmatch(%q0, e*),
    {
#
# 'enabled' specified
#

      @pemit %# = switch(get(%vm/default_save_option), 
        disabled, The mail system default for 'save' is now 'enabled'., 
        The mail system default for 'save' is already 'enabled'.); 
      &default_save_option %vm = enabled
    },

    strmatch(%q0, d*),
    {
#
# 'disabled' specified
#

      @pemit %# = switch(get(%vm/default_save_option), 
        enabled, The mail system default for 'save' is now 'disabled'., 
        The mail system default for 'save' is already 'disabled'.); 
      &default_save_option %vm = disabled
    },

    {
#
# Invalid value for 'save' default specified
#

      @pemit %# = The value specified for the mail system default for 'save', 
        must be either 'enabled' or 'disabled'.
    }

-
###############################################################################
#
#           + S E T   M A I L   D E F A U L T   S E P A R A T O R
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_DEFAULT_SEPARATOR #25=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system default
#   for the separator option (used when appending text during '-<text>' 
#   commands.
#
# Command Format:
#
#   +set mail default separator = space | return
#

  $+set mail default separator*=*: 

    @swi/first 

      [setq(0, trim(%1))]

    1 = eq(hasflag(%#, wizard), 0),
    {
#
# Non-Wiz invoked
#

      @pemit %# = Permission denied.
    },

    strmatch(%q0, s*),
    {
#
# 'space' specified
#

      @pemit %# = switch(get(%vm/default_separator_option), 
        return, The mail system default for 'separator' is now 'space'., 
        The mail system default for 'separator' is already 'space'.); 
      &default_separator_option %vm = space
    },

    strmatch(%q0, r*),
    {
#
# 'return' specified
#

      @pemit %# = switch(get(%vm/default_separator_option), 
        space, The mail system default for 'separator' is now 'return'., 
        The mail system default for 'separator' is already 'return'.); 
      &default_separator_option %vm = return
    },

    {
#
# Invalid value for 'separator' default specified
#

      @pemit %# = The value specified for the mail system default 
        for 'separator', must be either 'space' or 'return'.
    }

-
###############################################################################
#
#           + S E T   M A I L   D E F A U L T   T I M E O U T
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_DEFAULT_TIMEOUT #25=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system default
#   for the timeout option.
#
# Command Format:
#
#   +set mail default timeout = days
#
#
# If zero is specified, then no the timeout code is disabled. 
# Otherwise, must be 7 or greater.  'timeout' is specified in 
# number of days and stored in number of seconds.
#

  $+set mail default timeout*=*:

    @swi/first 0 = 

    hasflag(%#, wizard), 
    {
#
# Non-wiz invoked
#

      @pemit %# = Permission denied.
    },

    %1,
    {
#
# Timeout value of '0' specified.  This means that letters will not
# expire.
#

      &default_timeout_option %vm = 0;

      @pemit %# = The mail system default for 'timeout' has been set to 0 
        days (indicating that the timeout option has been turned off).
    },

    lt(%1, 7), 
    {
#
# Timeout greater than or equal to 7 days specified, store mail system-wide
# default value.
#

      &default_timeout_option %vm = mul(%1, v(seconds_in_day));

      @pemit %# = 
        The mail system default for 'timeout' is now [add(%1, 0)] days 
        and will run on [get(%vm/default_purge_time)].
    },

    {
#
# Timeout value of less than 7 specified. Value must be greater than or
# equal to 7 days.
#

      @pemit %# = The value specified for the mail system default for 
        'timeout', must be either a '0' (indicating the timeout option 
        has been turned off) or a value greater than or equal to 7 days.
    }

-
###############################################################################
#
#           + S E T   M A I L   D E F A U L T   P U R G E      
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_DEFAULT_PURGE #25=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system default
#   for when the mail/mailbox purge code should run.
#
# Command Format:
#
#   +set mail default purge = <day of week> <hour>:<minute>
#
#   Example:  +set mail default purge = Wednesday 04:15
#
# Registers used:
#
#   0 - hour
#   1 - minute
#

  $+set mail default purge*=* *:

    @swi/first 0 = 

    hasflag(%#, wizard), 
    {
#
# Non-wiz invoked
#

      @pemit %# = Permission denied.
    },

    match(Monday Tuesday Wednesday Thursday Friday Saturday Sunday 
      Mon Tue Tues Wed Thu Thur Thurs Fri Sat Sun, %1),
    {
      @pemit %# = Please specify day of week.  (example:%b Monday)
    },

    strmatch(%2, *:*),
    {
      @pemit %# = Please specify the time in the format of <hour>:<minute>.
    },

    not(strmatch(%2, *:*:*)),
    {
      @pemit %# = Please specify the time in the format of <hour>:<minute>.
    },

      [setq(0, before(%2, :))]

    not(or(lt(%q0, 0), gt(%q0, 24))), 
    {
      @pemit %# = Hour must be between 0 and 24.
    },

      [setq(1, after(%2, :))]

    not(or(lt(%q1, 0), gt(%q1, 59))), 
    {
      @pemit %# = Minute must be between 0 and 59.
    },

    {
      &default_purge_time %vm =    
        %1 
        [mid(00, 0, sub(2, strlen(%q0)))]%q0:
        [mid(00, 0, sub(2, strlen(%q1)))]%q1; 

      @pemit %# = 
        The mail system letter and mailbox purge code 
          will run on [get(%vm/default_purge_time)].
    }

-
###############################################################################
#
#            U s e r   C o n f i g u r a t i o n   C o m m a n d s
#
###############################################################################

###############################################################################
#
#           + S E T   M A I L   O P T I O N   D E L E T E     
#
###############################################################################
&SET_MAIL_OPTION_DELETE #25=
#
# PURPOSE:
#
#   This command may be used to set your delete option.  This value
#   will override the mail system default value.  
#
# Command Format:
#
#   +set mail option delete = hard | soft 
#
# Registers Used:
#
#   0 - user's MAIL_CONFIG_OPTIONS attribute
#

  $+set mail option delete*=*: 

    @swi/first 

      [setq(0, get(%#/mail_config_options))]

    trim(%1) = 

    s*,
    {
      @pemit %# = switch(member(%q0, soft), 
        0, Your 'delete' mail option is now set to 'soft'., 
        Your 'delete' mail option is already set to 'soft'.); 
      &mail_config_options %# = setunion(squish(remove(%q0, hard) soft), )
    },

    h*,
    {
      @pemit %# = switch(member(%q0, hard), 
        0, Your 'delete' mail option is now set to 'hard'., 
        Your 'delete' mail option is already set to 'hard'.); 
      &mail_config_options %# = setunion(squish(remove(%q0, soft) hard), )
    },

    {
      @pemit %# = The value specified for the mail option 'delete', 
        must be either 'soft' or 'hard'.
    }

-
&SET_MAIL_OPTION_MODE #25=
-
###############################################################################
#
#           + S E T   M A I L   O P T I O N   A U T O F O R W A R D
#
###############################################################################
&SET_MAIL_OPTION_AUTOFORWARD #25 = 
#
# PURPOSE:
#
#   This command may be used to set an automatic autoforward for mail
#   destined for your mailbox.
#
# Command Format:
#
#   +set mail option autoforward = <list of player names and/or mail aliases>
#
# Registers Used:
#
#   0 - dbref of mailbox
#   1 - dbref of who to autoforward to
#   2 - global mail aliases
#   3 - personal mail aliases
#

  $+set mail option autoforward*=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(2, get(%vm/global-mail-aliases))]
      [setq(3, get(%q0/alias-list))]

    1 = 

    and(eq(strlen(%q0), 0), eq(words(%1), 0)), 
    {
#
# User does not have a mailbox and did not specify an autoforward value.
#

      @pemit %# = Mail will not be autoforwarded.
    },

    eq(words(%1), 0), 
    {
#
# User did not specify an autoforward value and has a mailbox.  Clear
# the autoforward for that mailbox.
#

      &autoforward %q0 = ; 

      @pemit %# = Mail will not be autoforwarded.
    },

    eq(strlen(%q0), 0), 
    {
#
# User has no mailbox and specified a player that mail should be 
# autoforwarded to.  Create a mailbox.
#

      @swi/first 
    
        [setq(1,
          [ulocal(#300/identify_to_list, {%1}, %vm)] 
          [u(#300/get_aliases, {%1}, #0, %q2, )]
        )]

      %q1 = *ABORT*, 
      {
#
# Error detected in input parameter.
#
        @pemit %# = secure(after(before(%q1, ENDABORT), ABORT));
        @no %q0
      },

      {
        @create %N's Mailbox; 
        @set [setq(0, con(me))]%q0 = quiet; 
        @drain %q0; 
        &debug_mail %q0 = +set mail option autoforward%0=%1; 
        @chown %q0 = owner(%vm); 
        @set %q0 = !halt; 
        @tel %q0 = %vm; 
        &mailbox_%# %vm = %q0; 
        @tr %vm/add_mailbox = %q0; 
        &owner_dbref %q0 = %#; 
        @startup %q0 = {@drain me; @no me}; 
        @set %q0 = safe; 
        &mail-in-progress %q0 = false; 
        &current_folder %q0 = ulocal(#300/get_inbox, %#); 
        &folder-list %q0 = get(%q0/current_folder); 
        &autoforward %q0 = %q1; 

        @pemit %# = All mail destined for this mailbox will now 
          be autoforwarded to [u(#300/pretty_dist, 
          u(#300/get_aliases, %q1, 
          %q0, %q2, ), %q0, , %q2, 
          u(#300/snag_dbrefs, %q1))].; 

        @no %q0
      }
    },

    {
#
# User has a mailbox and specified a value that mail should be 
# autoforwarded to.  Save value in mailbox.
#
      @swi/first 

        [setq(1,
#
# Convert list of names specified by the user into dbrefs
#
          [ulocal(#300/identify_to_list, {%1}, %q0)] 
          [u(#300/get_aliases, {%1}, %q0, %q2, %q3)]
        )]

      %q1 = *ABORT*, 
      {
#
# Error detected in input parameter.
#
        @pemit %# = secure(after(before(%q1, ENDABORT), ABORT));
        @no %q0
      },

      {
        &autoforward %q0 = %q1; 

        @pemit %# = All mail destined for this mailbox will now 
          be autoforwarded to [u(#300/pretty_dist, 
          u(#300/get_aliases, %q1, 
          %q0, %q2, %q3), %q0, %q3, %q2, 
          u(#300/snag_dbrefs, %q1))].
      }
    }

-
###############################################################################
#
#           + S E T   M A I L   O P T I O N   F O R M A T     
#
###############################################################################
&SET_MAIL_OPTION_FORMAT #25=
#
# PURPOSE:
#
#   This command may be used to set your format option.  This value
#   will override the mail system default value.
#
# Command Format:
#
#   +set mail option format = standard | compact
#
# Registers Used:
#
#   0 - user's MAIL_CONFIG_OPTIONS attribute
#

  $+set mail option format*=*: 

    @swi/first 

      [setq(0, get(%#/mail_config_options))]

    trim(%1) = 

    s*,
    {
      @pemit %# = switch(member(%q0, standard), 
        0, Your 'format' mail option is now set to 'standard'., 
        Your 'standard' mail option is already set to 'standard'.); 
      &mail_config_options %# = 
        setunion(squish(remove(%q0, compact) standard), )
    },

    c*,
    {
      @pemit %# = switch(member(%q0, compact), 
        0, Your 'format' mail option is now set to 'compact'., 
        Your 'standard' mail option is already set to 'compact'.); 
      &mail_config_options %# = 
        setunion(squish(remove(%q0, standard) compact), )
    },

    {
      @pemit %# = The value specified for the mail option 'format', 
        must be either 'standard' or 'compact'.
    }

-
###############################################################################
#
#           + S E T   M A I L   O P T I O N   S E P A R A T O R
#
###############################################################################
&SET_MAIL_OPTION_SEPARATOR #25=
#
# PURPOSE:
#
#   This command may be used to set your separator option.  This value
#   will override the mail system default value.
#
# Command Format:
#
#   +set mail option separator = space | return
#
# Registers Used:
#
#   0 - user's MAIL_CONFIG_OPTIONS attribute
#

  $+set mail option separator*=*: 

    @swi/first 

      [setq(0, get(%#/mail_config_options))]

    trim(%1) = 

    s*,
    {
      @pemit %# = switch(member(%q0, space), 
        0, Your 'separator' mail option is now set to 'space'., 
        Your 'separator' mail option is already set to 'space'.); 
      &mail_config_options %# = 
        setunion(squish(remove(%q0, return) space), )
    },

    r*,
    {
      @pemit %# = switch(member(%q0, return), 
        0, Your 'separator' mail option is now set to 'return'., 
        Your 'separator' mail option is already set to 'return'.); 
      &mail_config_options %# = 
        setunion(squish(remove(%q0, space) return), )
    },

    {
      @pemit %# = The value specified for the mail option 'separator', 
        must be either 'space' or 'return'.
    }

-
###############################################################################
#
#               +S E T   M A I L   O P T I O N   I N B O X
#
###############################################################################
&SET_MAIL_OPTION_INBOX #25=
#
# PURPOSE:
#
#   This command may be used to specify the name of the folder that 
#   incoming mail should be stored in.
#
# Command Format:
#
#   +set mail option inbox = <folder name>
#
#   The folder name may be multiple words, but is limited to 16 characters
#   and should not contain any characters (besides blanks) which are not
#   allowed in attribute names (i.e., no '`!*()=\[\]{}\%|,<>/?:; " well,
#   you get the idea).
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - folder name, with blanks converted to $
#   2 - list of folders
#

  $+set mail option inbox*=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(1, edit(lcstr(trim(%1)), %b, $))]

    1 = strmatch(escape(%1), *[*),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(#300/nofunc)
    },

    not(strmatch(type(%#), PLAYER)),
    {
#
# User is not a player.
#

      @pemit %# = u(#300/not_player)
    },

    eq(words(%1), 0),
    {
#
# Nothing was specified as the name of the folder.
#

      @pemit %# = You must specify a name for the folder to be the 
        designated inbox.
    },

    gt(strlen([setq(2, [setq(3, %1)]
      filter(#300/check_for_bad_chars, 
      get(#300/bad_chars)))]%q2), 0),
    {
#
# Invalid character detected in folder name.
#

      @pemit %# = Invalid character(s) %q2 detected in folder name.
    },

    gt(strlen(%1), 16),
    {
#
# Folder name too long.
#

      @pemit %# = Folder name specified is too long (maximum of 
            16 characters).
    },

    eq(strlen(%q0), 0),
    {
#
# User has no mailbox.  Simply store inbox value in MAIL_CONFIG_OPTIONS.
#

      &MAIL_CONFIG_OPTIONS %# = 
        [before(get(%#/mail_config_options), INBOX:)] 
        [after(get(%#/mail_config_options), :INBOXEND)] 
        INBOX:%q1:INBOXEND; 
      @pemit %# = '[secure(%q1)]' is now the designated inbox
        [switch(%q1, null, {WARNING:%b This will result in all 
        of your incoming mail being automatically discarded.},.)]
    },

    {
#
# User HAS a mailbox.   Store inbox value in MAIL_CONFIG_OPTIONS,
# and make sure inbox is in list of folders.
#

      &MAIL_CONFIG_OPTIONS %# = 
        [before(get(%#/mail_config_options), INBOX:)] 
        [after(get(%#/mail_config_options), :INBOXEND)] 
        INBOX:%q1:INBOXEND; 
      &folder-list %q0 = setunion([get(%q0/folder-list)] %q1, ); 
      @pemit %# = '[secure(%q1)]' is now the designated inbox.
        [switch(%q1, null, {WARNING:%b This will result in all 
        of your incoming mail being automatically discarded.},.)]
    }

-
###############################################################################
#
#           + S E T   M A I L   O P T I O N   V A C A T I O N   
#
###############################################################################
&SET_MAIL_OPTION_VACATION #25=
#
# PURPOSE:
#
#   This command may be used to set your vacation option.  
#   If you have 'vacation' text associated with your mailbox,
#   any +mail received will result in the vacation text being
#   sent back to the originator.
#
# Command Format:
#
#   +set mail option vacation = <text>
#
# Registers Used:
#
#   0 - mailbox dbref
#

  $+set mail option vacation*=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = 

    and(eq(strlen(%q0), 0), eq(words(%1), 0)), 
    {
#
# User does not have a mailbox and did not specify vacation text.
#

      @pemit %# = No vacation text registered.
    },

    eq(words(%1), 0), 
    {
#
# User did not specify vacation text and has a mailbox.  Clear
# the vacation text for that mailbox.
#

      &vacation %q0 = ; 
      @pemit %# = Vacation text cleared.
    },

    eq(strlen(%q0), 0), 
    {
#
# User has no mailbox and specified vacation text.  Create a mailbox.
#

      @create %N's Mailbox; 
      @set [setq(0, con(me))]%q0 = quiet; 
      @drain %q0; 
      &debug_mail %q0 = +set mail option vacation%0=%1; 
      @chown %q0 = owner(%vm); 
      @set %q0 = !halt; 
      @tel %q0 = %vm; 
      &mailbox_%# %vm = %q0; 
      @tr %vm/add_mailbox = %q0; 
      &owner_dbref %q0 = %#; 
      @startup %q0 = {@drain me; @no me}; 
      @set %q0 = safe; 
      &mail-in-progress %q0 = false; 
      &current_folder %q0 = ulocal(#300/get_inbox, %#); 
      &folder-list %q0 = get(%q0/current_folder); 
      &vacation %q0 = u(#300/clean_text, %1); 

      @pemit %# = Vacation text set.; 

      @no %q0
    },

    {
#
# User has a mailbox and specified vacation text.  Save value in mailbox.
#
      &vacation %q0 = u(#300/clean_text, %1); 

      @pemit %# = Vacation text set.; 
    }

-
###############################################################################
#
#           + S E T   M A I L   O P T I O N   R E J E C T 
#
###############################################################################
&SET_MAIL_OPTION_REJECT #25=
#
# PURPOSE:
#
#   This command may be used to set your reject option.  
#   If you have 'reject' text associated with your mailbox,
#   any +mail received will be rejected, and result in the reject 
#   text being sent back to the originator.
#
# Command Format:
#
#   +set mail option reject = <text>
#
# Registers Used:
#
#   0 - mailbox dbref
#

  $+set mail option reject*=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = 

    and(eq(strlen(%q0), 0), eq(words(%1), 0)), 
    {
#
# User does not have a mailbox and did not specify reject text.
#

      @pemit %# = No reject text registered.
    },

    eq(words(%1), 0), 
    {
#
# User did not specify reject text and has a mailbox.  Clear
# the reject text for that mailbox.
#

      &reject_msg %q0 = ; 
      @pemit %# = Reject text cleared.
    },

    eq(strlen(%q0), 0), 
    {
#
# User has no mailbox and specified reject text.  Create a mailbox.
#

      @create %N's Mailbox; 
      @set [setq(0, con(me))]%q0 = quiet; 
      @drain %q0; 
      &debug_mail %q0 = +set mail option reject%0=%1; 
      @chown %q0 = owner(%vm); 
      @set %q0 = !halt; 
      @tel %q0 = %vm; 
      &mailbox_%# %vm = %q0; 
      @tr %vm/add_mailbox = %q0; 
      &owner_dbref %q0 = %#; 
      @startup %q0 = {@drain me; @no me}; 
      @set %q0 = safe; 
      &mail-in-progress %q0 = false; 
      &current_folder %q0 = ulocal(#300/get_inbox, %#); 
      &folder-list %q0 = get(%q0/current_folder); 
      &reject_msg %q0 = u(#300/clean_text, %1); 

      @pemit %# = Reject text set.; 

      @no %q0
    },

    {
#
# User has a mailbox and specified reject text.  Save value in mailbox.
#
      &reject_msg %q0 = u(#300/clean_text, %1); 

      @pemit %# = Reject text set.; 
    }

-
###############################################################################
#
#           + S E T   M A I L   O P T I O N   F I L T E R   R E J E C T
#
###############################################################################
&SET_MAIL_OPTION_FILTER_REJECT #25=
#
#   +set mail option filter reject = <text>
#
# Registers Used:
#
#   0 - mailbox dbref
#

  $+set mail option filter reject*=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = 

    and(eq(strlen(%q0), 0), eq(words(%1), 0)), 
    {
#
# User does not have a mailbox and did not specify filter reject text.
#

      @pemit %# = No filter reject text registered.
    },

    eq(words(%1), 0), 
    {
#
# User did not specify filter reject text and has a mailbox.  Clear
# the filter reject text for that mailbox.
#

      &filter_reject %q0 = ; 
      @pemit %# = Filter reject text cleared.
    },

    eq(strlen(%q0), 0), 
    {
#
# User has no mailbox and specified filter reject text.  Create a mailbox.
#

      @create %N's Mailbox; 
      @set [setq(0, con(me))]%q0 = quiet; 
      @drain %q0; 
      &debug_mail %q0 = +set mail option filter reject%0=%1; 
      @chown %q0 = owner(%vm); 
      @set %q0 = !halt; 
      @tel %q0 = %vm; 
      &mailbox_%# %vm = %q0; 
      @tr %vm/add_mailbox = %q0; 
      &owner_dbref %q0 = %#; 
      @startup %q0 = {@drain me; @no me}; 
      @set %q0 = safe; 
      &mail-in-progress %q0 = false; 
      &current_folder %q0 = ulocal(#300/get_inbox, %#); 
      &folder-list %q0 = get(%q0/current_folder); 
      &filter_reject %q0 = u(#300/clean_text, %1); 

      @pemit %# = Filter reject text set.; 

      @no %q0
    },

    {
#
# User has a mailbox and specified filter reject text.  Save value in mailbox.
#
      &filter_reject %q0 = u(#300/clean_text, %1); 

      @pemit %# = Filter reject text set.; 
    }

-
###############################################################################
#
#                  + S H O W   M A I L   O P T I O N S               
#
###############################################################################
&SHOW_MAIL_OPTIONS #25=
#
# PURPOSE:
#
#   This command may be used to see the mail options for a specific
#   mailbox.  If the user has not specified a specific option, the
#   mail system default is used.
#
#   Information shown:
#
#     delete option (hard or soft)
#     format option (standard or compact)
#     autoforward (none or player name)
#     timeout option (disabled, or number of days)
#     separator option (space or return)
#     list of personal mail aliases defined
#     number of filters defined
#     list of folders defined
#     designated inbox
#     current folder
#     vacation text registered (if any)
#     reject text registered (if any)
#     filter reject text registered (if any)
#
# Command Format:
#
#   +show mail option[s]
#
# Registers Used:
#
#   0 - mail system dbref
#   1 - user's format option
#   2 - user's mailbox
#

 $+show mail option*: 

   @pemit %# = 

       [setq(0, #300)]
       [setq(1, u(%q0/get_format_option, get(%#/mail_config_options)))]
       [setq(2, get(%vm/mailbox_%#))]

     [switch(%q1, standard,
       {[u(%q0/equal_line)]

       %rUser mail configuration options:

       %r[u(%q0/dash_line)]%r}
     )]

     [rjust(Delete:, 15)]%b%b[u(%q0/get_delete_option, %#)]
     %r[rjust(Format:, 15)]%b%b%q1
     %r[rjust(Autoforward:, 15)]%b%b[ulocal(%q0/get_autoforward_option, %#)]
     %r[rjust(Timeout:, 15)]%b%b[ulocal(%q0/get_timeout_option, %#)]
     %r[rjust(Separator:, 15)]%b%b
         [switch(u(%q0/get_separator_option, %#), %b, space, return)]
     %r[rjust(Aliases:, 15)]%b%b[ulocal(%q0/get_personal_aliases, %#)]
     %r[rjust(Filters:, 15)]%b%b[ulocal(%q0/get_filter_count, %#)]
     %r[rjust(Folders:, 15)]%b%b[ulocal(%q0/get_folders, %#)]
     %r[rjust(Inbox:, 15)]%b%b[secure(ulocal(%q0/get_inbox, %#))]
     %r[rjust(Current Folder:, 15)]%b%b
       [switch(
         words(%q2), 
         0, secure(ulocal(%q0/get_inbox, %#)), 
         secure(get(%q2/current_folder))
       )]
     %r[rjust(Vacation:, 15)]%b%b
       [switch(
         words(%q2), 
         0, <none>, 
         switch(get(%q2/vacation),, <none>, u(%q2/vacation))
       )]
     %r[rjust(Reject:, 15)]%b%b
       [switch(
         words(%q2), 
         0, <none>, 
         switch(get(%q2/reject_msg),, <none>, u(%q2/reject_msg))
       )]
     %r[rjust(Filter Reject:, 15)]%b%b
       [switch(
         words(%q2),
         0, <none>,
         switch(get(%q2/filter_reject),, <none>, u(%q2/filter_reject))
       )]

     [switch(%q1, standard, {%r[u(#300/equal_line)]})]
 
-
###############################################################################
#
#                M I S C E L L A N E O U S   C O M M A N D S 
#
###############################################################################

###############################################################################
#
#                        + M A I L   C R E D I T S               
#
###############################################################################
&MAIL_CREDITS #300=
#
# PURPOSE:
#
#   This command may be used to show the credits for the mail system.
#   Basically, it's a thanks to those who have provided assistance
#   or inspiration in the past.
#
# Command Format:
#
#   +mail credits
#

  $+mail credits: 

    @pemit %# = 
      Credits:

      %r%r%b%bTesting help, moral support[space(9)]- Kelson of CrystalMUSH
      %r%b%bIdea for +unread, .signature 
      %r%b%b%b%b+mark, +unmark [space(19)]- Anastasia of TooMUSH
      %r%b%bBug fixes, additional help text[space(5)]- Zalcor of Singlenesia
      %r%b%bSuggested improvements and patience - Ambar      
      %r%b%bSpace option, author:<name>, subject:<text> keywords, +note and 
        performance ideas%b - Amberyl      
   
      %r%r%b%b+mail, -, --, +proof, +toss, +send, +skim, +read, 
        +delete (clear), +edit
      %r%b%bwere written from scratch, without seeing his code, but based on the
      %r%b%buser interface of the mailer written by F'jon of PernMUSH, with
      %r%b%bnumerous enhancements.

      %r%r%b%bThe credit/blame for the rest of the commands, goes to Brandy of 
      %r%b%bCrystalMUSH.

      %r%r%b%bThis +mail code is available via anonymous FTP from 
      %r%b%bftp.visi.com in files:
      %r%b%b/users/cag/brandy_mailer.14
      %r%b%b/users/cag/mail_help

      %r%r%b%b(source code last updated [v(mail_version)])%r

-
###############################################################################
#
#                        + M A I L   C H A N G E S               
#
###############################################################################
&MAIL_CHANGES #300=
#
# PURPOSE:
#
#   This command documents what the changes are since the last release.
#
# Command Format:
#
#   +mail changes
#

  $+mail changes: 

    @pemit %# = 

      Changes since version 13:

%r%rUpdated to use some new 2.2 functions
%rSome bug fixes (see source file for details)
%rNew flag 'forwarded' on +read and +skim
%rNew command '+include <letter number or keyword>' 
%rNew command '+check mail/all' 
%rNew special folder 'null' mail filters, meaning auto-discard
%rNew admin command '+verify mail config'
%rNew admin command '+set mail option RGA = yes | no'

%r%rChanges since version 14:
%r%rJune 25, 1997%b%bfixed problem in +edit text and +edit subject
%r[space(15)](squish where s should be)
%r%rJune 26, 1997%b%bfixed problem in store_letter where message
%r[space(15)]displayed to mail originator was slightly
%r[space(15)]wrong for mailboxes that have a vacation or
%r[space(15)]reject set
%r%rJune 26, 1997%b%bModified keyword match to be smarter
%r%rJune 26, 1997%b%bchanged strlen to words in remove folder command
%r[space(15)]when checking to see if a folder is empty
%r%rJuly 10, 1997%b%bchanged +status of mail sent to <name> now shows
%r[space(15)]the outgoing mail number so you can easily +review it.
%r%rJuly 11, 1997%b%badded optional switches to +review <search criteria>
%r[space(15)]/brief or /skim just shows one line per letter that matches the
%r[space(20)]search criteria.
%r[space(15)]/full or /read shows the entire mail text of each letter that
%r[space(20)]matches the search criteria.
%r%rJuly 22, 1997%b%bFixed bug where global aliases within global
%r[space(15)]aliases were lost upon startup
%r%rAug 6, 1997%b%bFixed bug in expand_letter_range where keyword
%r[space(15)]author:<name> was occasionally matching more than it should
%r%rAug 8, 1997%b%bAdded new commands '+replace subject=<text>' and
%r[space(15)]'+replace subject <letter # or keyword> = <text>

-
###############################################################################
#
#       P E R S O N A L   A N D   G L O B A L   M A I L   A L I A S E S
#       in other words, mail distribution lists
#
###############################################################################

###############################################################################
#
#                  + A D D   P E R S O N A L   A L I A S 
#
###############################################################################
&ADD_PERSONAL_ALIAS #300=
#
# PURPOSE:
#
#   This command may be used to associate an alias with a list of people
#   that you wish to commonly send +mail to.  This way, you can 
#   '+mail my_group=status update' rather than having to always specify 
#   the list of people. The alias must be a single word only, and should 
#   not contain any characters which are not allowed in attribute names 
#   (ie, no '`!*()=[]{}%|,<>/?:; " well, you get the idea).  Personal mail 
#   aliases may only be used by the person who added the alias. If you 
#   wish to add a mail alias that may be used by anyone, the command 
#   '+add global alias <alias>=<list of people>' should be used instead. 
#
# NOTE:  
# 
#   If the player's names contain spaces, each name should be separated by
#   a comma. Example: +add personal alias my_family=Joe Jones, Mary Jones,
#   Baby Jones
#
#   Personal aliases may refer to other personal aliases defined previously 
#   by the user and also any global aliases.
#
# Command Format:
#
#   +add personal alias <alias name> = <list of people or other aliases>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of dbrefs and alias names to match user input
#   2 - dbref of new mailbox created (if needed)
#   3 - new alias name
#   5 - personal mail aliases defined before new one is added
#

  $+add personal alias *=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(5, get(%q0/alias-list))]

    1 = 

    or(strmatch(escape(%0), *[*), strmatch(escape(%1), *[*)),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strmatch(type(*[trim(%0)]), PLAYER),
    {
#
# Alias name specified is the name of a player.  This is not allowed.
#

      @pemit %# = I'm sorry, but the alias you specified is the name of%b
        a player.
    },

    not(strmatch(type(%#), PLAYER)), 
    {
#
# User is not a player.
#

      @pemit %# = u(not_player)
    }, 

    eq(words(%0), 0),
    {
#
# Nothing was specified as the name of the personal alias.
#

      @pemit %# = You must specify a name for the alias.
    },

    gt(words(%0), 1),
    {
#
# The alias name specified was more than one word in length.
#

      @pemit %# = The alias must be a single word.
    },

    gt(strlen(%0), 25), 
    {
      @pemit %# = Sorry, personal alias names are restricted to a maximum 
        of 25 characters.
    },

    gt(strlen([setq(2,
      [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]%q2), 0),
    {
#
# Invalid character detected in alias name.
#

      @pemit %# = Invalid character(s) %q2 detected in alias name.
    },

    eq(words(%1), 0),
    {
#
# User did not specify a list of people to associate with the new 
# personal alias.
#

      @pemit %# = You need to specify a list of people to associate 
        with the alias.
    },

    eq(strlen(%q0), 0),
    {
#
# User has no mailbox.
#

      @swi/first 

        [setq(1, 
          [ulocal(identify_to_list, {%1}, %vm)] 
          [u(get_aliases, {%1}, #0, get(%vm/global-mail-aliases), )]
        )]

      %q1 = *ABORT*,
      {
#
# Error detected in input parameter.
#
        @pemit %# = secure(after(before(%q1, ENDABORT), ABORT))
      },

      {
#
# Create a new mailbox to store the personal alias in to.
#

        @create %N's Mailbox; 
        @set [setq(2, con(me))]%q2 = quiet; 
        @drain %q2; 
        &debug_mail %q2 = +add personal alias %0=%1; 
        @tel %q2 = %vm; 
        &mailbox_%# %vm = %q2; 
        @tr %vm/add_mailbox = %q2; 
        &owner_dbref %q2 = %#; 
        @startup %q2 = {@drain me; @no me}; 
        @set %q2 = safe; 
        &mail-in-progress %q2 = false; 
        &current_folder %q2 = ulocal(get_inbox, %#); 
        &folder-list %q2 = get(%q2/current_folder); 

        &alias-list %q2 = [setq(3, lcstr(trim(%0)))]%q3; 
        &alias-%q3 %q2 = %q1; 

        @pemit %# = '%q3' has been added as a personal mail alias.;

        @no %q2
      }
    },

    {
#
# User HAS a mailbox.
#

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +add personal alias %0=%1; 

        @swi/first 

            [setq(1,
#
# Convert list of names specified by the user into dbrefs
#
              [ulocal(identify_to_list, {%1}, %q0)] 
              [u(get_aliases, 
                {%1}, 
                %q0, 
                get(%vm/global-mail-aliases), 
                %q5
              )]
            )]
            [setq(3, lcstr(trim(%0)))]

        1 = 

        gt(match(%q5, %q3), 0),
        {
#
# Personal alias already exists by that name.
#

          @pemit %# = You already have a personal alias with this name. 
            If you really mean to totally overwrite it, you should do a 
            +remove personal alias %q3, followed by a +add personal alias%b
            %q3=<list of people>.; 
          @no %q0
        },

        strmatch(%q1, *ABORT*),
        {
#
# Error detected in input parameter.
#
          @pemit %# = secure(after(before(%q1, ENDABORT), ABORT)); 
          @no %q0
        },

        {
#
# Life is good.  Notify user.
#

          &alias-list %q0 = %q5 %q3; 
          &alias-%q3 %q0 = %q1; 
          @pemit %# = '%q3' has been added as a personal mail alias.; 
          @no %q0
        }
      }
    }

-
&ADD_PERSONAL_ALIAS_BLANK #300=

  $+add personal alias: 

    @pemit %# = The syntax is +add personal alias <alias>=<list of people>.

&ADD_ALIAS_BLANK #300=

  $+add alias: 

    @pemit %# = There are two varieties of mail distribution lists (aliases): 
      personal and global. Personal aliases may be used only by you. Global 
      aliases may be used by all. The syntax is:%r%r

      +add personal alias <alias>=<list of people> -or-%r
      +add global alias <alias>=<list of people>

-
###############################################################################
#
#                + L I S T   P E R S O N A L   A L I A S E S  
#
###############################################################################
&LIST_PERSONAL_ALIASES #300=
#
# PURPOSE:
#
#   This command may be used to show the names of personal mail aliases 
#   that were previously defined via the '+add personal alias <alias> = 
#   <list of people and/or aliases>' command.
#
# Command Format:
#
#   +list personal aliases
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - personal aliases defined
#   2 - user's format option
#

  $+list personal a*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    strlen(%q0) = 0, 
    {
#
# User does not have a mailbox, and therefore, has no personal mail
# aliases.
#

      @pemit %# = You have no personal mail aliases defined.
    },
    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +list personal aliases; 

        @pemit %# = 

            [setq(1, get(%q0/alias-list))]
            [setq(2, u(get_format_option, get(%#/mail_config_options)))]

          switch(strlen(%q1), 
            0, You have no personal mail aliases defined.,
            {
              [switch(%q2, standard, 
                {[u(equal_line)]
                %rList of [name(%#)]'s personal mail aliases:
                %r[u(dash_line)]%r}
              )]

              [iter(%q1, 
                [lcstr(##)]
                [switch(type(*##), PLAYER, {%b-%b( Warning: there is a player%b
                with this name, therefore using this alias will send to%b
                that player instead%b)%b})]
              )]

              [switch(%q2, standard, {%r[u(equal_line)]})]
            }
          ); 

        @no %q0
      }
    }

-
&LIST_ALIASES_BLANK #300=

  $+list alias*: 

    @pemit %# = There are two varieties of mail distribution lists (aliases): 
      personal and global. Personal aliases may be used only by you. Global 
      aliases may be used by all. The syntax is:%r%r

      +list personal aliases -or-%r
      +list global aliases

-
###############################################################################
#
#                + E X P A N D   P E R S O N A L   A L I A S   
#
###############################################################################
&EXPAND_PERSONAL_ALIAS #300=
#
# PURPOSE:
#
#   This command may be used to show the list of people and/or aliases 
#   on the specified personal distribution list which was previously defined
#   via the +'add personal alias <alias> = <list of people and/or aliases>' 
#   command.  You may only expand lists that you own.
#
# Command Format:
#
#   +expand personal alias <alias name>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of personal mail aliases
#   2 - user's format option
#   3 - list of global mail aliases
#   4 - list of people and/or aliases associated with %0
#

  $+expand personal alias *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = 

    strlen(%q0),
    {
#
# No mailbox for user.
#

      @pemit %# = You do not have a personal mail alias defined with that 
        name.
    },

    eq(strlen([setq(2,
      [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]%q2), 0),
    {
#
# Invalid character detected in alias name.
#

      @pemit %# = Invalid character(s) %q2 detected in alias name.
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +expand personal alias %0; 

        @pemit %# = 

            [setq(1, get(%q0/alias-list))]
            [setq(2, u(get_format_option, get(%#/mail_config_options)))]
            [setq(3, get(%vm/global-mail-aliases))]
            [setq(4, get(%q0/alias-%0))]

          switch(or(eq(strlen(%q1), 0), eq(match(%q1, %0), 0)), 
            1, 
              You do not have a personal mail alias defined with that name.,
            {
              [switch(%q2, standard, 
                {[u(equal_line)]
                %rExpansion of %N's personal mail alias 
                '[lcstr(%0)]':
                [switch(type(*%0), PLAYER, {%rWARNING: there is a player%b
                with this name, therefore using this alias will send to%b
                that player instead%b})]
                %r[u(dash_line)]%r}
              )]

              [u(pretty_dist, 
                u(get_aliases, {%q4}, %q0, %q3, %q1), 
                %q0, 
                %q1, 
                %q3, 
                u(snag_dbrefs, %q4)
              )]

              [switch(%q2, standard, {%r[u(equal_line)]})]
            }
          ); 

        @no %q0
      }
    }

-
&EXPAND_PERSONAL_ALIAS_BLANK #300=

  $+expand personal alias: 

    @pemit %# = The syntax is +expand personal alias <alias>.

-
&EXPAND_ALIAS_BLANK #300=

  $+expand alias: 

    @pemit %# = There are two varieties of mail distribution lists (aliases): 
      personal and global. Personal aliases may be used only by you. Global 
      aliases may be used by all. The syntax is:%r%r

      +expand personal alias <alias> -or-%r
      +expand global alias <alias>

-
###############################################################################
#
#                + R E M O V E   P E R S O N A L   A L I A S   
#
###############################################################################
&REMOVE_PERSONAL_ALIAS #300=
#
# PURPOSE:
#
#   This command may be used to remove a personal distribution list which
#   was previously defined via the +'add personal alias <alias> = 
#   <list of people and/or aliases>' command.  
#
# Command Format:
#
#   +remove personal alias <alias name>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of personal mail aliases
#   2 - alias to remove 
#

  $+remove personal alias *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = 

    or(eq(words(%0), 0), eq(strlen(%q0), 0)),
    {
#
# Personal alias not specified or the user has no mailbox.
#

      @pemit %# = You do not have a personal mail alias defined with that 
        name.
    },

    gt(strlen([setq(2,
      [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]%q2), 0),
    {
#
# Invalid character detected in alias name.
#

      @pemit %# = Invalid character(s) %q2 detected in alias name.
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +remove personal alias %0; 

        @swi/first 

          [setq(1, get(%q0/alias-list))]
          [setq(2, lcstr(%0))]

        or(eq(strlen(%q1), 0), eq(match(%q1, %0), 0)) = 1,
        {
#
# Personal alias specified is not defined in user's mailbox.
#

          @pemit %# = You do not have a personal mail alias defined with that 
            name.; 
          @no %q0
        },
        {
          &alias-list %q0 = squish(remove(%q1, %q2)); 
          &alias-%0 %q0 = ;  

          @pemit %# = '%q2' has been removed from your list 
            of personal mail aliases.; 

          @no %q0; 
        }
      }
    }

-
&REMOVE_PERSONAL_ALIAS_BLANK #300=

  $+remove personal alias: 

    @pemit %# = The syntax is +remove personal alias <alias>.

-
&REMOVE_ALIAS_BLANK #300=

  $+remove alias: 

    @pemit %# = There are two varieties of mail distribution lists (aliases):  
      personal and global. Personal aliases may be used only by you. Global 
      aliases may be used by all. The syntax is:%r%r

      +remove personal alias <alias> -or-%r
      +remove global alias <alias>

-
&EDIT_PERSONAL_ALIAS #300=
#
# PURPOSE:
#
#   This command may be used to edit a personal distribution list which
#   was previously defined via the +'add personal alias <alias> =
#   <list of people and/or aliases>' command.  The standard '^' and '$'
#   may be used for <old text> to prepend and append <next text> respectively.
#
#   Note:  The resultant list of people is checked to verify that all
#   members of the distribution list are valid players or mail aliases.
#
# Command Format:
#
#   +edit personal alias <alias name> = <old text>/<new text>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - alias name
#   2 - old text
#   3 - new text
#   4 - list of dbrefs and aliases associated with alias before edit
#   5 - personal mail aliases defined
#   6 - global mail aliases defined
#   7 - 'prettified' version of personal alias list before edit
#

  $+edit personal alias *=*/*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = 

    strlen(%q0), 
    {

#
# User has no mailbox and therefore no personal aliases.
#

      @pemit %# = You do not have a personal mail alias defined with that 
        name.
    },

    eq(strlen([setq(2,
      [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]%q2), 0),
    {
#
# Invalid character detected in alias name.
#

      @pemit %# = Invalid character(s) %q2 detected in alias name.
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +edit personal alias %0=%1/%2; 

        @swi/first 

          [setq(1, lcstr(trim(%0)))]
          [setq(2, lcstr(trim(%1)))]
          [setq(3, trim(%2))]
          [setq(4, u(purify_alias_list, get(%q0/alias-%q1)))]
          [setq(5, get(%q0/alias-list))]
          [setq(6, get(%vm/global-mail-aliases))]
          [setq(7, lcstr(u(pretty_dist, u(get_aliases, %q4, %q0, %q6, %q5), 
            %q0, %q5, %q6, u(snag_dbrefs, %q4))))]

        1 = eq(strlen(%q1), 0),
        {
#
# Personal alias not specified.
#

          @pemit %# = You must specify a name for the alias you wish to edit.; 
          @no %q0
        },

        gt(words(%q1), 1), 
        {
#
# Multi-word personal alias specified.
#

          @pemit %# = The alias must be a single word.; 
          @no %q0
        },

        eq(match(%q5, %q1), 0), 
        {
#
# You do not have a personal alias by that name defined.
#

          @pemit %# = You do not have a personal mail alias defined with that%b
            name.; 
          @no %q0
        },

        eq(words(%q4), 0),
        {
#
# Found match on personal alias, alias has no members. Set members of
# alias to substitute text.
#

          @tr me/cleanup_edit_mail_palias = %#, %q3, %q0, %q1
        },

        strmatch(%q2, $), 
        {
#
# Found match on personal alias, alias has at least one member. Insert
# substitute text at end.
#

          @tr me/cleanup_edit_mail_palias = 
            %#,
            u(clean_dist, {%q4, %q3}), 
            %q0,
            %q1
        },

        strmatch(%q2, ^), 
        {
#
# Found match on personal alias, alias has at least one member. Insert
# substitute text at beginning.
#

          @tr me/cleanup_edit_mail_palias = 
            %#,
            u(clean_dist, {%q3, %q4}), 
            %q0,
            %q1
        },

        strmatch(%q7, *%q2*), 
        {
#
# Replace <old text> with <new text>
#

          @tr me/cleanup_edit_mail_palias = 
            %#,
            u(clean_dist, edit(%q7, %q2, %q3)), 
            %q0, 
            %q1
        }, 
   
        {
          @pemit %# = Unable to find '%q2' in current value for personal 
          alias '%q1'.%b Please check the exact format by doing a 
          '+expand personal alias %q1'.; 
          @no %q0
        }
      }
    }

-
&CLEANUP_EDIT_MAIL_PALIAS #4167=
#
# PURPOSE:
#
#   This is a helper routine for '+edit personal alias <alias>=<old>/<new>'.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - list of names after edit
#   %2 - dbref of mailbox
#   %3 - name of personal alias
#
# Registers Used:
#
#   1 - list of dbrefs       
#   2 - global mail aliases
#   3 - personal mail aliases
#   4 - list of aliases
#

  @swi/first 

    [setq(1, ulocal(identify_to_list, {%1}, %2))]
    [setq(2, get(%vm/global-mail-aliases))]
    [setq(3, get(%2/alias-list))]
    [setq(4, u(get_aliases, {%1}, %2, %q2, %q3))]

  %q1 = *ABORT*, 
  {
#
# Error detected in input parameter.
#
    @pemit %0 = secure(after(before(%q1, ENDABORT), ABORT)); 
    @no %2
  },
  {
#
# Weed out duplicates.
#

    &alias-%3 %2 = %q1 %q4; 

    @pemit %0 = 

      switch(words(%q1 %q4), 
        0, {No names are associated with the specified alias.}, 
        {Your '%3' personal alias has been updated and is now set to:
        %b [u(pretty_dist, %q4, %2, %q3, %q2, %q1)]}
      ); 

    @no %2
  }

-
###############################################################################
#
#                 + L I S T   G L O B A L   A L I A S E S
#
###############################################################################
-
&LIST_GLOBAL_ALIASES #300=
#
# PURPOSE:
#
#   This command may be used to show the names of global mail aliases
#   that were previously defined via the '+add global alias <alias> =
#   <list of people and/or aliases>' command.  These aliases may be
#   used by anyone while writing +mail.
#
# Command Format:
#
#   +list global aliases
#
# Registers Used:
#
#   0 - list of global mail aliases defined
#   1 - user's format option
#

  $+list global a*: 

    @swi/first 

      [setq(0, get(%vm/global-mail-aliases))]

    strlen(%q0) = 0, 
    {
      @pemit %# = There are no global mail aliases defined.
    },
    {
      @pemit %# = 

          [setq(1, u(get_format_option, get(%#/mail_config_options)))]

        [switch(%q1, standard, 
          {[u(equal_line)]
          %rList of global mail aliases:
          %r[u(dash_line)]%r}
        )]

        [iter(%q0, 
          [lcstr(##)]
          [switch(type(*##), PLAYER, {%b-%b( Warning:%b there is a player%b
          with this name, therefore using this alias will send to%b
          that player instead%b)%b})])]

        [switch(%q1, standard, {%r[u(equal_line)]})]; 
    }

-
###############################################################################
#
#                    + A D D   G L O B A L   A L I A S
#
###############################################################################
&ADD_GLOBAL_ALIAS #300=
#
# PURPOSE:
#
#   This command may be used to associate an alias with a list of people
#   that it is felt many people would wish to send +mail to as a group. 
#   This way, you can '+mail wizards=question' rather than having to 
#   always specify the list of people. The alias must be a single word 
#   only, and should not contain any characters which are not allowed 
#   in attribute names (ie, no '`!*()=[]{}%|,<>/?:; " well, you get the 
#   idea).  Global mail aliases may be used by anyone using the +mail
#   system.  If you wish to add a personal mail alias that is for your
#   use alone, the command '+add personal alias <alias>=<list of people>
#   should be used instead.
#
# NOTE:
#
#   If the player's names contain spaces, each name should be separated by
#   a comma. Example: +add global alias my_family=Joe Jones, Mary Jones,
#   Baby Jones
#
#   Global aliases may refer to other global aliases.
#
# Command Format:
#
#   +add global alias <alias name> = <list of people or other aliases>
#
# Registers Used:
#
#   0 - new alias name
#   1 - list of names and alias names to match user input
#   2 - list of global mail aliases defined
#   3 - list of player dbrefs and aliases associated with new alias
#

  $+add global alias *=*: 

#
# Snag the semaphore on the Master Mailbox.
#

   @wait %vm = 
   {
     &debug_mail %vm = +add global alias %0=%1; 

     @swi/first 

       [setq(0, lcstr(trim(%0)))]
       [setq(1, trim(%1))]
       [setq(2, get(%vm/global-mail-aliases))]

     1 = or(strmatch(escape(%0), *[*), strmatch(escape(%1), *[*)),
     {
#
# Cannot have a '[' as part of an input parameter.
#

       @pemit %# = u(nofunc); 
       @no %vm
     },

     and(get(#7/default_rga_option), not(hasflag(%#, wizard))), 
     {
#
# Creation of global aliases is restricted to wizards.
#
       @pemit %# = I'm sorry, creation of global aliases has been 
         restricted to wizards.; 
       @no %vm
     },

     strmatch(type(*%q0), PLAYER),
     {
#
# Player's names are not allowed to be used as global aliases.
#

       @pemit %# = I'm sorry, the alias you specified is the name of a%b
         player.; 
       @no %vm
     },

     not(strmatch(type(%#), PLAYER)),
     {
       @pemit %# = u(not_player); 
       @no %vm
     },

     eq(strlen(%q0), 0),
     {
#
# Did not specify name for the global alias to add.
#

       @pemit %# = You must specify a name for the global alias.; 
       @no %vm
     },

     gt(strlen(%q0), 14), 
     {
       @pemit %# = Sorry, global alias names are restricted to a maximum 
         of 14 characters.;
       @no %vm
     },

     gt(strlen([setq(4,
       [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]%q4), 0),
     {
#
# Invalid character detected in alias name.
#

       @pemit %# = Invalid character(s) %q4 detected in alias name.; 
       @no %vm
     },

     gt(words(%q0), 1), 
     {
#
# Multi-word value specified for the global alias to add. Aliases must
# be one word only.
#

       @pemit %# = The global alias must be a single word.; 
       @no %vm
     },

     eq(strlen(%q1), 0),
     {
#
# No members specified for the global alias to add.
#

       @pemit %# = You need to specify a list of people to associate%b
         with the global alias.; 
       @no %vm
     },

     gt(match(%q2, %q0), 0),
     {
#
# A global alias already exists with this name.  
#

       @pemit %# = A global already exists with this name.; 
       @no %vm
     },

     {
#
# Attempt to parse the member list (which may include other global aliases)
#

       @swi/first 
       
         [setq(3, 
           [ulocal(identify_to_list, {%q1}, %vm)] 
           [u(get_aliases, 
             {%q1}, 
             %0, 
             %q2, 
           )]
         )]

       %q3 = *ABORT*,
       {
#
# Error detected in member list for alias to add.
#

         @pemit %# = secure(after(before(%q3, ENDABORT), ABORT)); 
         @no %vm
       },

       {
#
# Everything is fine, add the global alias and notify the invoker.
#

         &global-mail-aliases %vm = %q2 %q0; 
         &alias-%q0 %vm = %q3; 
         @pemit %# = '%q0' has been added as a global mail alias.; 
         &alias-%q0-created-by %vm = %# %N on [time()]; 
         @no %vm
       }
     }
   }

-
&ADD_GLOBAL_ALIAS_BLANK #300=

  $+add global alias: 

    @pemit %# = The syntax is +add global alias <alias>=<list of people>.

-
###############################################################################
#
#                + E X P A N D   G L O B A L   A L I A S
#
###############################################################################
&EXPAND_GLOBAL_ALIAS #300=
#
# PURPOSE:
#
#   This command may be used to show the list of people and/or aliases
#   on the specified global distribution list which was previously defined
#   via the +'add global alias <alias> = <list of people and/or aliases>'
#   command.  You may expand any distribution list.
#
# Command Format:
#
#   +expand global alias <alias name>
#
# Registers Used:
#
#   0 - list of global mail aliases
#   1 - user's format option
#   2 - list of people and/or aliases associated with %0
#

  $+expand global alias *: 

    @swi/first 

      [setq(0, get(%vm/global-mail-aliases))]

    1 = 

    gt(strlen([setq(1,
      [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]%q1), 0),
    {
#
# Invalid character detected in alias name.
#

      @pemit %# = Invalid character(s) %q1 detected in alias name.
    },

    or(eq(words(%0), 0), eq(strlen(%q0), 0), eq(match(%q0, %0), 0)),
    {
      @pemit %# = There is no global mail alias defined with that name.
    },

    {
      @pemit %# = 

        [setq(1, u(get_format_option, get(%#/mail_config_options)))]
        [setq(2, get(%vm/alias-%0))]

        [switch(%q1, standard, 
          {[u(equal_line)]
          %rExpansion of global mail alias 
          '[lcstr(%0)]'%r( Last modified by 
          [rest(get(%vm/alias-%0-created-by))] )
          [switch(type(*%0), PLAYER, {%rWARNING: there is a player%b
          with this name, therefore using this alias will send to%b
          that player instead%b)%b})]
          %r[u(dash_line)]%r}
        )]

        [u(pretty_dist, 
          u(get_aliases, {%q2}, %vm, %q0, , ), %vm, , %q0, 
            u(snag_dbrefs, %q2)
        )]

        [switch(%q1, standard, {%r[u(equal_line)]})]; 
    }

-
&EXPAND_GLOBAL_ALIAS_BLANK #300=

  $+expand global alias: 

    @pemit %# = The syntax is +expand global alias <alias>.

-
&EDIT_GLOBAL_ALIAS #300=
#
# PURPOSE:
#
#   This command may be used to edit a global distribution list which
#   was previously defined via the +'add global alias <alias> =
#   <list of people and/or aliases>' command.  The standard '^' and '$'
#   may be used for <old text> to prepend and append <next text> respectively.
#
#   Note:  The resultant list of people is checked to verify that all
#   members of the distribution list are valid players or mail aliases.
#
# Command Format:
#
#   +edit global alias <alias name> = <old text>/<new text>
#
# Registers Used:
#
#   0 - alias name
#   1 - old text
#   2 - new text
#   3 - needed by filter() call
#   4 - list of dbrefs and aliases associated with alias before edit
#   5 - bad characters detected in alias name
#   6 - list of global mail aliases
#   7 - prettified version of %q4
#

  $+edit global alias *=*/*: 

#
# Snag the semaphore
#

    @wait %vm = 
    {
      &debug_mail %vm = +edit global alias %0=%1/%2; 

      @swi/first 

        [setq(0, trim(lcstr(%0)))]
        [setq(1, lcstr(trim(%1)))]
        [setq(2, trim(%2))]
        [setq(4, u(purify_alias_list, get(%vm/alias-%q0)))]
        [setq(6, get(%vm/global-mail-aliases))]
        [setq(7, lcstr(u(pretty_dist, u(get_aliases, %q4, #0, %q6, ), #0, , 
          %q6, u(snag_dbrefs, %q4))))]

      1 = 
      gt(strlen([setq(5,
        [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]%q5), 0),
      {
#
# Invalid character detected in alias name.
#

        @pemit %# = Invalid character(s) %q5 detected in alias name.; 
        @no %vm
      },

      [or(
        eq(strlen(%q0), 0),
        eq(strlen(%q6), 0),
        eq(match(%q6, lcstr(%q0)), 0)
      )],
      {
#
# There is no global mail alias by that name.
#

        @pemit %# = There is no global mail alias defined with that name.; 
        @no %vm
      },

      not(or(
        hasflag(%#, wizard),
        strmatch(
          %#,
          first(get(%vm/alias-%q0-created-by))
        )
      )),
      {
#
# Permission denied.  In order to edit a global alias, you must either
# be the person who last modified (added) the alias, or be a wizard.
#

        @pemit %# = I'm sorry, you may only edit global mail aliases%b
          that you added. If you still desire to have the alias modified,%b
          please contact the person who added the alias, or a wizard.; 
        @no %vm
      },

      eq(words(%q4), 0),
      {
#
# Found match on global alias, alias has no members. Set members of
# alias to substitute text.
#

        @tr me/cleanup_edit_mail_galias = %#, %q2, %q0
      },

      strmatch(%q1, $),
      {
#
# Found match on global alias, alias has at least one member. Insert
# substitute text at end.
#

        @tr me/cleanup_edit_mail_galias = 
          %#, 
          u(clean_dist, {%q4, %q2}), 
          %q0
      },

      strmatch(%q1, ^),
      {
#
# Found match on global alias, alias has at least one member. Insert
# substitute text at beginning.
#

        @tr me/cleanup_edit_mail_galias = 
          %#, 
          u(clean_dist, {%q4, %q2}), 
          %q0
      },

      strmatch(%q7, *%q1*), 
      {
#
# Replace <old text> with <new text>
#

        @tr me/cleanup_edit_mail_galias =
          %#,
          u(clean_dist, edit(%q7, %q1, %q2)), 
          %q0
      },

      {
        @pemit %# = Unable to find '%q1' in current value for global 
          alias '%q0'.%b Please check the exact format by doing a 
          '+expand global alias %q0'.; 
        @no %vm
      }
    }

-
&CLEANUP_EDIT_MAIL_GALIAS #4167=
#
# PURPOSE:
#
#   This is a helper routine for '+edit global alias <alias>=<old>/<new>'.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - list of names after edit
#   %2 - name of global alias
#
# Registers Used:
#
#   1 - dbrefs alone
#   2 - global mail aliases
#   3 - aliases alone
#

  @swi/first 

    [setq(1, ulocal(identify_to_list, {%1}, %vm))]
    [setq(2, get(%vm/global-mail-aliases))]
    [setq(3, u(get_aliases, {%1}, #0, %q2, ))]

  %q1 = *ABORT*, 
  {
#
# Error detected in input parameter.
#
    @pemit %0 = secure(after(before(%q1, ENDABORT), ABORT)); 
    @no %vm
  }, 
  {
    &alias-%2 %vm = %q1 %q3; 
    &alias-%2-created-by %vm = %0 [name(%0)] on [time()]; 

    @pemit %0 = 

      switch(
        words(%q1 %q3), 
        0, {No names are associated with the specified alias.}, 
        {The '%2' global alias has been updated and is now set to:
        %b [u(pretty_dist, %q3, #0, , %q2, %q1)]}
      ); 

    @no %vm
  }

-
&SNAG_DBREFS #4167 = 
#
# Make sure dbref is a PLAYER
#

  iter(%0, switch(##+[type(##)], #*+PLAYER, ##, ))

-
###############################################################################
#
#                + R E M O V E   G L O B A L   A L I A S
#
###############################################################################
&REMOVE_GLOBAL_ALIAS #300=
#
# PURPOSE:
#
#   This command may be used to remove a global distribution list which
#   was previously defined via the +'add global alias <alias> =
#   <list of people and/or aliases>' command.  You may only remove
#   global distribution lists that you added (unless you are a wizard).
#
# Command Format:
#
#   +remove global alias <alias name>
#
# Registers Used:
#
#   0 - list of global mail aliases
#   1 - alias to remove
#

  $+remove global alias *: 

#
# Snag the semaphore
#

    @wait %vm = 
    {
      &debug_mail %vm = +remove global alias %0; 

      @swi/first 1 = 

        [setq(0, get(%vm/global-mail-aliases))]
        [setq(1, lcstr(trim(%0)))]

      gt(strlen([setq(2,
        [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]%q2), 0),
      {
#
# Invalid character detected in alias name.
#

        @pemit %# = Invalid character(s) %q2 detected in alias name.; 
        @no %vm
      },

      or(
        eq(words(%0), 0),
        eq(strlen(%q0), 0),
        eq(match(%q0, %0), 0)
      ),
      {
        @pemit %# = There is no global mail alias defined with that name.; 
        @no %vm
      },

      or(
        hasflag(%#, wizard),
        strmatch(%#, first(get(%vm/alias-%q1-created-by))
        )
      ),
      {
        &global-mail-aliases %vm = squish(remove(%q0, %q1)); 

        &alias-%0 %vm = ; 
        &alias-%q1-created-by %vm = ; 

        @pemit %# = '%q1' has been removed from the list 
          of global mail aliases.; 

        @no %vm
      },

      {
        @pemit %# = I'm sorry, you may only remove global mail aliases%b
          that you added. If you still desire to have the alias removed,%b
          please contact the person who added the alias, or a wizard.; 

        @no %vm
      }
    }

-
&REMOVE_GLOBAL_ALIAS_BLANK #300=

  $+remove global alias: 

    @pemit %# = The syntax is +remove global alias <alias>.

-
###############################################################################
#
#               F O L D E R   R E L A T E D   C O M M A N D S
#
###############################################################################

###############################################################################
#
#                        + L I S T   F O L D E R S
#
###############################################################################
&LIST_FOLDERS #300=
#
# PURPOSE:
#
#   This command may be used to show one line of information per folder 
#   in the user's mailbox.  Information shown includes:  folder name, a 
#   count of how many letters are in the folder, how many are marked for 
#   deletion, how many are marked, how many are 'save'ed, how many
#   are close to being timed out and how many are unread.
#
# Command Format:
#
#   +list folders
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   2 - list of letters in a folder
#   3 - user's format option
#

  $+list folders: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(3, u(get_format_option, get(%#/mail_config_options)))]

    strlen(%q0) = 0,
    {
#
# User does not have a mailbox, and therefore, has no folders.
#

      @pemit %# = 

        [switch(%q3, standard,
          {[u(equal_line)]
          %rList of %N's folders:%r%r}
        )]

        Folder Name[space(5)]D-flag[space(5)]Marked[space(6)]
          Saved[space(2)]Timed Out[space(5)]Unread[space(6)]Total
        %r[u(dash_line)]%r

        [ljust(secure(ulocal(get_inbox, %#)), 21)]
        0[space(10)]0[space(10)]0[space(10)]0[space(10)]0[space(10)]0

        [switch(%q3, standard, {%r[u(equal_line)]})]
    },
    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +list folders; 

        @pemit %# = 

          [switch(%q3, standard, 
            {[u(equal_line)]
            %rList of %N's folders:%r}
          )]

          Folder Name[space(5)]D-flag[space(5)]Marked[space(6)]
            Saved[space(2)]Timed Out[space(5)]Unread[space(6)]Total
          %r[u(dash_line)]; 

        &folder-list %q0 = squish(remove(get(%q0/folder-list), null)); 

        @dolist get(%q0/folder-list) = 
        {
          @pemit %# = 

            [setq(2, get(%q0/in-list-##))]

          [ljust(secure(lcstr(##)), 17)]

          [switch(
            strlen(%q2), 
            0, 
              [space(4)]0[space(10)]0[space(10)]0[space(10)]0
                [space(10)]0[space(10)]0, 
            {
              [rjust(u(count_deleted_letters, %q0, %q2), 5)]
              [rjust(u(count_marked_letters, %q0, %q2), 11)]
              [rjust(u(count_saved_letters, %q0, %q2), 11)]
              [rjust(ulocal(count_timed_out_letters, %q0, %q2), 11)]
              [rjust(u(count_unread_letters, %q0, %q2), 11)]
              [rjust(words(%q2), 11)]
            }
          )]
        }; 

        @swi 1 = 1,
        {
          @pemit %# = 
            %rSelected folder:%b [u(get_active_folder, %q0)]
            [switch(%q3, standard, {%r[u(equal_line)]})]; 
          @no %q0
        }
      }
    }

-
###############################################################################
#
#                                 + M O V E
#
###############################################################################
&MOVE_LETTER_TO_FOLDER #300=
#
# PURPOSE:
#
#   This command may be used to move one or more letters to a specified
#   folder.
#
# Command Format:
#
#   +move <letter(s) or keyword> to <folder name>
#
#   The following keywords are available to specify the scope of +move:
#
#     all, current (default), deleted, first, marked, last, next, 
#     previous, saved, unread
#
#   Only the first character of the keyword needs to be specified.
#
#   This command also accepts a list of numbers, including ranges.  For
#   example:  +move 1 3-5 8.  Either a '-' or a '..' may be used to
#   indicate a range specification.
#
#   The folder name may be multiple words, but is limited to 16 characters
#   and should not contain any characters (besides blanks) which are not
#   allowed in attribute names (i.e., no '`!*()=\[\]{}\%|,<>/?:; " well,
#   you get the idea).
#
#   If the folder does not exist, it will be created automatically.
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of internal mail numbers to move
#   2 - new value for current letter in active folder
#   3 - list of external mail numbers to move
#   5 - folder to move to, with internal blanks changed to $s.
#   6 - list of internal mail numbers for the current folder
#

  $+move* to *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(5, lcstr(edit(trim(%1), %b, $)))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(or(
      strmatch(escape(%0), *[*), 
      strmatch(escape(%1), *[*)
    )),
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    strlen(%q0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, ulocal(get_inbox, %#))
    },

    not(strmatch(%1, null)), 
    {@pemit %# = Gimme a break, just +delete it. \;)}, 

    eq(strlen([setq(2,
      [setq(3, %1)]filter(check_for_bad_chars, v(bad_chars)))]%q2), 0),
    {
#
# Invalid character detected in folder name.
#

      @pemit %# = Invalid character(s) %q2 detected in folder name.
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +move%0 to %1; 

        @swi/first 

          [setq(6, u(get_folder_in_list, %q0))]

          [setq(1, 
#
# Interpret user input and convert into a list of internal mail numbers
#
            ulocal(expand_letter_range,
              %0,
              %q6, 
              u(get_folder_current_letter, %q0)
            )
          )]

          [setq(1, 
#
# Reorder the list of letters to move into the same order as is in
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
            u(filter_list, setunion(%q1, ), %q6)
          )]

          [setq(2, 
#
# Determine the internal mail number of the last letter to move
#
            match(%q6, last(%q1))
          )]

          [setq(2, 
#
# Determine what the 'current letter' will be after all requested
# moves have occurred.  If the last letter in the in-list-<folder> is
# moved, set 'current letter' to the first letter in the in-list-<folder>.
# Otherwise, set 'current letter' to the letter after the last
# one moved.
#
            switch(

              last(%q1), 
              last(%q6), 

                first(%q6), 

              extract(%q6, add(%q2, 1), 1)
            )
          )]

          [setq(3, 
#
# Convert the list of internal mail numbers to external mail numbers
# for use in later display to the user.
#

            u(convert_nums, %q1, %q6)
          )]

        0 = words(%1),
        {
#
# No destination specified for where to move the letter to.  Notify user
# and release the semaphore.
#

          @pemit %# = You must specify a destination folder to move the 
            mail to.; 
          @no %q0
        },

        lte(strlen(%1), 16),
        {
#
# Folder name too long.  Notify user and release the semaphore.
#

          @pemit %# = Folder name specified is too long (maximum of 
            16 characters).; 
          @no %q0
        },

        words(%q6),
        {
#
# There is no mail in the user's mailbox.  Notify user and release 
# the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, %q0)); 
          @no %q0
        },

        not(strmatch(%q1, *ABORT*)),
        {
#
# Error detected in input parameter.  Notify the user, clear global
# variables and release the semaphore.
#

          @pemit %# = after(before(%q1, ENDABORT), ABORT); 
          @no %q0
        },

        words(%q1), 
        {
#
# Could not find any letters to match the specified input parameter.
# Notify the user, clear global variables and release the semaphore.
#

          @pemit %# = u(no_match, +move, ulocal(format_request, trim(%0)), 
            u(get_active_folder, %q0)); 
          @no %q0
        },

        not(strmatch(%q5, get(%q0/current_folder))), 
        {
#
# Folder to move to is the current folder.  No action needed.
#

          @pemit %# = The folder specified to move the letter(s) to 
            is the current folder ([u(get_active_folder, %q0)]), 
            no action needed.; 
          @no %q0
        },

        match(get(%q0/folder-list), %q5), 
        {
#
# Folder does not exist, create one.
#

          &folder-list %q0 = get(%q0/folder-list) %q5; 
          &in-list-%q5 %q0 = %q1; 
          &current_letter-%q5 %q0 = first(%q1); 

          &[setq(7, u(which_in_list, %q0))]%q7 %q0 = 
            u(filter_list, setdiff(%q6, %q1), %q6); 

          &[setq(8, u(which_current_letter, %q0))]%q8 %q0 = 
            switch(member(get(%q0/%q7), %q2), 0, first(get(%q0/%q7)), %q2); 

          @pemit %# = Message(s) %q3
            [ulocal(format_request, trim(%0))] moved 
            from folder '[u(get_active_folder, %q0)]' 
            to newly created folder '[lcstr(%1)]'.; 

          @no %q0
        }, 

        {
#
# Folder exists, just move letters over.
#

          &in-list-%q5 %q0 = squish([get(%q0/in-list-%q5)] %q1);

          &current_letter-%q5 %q0 = first(get(%q0/in-list-%q5)); 

          &[setq(7, u(which_in_list, %q0))]%q7 %q0 = 
            u(filter_list, setdiff(%q6, %q1), %q6); 

          &[setq(8, u(which_current_letter, %q0))]%q8 %q0 = 
            switch(member(get(%q0/%q7), %q2), 0, first(get(%q0/%q7)), %q2); 

          @pemit %# = Message(s) %q3
            [ulocal(format_request, trim(%0))] moved 
            from folder '[u(get_active_folder, %q0)]' 
            to folder '[lcstr(%1)]'.; 

          @no %q0
        }
      }
    }


-
&MOVE_NO_PARAM #300=

  $+move:

    @pemit %# = There are two ways to +move one or more letters to 
      another folder.

      %r%r1) +move to <folder name> - will move the current 
      letter to the specified folder (example:%b +move to things to do)

      %r%r2) +move <keyword or list of letters> 
      to <folder name> - will move the specified letters to the named 
      folder.%r%rThe folder will be created if it doesn't already exist.%b 
      See '+help move' for more details.

-
###############################################################################
#
#                      + A D D   F O L D E R
#
###############################################################################
&ADD_FOLDER #300=
#
# PURPOSE:
#
#   This command may be used to create a folder that mail may be moved to.
#   folder.
#
# Command Format:
#
#   +add folder <folder name>
#
#   The folder name may be multiple words, but is limited to 16 characters
#   and should not contain any characters (besides blanks) which are not
#   allowed in attribute names (i.e., no '`!*()=\[\]{}\%|,<>/?:; " well,
#   you get the idea).  You cannot add a folder with the name of 'null'.
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - folder name, with blanks converted to $
#   2 - newly created mailbox (if necessary)
#   4 - list of folders
#

  $+add folder *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(1, edit(lcstr(%0), %b, $))]

    1 = strmatch(escape(%0), *[*),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    not(strmatch(type(%#), PLAYER)),
    {
#
# User is not a player.
#

      @pemit %# = u(not_player)
    },

    eq(words(%0), 0),
    {
#
# Nothing was specified as the name of the folder.
#

      @pemit %# = You must specify a name for the folder.
    },

    strmatch(%0, null),
    {
      @pemit %# = Sorry, you cannot create a folder with the name of 'null'.
    },

    gt(strlen([setq(2, 
      [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]%q2), 0),
    {
#
# Invalid character detected in folder name.
#

      @pemit %# = Invalid character(s) %q2 detected in folder name.
    },

    gt(strlen(%0), 16),
    {
#
# Folder name too long.
#

      @pemit %# = Folder name specified is too long (maximum of 
            16 characters).
    },

    eq(strlen(%q0), 0),
    {
#
# User has no mailbox.
#

#
# Create a new mailbox and store the folder name in it.
#

      @create %N's Mailbox; 
      @set [setq(2, con(me))]%q2 = quiet; 
      @drain %q2; 
      &debug_mail %q2 = +add folder %0; 
      @tel %q2 = %vm; 
      &mailbox_%# %vm = %q2; 
      @tr %vm/add_mailbox = %q2; 
      &owner_dbref %q2 = %#; 
      @startup %q2 = {@drain me; @no me}; 
      @set %q2 = safe; 
      &mail-in-progress %q2 = false; 
      &folder-list %q2 = setunion(%q1, ulocal(get_inbox, %#)); 
      &current_folder %q2 = ulocal(get_inbox, %#); 

      @pemit %# = '[secure(%q1)]' has been added as a folder.;

      @no %q2
    },

    {
#
# User HAS a mailbox.
#

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +add folder %0; 

        @pemit %# = 

            [setq(4, remove(get(%q0/folder-list), null))]

          switch(
            gt(match(%q4, %q1), 0), 
            1, You already have a folder with this name., 
            '[secure(%q1)]' has been added as a folder.
          ); 

        &folder-list %q0 = setunion(%q4 %q1, ); 
        @no %q0
      }
    }

-
###############################################################################
#
#                      + R E M O V E   F O L D E R
#
###############################################################################
&REMOVE_FOLDER #300=
#
# PURPOSE:
#
#   This command may be used to remove a folder that was previously defined
#   either by an explicit '+add folder <folder name>' command, or 
#   indirectly by a '+move <letter(s) or keyword> to <folder name>' command.
#
# Command Format:
#
#   +remove folder <folder name>
#
#   The folder name may be multiple words, but is limited to 16 characters
#   and should not contain any characters (besides blanks) which are not
#   allowed in attribute names (i.e., no '`!*()=\[\]{}\%|,<>/?:; " well,
#   you get the idea).
#
# NOTE:
#
#   You may only remove empty folders.
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of folders
#   2 - folder name with blanks converted to $
#   3 - current folder
#

  $+remove folder*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(2, lcstr(edit(trim(%0), %b, $)))]

    1 = 

    strmatch(escape(%0), *[*),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strmatch(%q2, ulocal(get_inbox, %#)),
    {
      @pemit %# = You are not allowed to remove the designated 'inbox' folder.
    },

    eq(words(%0), 0), 
    {
#
# Folder not specified.
#

      @pemit %# = You must specify a name for the folder.
    },
  
    eq(strlen(%q0), 0), 
    {
#
# The user has no mailbox.
#

      @pemit %# = You do not have a folder defined with that name.
    },

    not(strmatch(type(%#), PLAYER)),
    {
#
# User is not a player.
#

      @pemit %# = u(not_player)
    },

    gt(strlen(%q0), 16),
    {
#
# Folder name too long.
#

      @pemit %# = Folder name specified is too long (maximum of 
            16 characters).
    },

    gt(strlen([setq(1,
      [setq(3, trim(%0))]filter(check_for_bad_chars, v(bad_chars)))]%q1), 0),
    {
#
# Invalid character detected in folder name.
#

      @pemit %# = Invalid character(s) %q1 detected in folder name.
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +remove folder%0; 

        @swi/first 1 = 

          [setq(1, get(%q0/folder-list))]

        or(
          eq(strlen(%q1), 0), 
          eq(match(%q1, %q2), 0)
        ),
        {
#
# Folder specified is not defined in user's mailbox.
#

          @pemit %# = You do not have a folder defined with that name.; 
          @no %q0
        },

        sign(words(get(%q0/in-list-%q2))),
        {
#
# Folder is not empty.
#

          @pemit %# = The folder specified is not empty and therefore 
            cannot be removed.; 
          @no %q0
        },

        {
          &folder-list %q0 = squish(remove(%q1, %q2)); 

          &in-list-%q2 %q0 = ; 
          &current_letter-%q2 %q0 = ; 

          &current_folder %q0 = 

              [setq(3, get(%q0/current_folder))]

            switch(%q2, %q3, ulocal(get_inbox, %#), %q3); 

          @pemit %# = '[lcstr(trim(%0))]' has been removed from your list 
            of folders.[switch(%q2, %q3,%b '[get(%q0/current_folder)]' 
            is now the active folder)]; 

          @no %q0
        }
      }
    }

-
###############################################################################
#
#                      + S E L E C T   F O L D E R
#
###############################################################################
&SELECT_FOLDER #300=
#
# PURPOSE:
#
#   This command may be used to choose a 'working' folder.  All +mail
#   commands work off the currently selected folder.
#
# Command Format:
#
#   +select folder <folder name>
#
#   The folder name may be multiple words, but is limited to 16 characters
#   and should not contain any characters (besides blanks) which are not
#   allowed in attribute names (i.e., no '`!*()=\[\]{}\%|,<>/?:; " well,
#   you get the idea).
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of folders
#   2 - folder to select with blanks converted to $
#

  $+select folder *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(2, lcstr(edit(%0, %b, $)))]

    1 = 

    strmatch(escape(%0), *[*),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    eq(words(%0), 0), 
    {
#
# Folder not specified 
#

      @pemit %# = You must specify a name for the folder.
    },

    strmatch(%0, null),
    {
      @pemit %# = 'null' is an invalid folder name.
    },

    and(
      eq(strlen(%q0), 0), 
      strmatch(%0, secure(ulocal(get_inbox, %#)))
    ),
    {
#
# User specified the designated 'inbox' and does not have a mailbox.  
# The designated 'inbox' always exists.
#

      @pemit %# = '[lcstr(%0)]' is already the selected folder.
    },

    eq(strlen(%q0), 0), 
    {
#
# User specified something other than the designated 'inbox' and 
# does not have a mailbox.  
#
      @pemit %# = You do not have a folder defined with that name.
    },

    not(strmatch(type(%#), PLAYER)),
    {
#
# User is not a player.
#

      @pemit %# = u(not_player)
    },

    gt(strlen(%0), 16),
    {
#
# Folder name too long.
#

      @pemit %# = Folder name specified is too long (maximum of 
            16 characters).
    },

    gt(strlen([setq(1,
      [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]%q1), 0),
    {
#
# Invalid character detected in folder name.
#

      @pemit %# = Invalid character(s) %q1 detected in folder name.
    },

    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +select folder %0; 

        @swi/first 

            [setq(1, get(%q0/folder-list))]

        eq(match(%q1, %q2), 0) = 1, 
        {
#
# Folder specified is not defined in user's mailbox.
#

          @pemit %# = You do not have a folder defined with that name.; 

          @no %q0
        },

        {
          @pemit %# = 
            switch(
              get(%q0/current_folder), 
              %q2, '[lcstr(%0)]' is already the selected folder., 
              '[lcstr(%0)]' is now the selected folder.
            ); 

          &current_folder %q0 = %q2; 

          @no %q0
        }
      }
    }

-
###############################################################################
#
#                      + A D D   F I L T E R
#
###############################################################################
&ADD_FILTER #300=
#
# PURPOSE:
#
#   This command may be used to add a mail filter.
#
#   Incoming mail can be automatically filtered into different folders
#   based on author or partial match on subject line.  
#
#   For example:  
#
#     +add filter author=Brandy folder=ignore
#
#       All incoming mail from Brandy will be stored in folder 'ignore'. ;)
#
#     +add filter subject=interview folder=interviews
#  
#       All incoming mail that has the word 'interview' in it will be
#       stored in folder 'interviews'.
#
# Command Format:
#
#   +add filter author|subject=<name or text> folder=<folder name>
#
#   The folder name may be multiple words, but is limited to 16 characters
#   and should not contain any characters (besides blanks) which are not
#   allowed in attribute names (i.e., no '`!*()=\[\]{}\%|,<>/?:; " etc).
#
#   If the folder named specified is 'null', incoming mail that passes
#   the specified filter, is tossed automatically.
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - folder name, with blanks converted to $
#   2 - newly created mailbox (if necessary)
#   4 - interpreted %0
#

  $+add filter *=* folder*=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(1, edit(lcstr(trim(%3)), %b, $))]
      [setq(4, switch(trim(%0), s*, subject, a*, author, error))]

    1 = 

    strmatch(%3, *reject*=*),,

    or(
      strmatch(escape(%0), *[*), 
      strmatch(escape(%1), *[*), 
      strmatch(escape(%3), *[*)
    ), 
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    not(strmatch(type(%#), PLAYER)),
    {
#
# User is not a player.
#

      @pemit %# = u(not_player)
    },

    strmatch(%q4, error),
    {
      @pemit %# = You must specify the type of filter, author or 
        subject.%b (syntax:%b +add filter author|subject=<name or text> 
        folder=<folder name>)
    },

    eq(words(%1), 0),
    {
      @pemit %# = You must specify [switch(%q4, author, A player 
        name to filter on, Some text to filter based on subject line)].
        %b (syntax:%b +add filter author|subject=<name or text> 
        folder=<folder name>)
    }, 

    and(
      strmatch(%q4, author), 
      not(strmatch(type(*%1), PLAYER))
    ),
    {
      @pemit %# = Name specified to filter based on author 
        is not an existing player.
    },

    eq(words(%3), 0),
    {
#
# Nothing was specified as the name of the folder.
#

      @pemit %# = You must specify a name for the folder.
    },

    gt(strlen([setq(2, 
      [setq(3, %3)]filter(check_for_bad_chars, v(bad_chars)))]%q2), 0),
    {
#
# Invalid character detected in folder name.
#

      @pemit %# = Invalid character(s) %q2 detected in folder name.
    },

    gt(strlen(%3), 16),
    {
#
# Folder name too long.
#

      @pemit %# = Folder name specified is too long (maximum of 
            16 characters).
    },

    eq(strlen(%q0), 0),
    {
#
# User has no mailbox.
#

#
# Create a new mailbox and store the filter in it.
#

      @create %N's Mailbox; 
      @set [setq(2, con(me))]%q2 = quiet; 
      @drain %q2; 
      &debug_mail %q2 = +add filter %0=%1 folder%2=%3;  
      @tel %q2 = %vm; 
      &mailbox_%# %vm = %q2; 
      @tr %vm/add_mailbox = %q2; 
      &owner_dbref %q2 = %#; 
      @startup %q2 = {@drain me; @no me}; 
      @set %q2 = safe; 
      &mail-in-progress %q2 = false; 
      &%q4_filter %q2 = [switch(%q4, author, [num(*%1)], %1)]|%q1; 
      &current_folder %q2 = ulocal(get_inbox, %#); 

      @pemit %# = Filter added.; 

      @no %q2
    },

    {
#
# User HAS a mailbox.
#

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +add filter %0=%1 folder%2=%3;  

        &%q4_filter %q0 = 
           trim(
             [get(%q0/%q4_filter)]~
             [switch(%q4, author, [num(*%1)], %1)]|%q1
             ,,~
           ); 
        @pemit %# = Filter added.; 
        @no %q0
      }
    }

-
###############################################################################
#
#                      + R E M O V E   F I L T E R 
#
###############################################################################
&REMOVE_FILTER #300=
#
# PURPOSE:
#
#   This command may be used to remove a filter that was previously defined
#   by a '+add filter' command.
#
# Command Format:
#
#   +remove filter <number>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of author filters
#   2 - list of subject filters
#

  $+remove filter*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = 

    strmatch(escape(%0), *[*),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    eq(words(%0), 0), 
    {
#
# Filter not specified.
#

      @pemit %# = You must specify which filter to remove.
    },
  
    eq(strlen(%q0), 0), 
    {
#
# The user has no mailbox.
#

      @pemit %# = You have no filters defined.
    },

    or(
      not(strmatch(trunc(%0), trim(%0))),
      lt(%0, 1),
      not(isnum(%0))
    ),
    {
#
# Non-natural number specified.
#

      @pemit %# = You must enter a non-zero integer.%b See +list filters 
        for a list of valid numbers.
    }, 
      
    {

#
# Snag the semaphore
#

      @wait %q0 = 
      {
        &debug_mail %q0 = +remove filter%0;  

        @swi/first 1 = 

          [setq(1, get(%q0/author_filter))]
          [setq(2, get(%q0/subject_filter))]

        gt(%0, add(words(%q1, ~), words(%q2, ~))), 
        {
          @pemit %# = Filter specified does not exist.; 
          @no %q0
        },

        gt(%0, words(%q1, ~)), 
        {
#
# Subject filter
#

          &subject_filter %q0 = ldelete(%q2, sub(%0, words(%q1, ~)), ~); 
          @pemit %# = Subject filter removed.; 
          @no %q0
        }, 

        {
#
# Author filter
#

          &author_filter %q0 = ldelete(%q1, %0, ~);
          @pemit %# = Author filter removed.;
          @no %q0
        } 
      }
    }

-
###############################################################################
#
#                        + L I S T   F I L T E R S
#
###############################################################################
&LIST_FILTERS #300=
#
# PURPOSE:
#
#   This command may be used to show one line of information per filter 
#   defined.
#
# Command Format:
#
#   +list filters
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of author filters
#   2 - list of author filters
#   3 - user's format option
#

  $+list filters: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    strlen(%q0) = 0,
    {
      @pemit %# = You have no filters defined.
    },
    {

#
# Snag the semaphore
#

      @wait 

        [setq(1, get(%q0/author_filter))]
        [setq(2, get(%q0/subject_filter))]
        [setq(3, u(get_format_option, get(%#/mail_config_options)))]

      %q0 = 
      {
        &debug_mail %q0 = +list filters;  

        @pemit %# = 

          switch(add(words(%q1, ~), words(%q2, ~)), 
          0, You have no filters defined.,
          {
          [switch(%q3, standard, 
            {[u(equal_line)]
            %r[center(List of Mail Filters, 78)]%r}
          )]

          [space(6)]Type[space(5)]Value[space(41)]Folder
          %r[u(dash_line)]

          [iter(%q1, 
            %r[rjust(member(%q1, ##, ~), 3)]\\)
            %b%bauthor%b%b%b
            [ljust(
              switch(type(before(##, |)), PLAYER, 
              name(before(##, |)), destroyed player)
            , 46)]
            [ljust(secure(after(##, |)), 16)]
            [switch(after(##, |), null, {%b\(discard\)},)]
            ,
            ~
          )]

          [iter(%q2, 
            %r[rjust(add(words(%q1, ~), member(%q2, ##, ~)), 3)]\\)
            %b%bsubject%b%b
            [ljust(before(##, |), 46)]
            [ljust(secure(after(##, |)), 16)]
            [switch(after(##, |), null, {%b\(discard\)},)]
            ,
            ~
          )]

          [switch(%q3, standard, {%r[u(equal_line)]})]}); 

        @no %q0
      }
    }

-
###############################################################################
#
# #7 is the Master Mailbox 
#
# Attributes:
#
#   add_mailbox
#   make_mailbox 
#   destroy_mailbox
#
#   @startup
#
#   Data attributes:
#     day_mon
#     day_tue
#     day_wed
#     day_thu
#     day_fri
#     day_sat
#     day_sun
#
#   Mail timeout related code:
#     how_long_til_purge
#     full_days
#     periodic_letter_purge
#     purge_old_letters
#     move_to_next_mailbox 
#     grab_letters
#
###############################################################################

# Nuke attributes no longer needed

&GENERIC_INFO_RECORD #7=
-
&GENERIC_MAILBOX #7=
-
&PROCESS_INFO_RECORD #7=
-



&ADD_MAILBOX #7 = 
#
# Stuff the mailbox on the mailboxes_* attribute.  This is not
# time critical since it is only used for the +mail status
# commands.
#

  @swi/first 

    [setq(0, v(mailboxes_num_of_attributes))]
    [setq(1, add(1, v(mailboxes_num_of_attributes)))]

  gt(strlen(v(mailboxes_%q0)), v(overflow_point)) = 1, 
  {
    &mailboxes_num_of_attributes me = %q1; 
    &mailboxes_%q1 me = [v(mailboxes_%q1)] %0
  }, 
  {
    &mailboxes_%q0 me = sort([v(mailboxes_%q0)] %0, d)
  }

-
&MAKE_MAILBOX #7=
#
# PURPOSE:
#
#   Make a mailbox.  This is a helper routine for '+make mailbox for <person>'.
#
# INPUT:
#
#   %0 - name of player to create mailbox for
#   %1 - dbref of invoker
#
# Registers Used:
#
#   0 - dbref of player to make mailbox for
#   1 - 'official' name of player to make mailbox for
#   2 - dbref of newly created mailbox
#

  @swi/first 

    [setq(0, num(*%0))]
    [setq(1, name(%q0))]

  0 = 

  strmatch(type(%q0), PLAYER),
  {
    @pemit %1 = [capstr(%0)] is not a player.
  },

  strlen(v(mailbox_%q0)),
  {
    @create %q1's Mailbox; 
    @set [setq(2, con(me))]%q2 = quiet; 
    @drain %q2; 
    &debug_mail %q2 = make mailbox; 
    @tel %q2 = me; 
    &mailbox_%q0 me = %q2; 
    @tr %vm/add_mailbox = %q2; 
    &owner_dbref %q2 = %q0; 
    @startup %q2 = {@drain me; @no me}; 
    @set %q2 = safe; 
    &mail-in-progress %q2 = false; 
    &current_folder %q2 = ulocal(#300/get_inbox, %q0); 
    &folder-list %q2 = get(%q2/current_folder); 
    @no %q2; 

    @pemit %1 = Mailbox created for %q1.
  },

  {
    @pemit %1 = %q1 already has a mailbox.
  }

-
&MAKE_MAILBOX2 #7=
-
&DESTROY_MAILBOX #7=
#
# PURPOSE:
#
#   Destroy a mailbox.  
#   This is a helper routine for:
#
#      '+destroy mailbox for <person>',
#      '+destroy mailbox for <dbref>',
#      '+toss',
#      'remove_letter',
#      'purge_old_letters'
#
# INPUT:
#
#   %0 - name OR dbref of player to destroy mailbox for
#   %1 - dbref of who/what caused this attribute to be invoked
#   %2 - the dbref of the mailbox to destroy, OR a '0' if unknown
#   %3 - debug info about invoking function
#
# Registers Used:
#
#   0 - dbref of player to destroy mailbox for
#   1 - dbref of mailbox to destroy   
#
# CAUTION:
#
#   This routine is extremely anal retentive about removing mailboxes
#   that don't 'look right'.  This is necessary to avoid problems with
#   infinite loops in the timeout code.
#

  @wait me = 
  {
    &debug_mail me = destroy mailbox - parameters: %0, %1, %2, %3; 

    &mailbox_
      [setq(0, switch(isdbref(%0), 1, %0, num(*%0)))]
      [setq(1, v(mailbox_%q0))]
        %q0 me=switch(get(%q1/owner_dbref), %q0,,v(mailbox_%q0)); 

    @swi/first 

    strlen(%q1) = 0, 
    {
#
# No mailbox.
#

      @swi/first %2 = 0,
      {
#
# Invoked by +destroy mailbox for <name>
#
        @pemit %1 = [name(%q0)] does not have a mailbox.; 
        @no me
      },
      {
#
# Called internally.  Bug.  Remove mailbox passed in from list, 
# and flag as an error.
#
        @dolist lnum(v(mailboxes_num_of_attributes)) = 
        {
          &mailboxes_[add(1, ##)] me = 
            squish(remove(v(mailboxes_[add(1, ##)]), %2))
        }; 

        @swi 1 = 1, 
        {
          &weird_mailboxes me = [v(weird_mailboxes)] %q1/%2:%0-%1-%2-%3; 
          @no me
        }
      }
    },
    {
 
      @swi/first 
        and(
          strmatch(get(%q1/owner_dbref), %q0),
          or(
            strmatch(%2, 0),
            strmatch(%2, %q1)
          )
        ) = 1,
      {
#
# A mailbox exists for the player name specified and it seems
# to be valid.
#

#
# Go through all received mail and remove it from the source mailboxes.
#

        @dolist u(#300/get_all_in_lists, %q1) = 
        {
          @tr #300/remove_letter = 
            u(#300/get_src_dbref, %q1, ##), 
            u(#300/get_src_num, %q1, ##), 
            get(%q1/owner_dbref), 
            %q1, 
            ##, 
            %b,
            +destroy mailbox
        }; 

#
# Go through all outstanding mail and remove it from the destination
# mailboxes.
#

        @dolist get(%q1/out-list) = 
        {
          @tr #300/retract_main = 
            num(me), 
            %q1, 
            ##, 
            %b
        }; 

        @dolist lnum(v(mailboxes_num_of_attributes)) = 
        {
#
# Since we don't know which mailboxes_* attribute the dbref of the
# mailbox resides in, need to try to remove it from all.
#

          &mailboxes_[add(1, ##)] me = 
            squish(remove(v(mailboxes_[add(1, ##)]), %q1))
        }; 

        @swi 1 = 1, 
        {
          @swi 1 = 1, 
          {
            @swi 1 = 1, 
            {
#
# Destroy the mailbox and notify invoker.  Stupid nested @swi's are
# needed to keep the queue correct and allow the above dolists to
# complete before nuking the mailbox.
#

              @destroy/override %q1; 
 
              @pemit %1 = Mailbox for [name(%q0)] has been destroyed.; 

              @no me
            }
          }
        }
      },
      {
#
# Mailbox does not appear valid.  Warn invoker.
#

        @pemit %1 = WARNING: mailbox_%q0 on the master mailbox does%b
          not appear to contain the dbref of a mailbox object for the%b
          specified player. Therefore, the 'mailbox' was NOT%b
          destroyed. Someone should look into this. The mailbox has been 
          moved to attribute 'weird_mailboxes' on the Master Mailbox.; 

        @dolist lnum(v(mailboxes_num_of_attributes)) = 
        {
          &mailboxes_[add(1, ##)] me = 
            squish(remove(remove(v(mailboxes_[add(1, ##)]), %q1), %2))
        }; 

        @swi 1 = 1, 
        {
          &weird_mailboxes me = [v(weird_mailboxes)] %q1/%2:%0-%1-%2-%3; 
          @no me
        }
      }
    }
  }

-
@startup #7 = 
#
# PURPOSE:
#
#   This is the STARTUP for the Master Mailbox.
#
#   It simply resets the semaphore to 'not in use' (-1) and
#   then determines how long until the next periodic letter
#   purge.
#

  @drain me; 
  @no me; 

  @wait u(how_long_til_purge) = @tr me/periodic_letter_purge; 

  @dolist v(global-mail-aliases)={&alias-## me=s(u(cleanup_one_alias, ##))}

-
&cleanup_one_alias #7=
iter(v(alias-%0), 
switch(strmatch(type(##), PLAYER)+[strmatch(##, #*)], 1+*, ##, *+0, ##,))

-
&HOW_LONG_TIL_PURGE #7 =
#
# PURPOSE:
#
#   This is a helper routine for the @startup on the Master Mailbox.
#   It calculates a value in seconds between the current time and
#   the time the next periodic letter purge is scheduled to occur.
#
# Registers Used:
# 
#   0 - current day
#   1 - timeout day
#   2 - current hour converted to minutes
#   3 - timeout hour converted to minutes
#   4 - current minute
#   5 - timeout minute
#   6 - current hour plus minute converted to minutes
#   7 - timeout hour plus minute converted to minute
#

  [setq(0, v(day_[first(time())]))]

  [setq(1, v(day_[mid(v(default_purge_time), 0, 3)]))]

  [setq(2, mul(mid(extract(time(), 4, 1), 0, 2), 60))]

  [setq(3, mul(mid(first(rest(v(default_purge_time))), 0, 2), 60))]

  [setq(4, mid(extract(time(), 4, 1), 3, 2))]

  [setq(5, mid(first(rest(v(default_purge_time))), 3, 2))]

  [setq(6, add(%q2, %q4))]

  [setq(7, add(%q3, %q5))]

  switch(

    [eq(%q0, %q1)]+[gt(%q7, %q6)],
    1+1,
      mul(sub(%q7, %q6), 60),
    1+0,
      sub(604800, mul(sub(%q6, %q7), 60)),
    add(
      mul(u(full_days, %q0, %q1), 86400),
      mul(%q7, 60),
      mul(sub(1440, %q6), 60)
    )
  )

-
#
# These data attributes are used in HOW_LONG_TIL_PURGE and convert
# the names of days of the week into a numeric representation.
#
&DAY_MON #7=1
-
&DAY_TUE #7=2
-
&DAY_WED #7=3
-
&DAY_THU #7=4
-
&DAY_FRI #7=5
-
&DAY_SAT #7=6
-
&DAY_SUN #7=7
-
&FULL_DAYS #7 =
#
# PURPOSE:
#
#   This is a helper function for HOW_LONG_TIL_PURGE.
#
#   Get the number of full days between the current day and the desired day.
#   Do not count the current day or the desired day.  For example, there
#   are 5 full days between Tuesday and the following Monday.  There are
#   no full days between Wednesday and Thursday.
#
# INPUT:
#
#   %0 - current day
#   %1 - desired day
#
# OUTPUT:
#
#   The number of full days between the current day and the desired day.
#

  switch(
    gt(%0, %1),
    1,
    add(sub(6, %0), %1),
    sub(sub(%1, %0), 1)
  )

-
&PERIODIC_LETTER_PURGE #7 = 
#
# PURPOSE:
#
#   Scan through all mailboxes and delete timed out messages.
#   Also, destroy empty mailboxes and mailboxes that no longer
#   belong to a valid player.
#
#   If the player has not logged in during the time specified
#   by that mailboxes's 'timeout' value, clear mail-in-progress
#   attributes also.
#

  @swi/first v(default_timeout_option) = 0,
  {
#
# Timeout code currently disabled.  Requeue the request just in case they
# turn it on for next time (one week later).
#
    @wait 604800 = @tr me/periodic_letter_purge
  },
  {
    @tr me/purge_old_letters = 
      first(v(mailboxes_1)), #7, 1, 1, v(mailboxes_1)
  }

-
&PURGE_OLD_LETTERS #7 = 
#
# %0 - dbref of mailbox to purge old letters from
# %1 - dbref of invoker (for testing purposes mainly)
# %2 - which mailboxes_* line is currently being scanned
# %3 - index of which list element in mailboxes_* being worked on
# %4 - actual mailboxes_* line
#
# use @va as temp variable to hold value of TIMEOUT to use as judging criteria
#     @vb as temp variable to hold secs()
#     @vc as temp variable to hold number of letters destroyed
#

#
# Snag the semaphore
#

  @wait me = 
  {
    &debug_mail me = purge_old_letters; 

    @swi/first type(get(%0/owner_dbref)) = PLAYER, 
    {
      @pemit %1 = Scanning [name(get(%0/owner_dbref))]'s mailbox for messages 
        which have timed out.; 

      @va me = u(#300/grab_timeout_value, get(%0/message_timeout), 
        v(default_timeout_option)); 

      @swi/first %va = 200000000,
      {
        @pemit %1 = %tTimeout capability disabled.; 
        @tr me/move_to_next_mailbox = %1, %2, %3, %4; 
        @va me = ; 
        @no me
      },
      {
        @vb me = secs(); 
        @vc me = 0; 

        @swi gte(sub(%vb, convtime(get(get(%0/owner_dbref)/last))), %va) = 1,
        {
          @wipe %0/mail-in-progress-*;
          &mail-in-progress %0 = false
        }; 

        @dolist [iter(get(%0/folder-list), u(grab_letters, %0, ##))] ZZ = 
        {

          @swi/first 1 = 

# Internal letter number

            [setq(0, before(##, ~))]

# Folder name

            [setq(1, after(##, ~))]

# Time Read

            [setq(2, get(%0/in-%q0-time_read))]

# Mail is unread?  1-yes, 0-no

            [setq(3, strmatch(%q2, 0))]

# 'saved' flag set?  1-yes, 0-no

            [setq(4, eq(match(get(%0/in-%q0-flags), S), 0))]

# Mail received longer than 'timeout' ago?  1-yes, 0-no
            [setq(5, 
              gte(
                sub(
                  %vb, 
                  convtime(get(u(get_src_dbref, %0, %q0)/
                    out-[u(get_src_num, %0, %q0)]-time_sent))
                ), 
                %va)
            )]

# Mail read longer than 'timeout' ago?  1-yes, 0-no
            [setq(6, gte(sub(%vb, convtime(%q2)), %va))]

          strmatch(##, ZZ),
          {
            @swi 1 = 1,
            {
# to get things queued right
              @pemit %1 = %t%vc message(s) deleted.; 
              @tr me/move_to_next_mailbox = %1, %2, %3, %4; 
              @va me = ; @vb me = ; @vc me = ; 
              @no me
            }
          },

          and(%q3, %q4, %q5),
          {
#
# Letter has not been read, the 'saved' flag is not set, and the letter 
# was received at least 'timeout' time ago.  Delete it.
#

# Increment count of letters deleted.

            @vc me = add(%vc, 1);

            @tr #300/remove_letter = 
              u(get_src_dbref, %0, %q0), 
              u(get_src_num, %0, %q0), 
              get(%0/owner_dbref), 
              %0, 
              %q0, 
              %q1,
              timeout A
          },

          and(not(%q3), %q4, %q6),
          {
#
# Letter has been read but not within 'timeout' time ago.  Delete it.
# (And the 'saved' flag is not set)
#

# Increment count of letters deleted.

            @vc me = add(%vc, 1); 

            @tr #300/remove_letter = 
              u(get_src_dbref, %0, %q0), 
              u(get_src_num, %0, %q0), 
              get(%0/owner_dbref), 
              %0, 
              %q0, 
              %q1, 
              timeout B
          }
        }
      }
    }, 

    {
      @tr me/destroy_mailbox = 
        get(%0/owner_dbref), num(me), %0, purge_old_letters;
      @pemit %1 = Mailbox belongs to dest'ed player.%b Mailbox destroyed.;
      @tr me/move_to_next_mailbox = %1, %2, %3, %4;
      @va me = ; 
      @no me
    }

  }

-
&GRAB_LETTERS #7 = 

  iter(get(%0/in-list-%1), ##~%1)

-
&MOVE_TO_NEXT_MAILBOX #7 = 
#
# %0 - dbref of invoker (needed for debug purposes, debug messages are 
#        only seen if the purge is triggered manually)
# %1 - which mailboxes_* is being dealt with
# %2 - which list element in mailboxes_* was last dealt with
# %3 - actual mailboxes_* list to work on
#

  @wait me = 
  {
    &debug_mail me = move_to_next_mailbox; 

    @swi/first 1 = 

    gte(%2, words(%3)), 
    {
      @swi/first lt(%1, v(mailboxes_num_of_attributes)) = 1,
      {
        @tr me/move_to_next_mailbox = 
          %0, add(1, %1), 0, v(mailboxes_[add(1, %1)]); 
        @no me 
      },
      {
        @pemit %0 = Purge complete.; 
        @no me; 
        @wait u(how_long_til_purge) = @tr me/periodic_letter_purge
      }
    },

    {
      @tr me/purge_old_letters = 
        extract(%3, add(1, %2), 1), 
        %0, 
        %1, 
        add(1, %2), 
        %3; 
      @no me 
    }
  }

-
###############################################################################
#
#                        H e l p e r   R o u t i n e s            
#
###############################################################################
&CHECK_FOR_BAD_CHARS #4167 = 

  comp(pos(%0, %q3), #-1)

-
&BAD_CHARS #4167 = 

  ' ` * ( ) = [ ] { } % | , < > / ? : ; "

-
&COUNT_UNREAD_LETTERS #4167 =

#
# %0 - mailbox dbref
# %1 - list of letters
#

 words(
   iter(
     %1,
     switch(get(%0/in-##-time_read), 0, ##,)
   )
 )

-
&COUNT_MARKED_LETTERS #4167 = 

#
# %0 - mailbox dbref
# %1 - list of letters
#

 words(iter(%1, switch(get(%0/in-##-flags), *m*, ##, )))

-
&COUNT_DELETED_LETTERS #4167 = 

#
# %0 - mailbox dbref
# %1 - list of letters
#

 words(iter(%1, switch(get(%0/in-##-flags), *d*, ##, )))

-
&COUNT_SAVED_LETTERS #4167 = 

#
# %0 - mailbox dbref
# %1 - list of letters
#

 words(iter(%1, switch(get(%0/in-##-flags), *s*, ##, )))

-
&COUNT_TIMED_OUT_LETTERS #4167 = 

#
# %0 - mailbox dbref
# %1 - list of letters
#
# CAUTION:  Use ulocal() when invoking this function to avoid
# stomping on registers
#

   [setq(0, get(%0/message_timeout))]
   [setq(1, get(%vm/default_timeout_option))]
   [setq(1, div(u(grab_timeout_value, %q0, %q1), 2))]

 words(
   iter(
     %1,

       [setq(2, get(%0/in-##-time_read))]

     switch(
       and(
         eq(match(get(%0/in-##-flags), s), 0), 
         not(strmatch(%q2, 0)), 
         gte(
           sub(secs(), convtime(%q2)), 
           %q1
         )
       ), 1, ##, )
   )
 )

-
&OK_TO_DEST_MAILBOX #4167 =
#
# %0 - dbref of mailbox
#
# OUTPUT:
#
#   Returns a 1 if it is OK to destroy the mailbox and a zero otherwise.
#

  and(
      eq(words(u(get_all_in_lists, %0)), 0),
      eq(words(get(%0/out-list)), 0),
      strmatch(get(%0/mail-in-progress), false),
      get(%vm/delete_when_empty),
      lte(get(%0/semaphore), 0),
      not(hasattr(%0, alias-list)), 
      not(hasattr(%0, author_filter)), 
      not(hasattr(%0, subject_filter)), 
      not(hasattr(%0, vacation)), 
      not(hasattr(%0, reject_msg)), 
      not(hasattr(%0, filter_reject)), 
      not(hasattr(%0, autoforward))
  )

-
&GET_ALIASES #4167=
#
# %0 - user input string
# %1 - user's mailbox dbref
# %2 - global mail aliases
# %3 - personal mail aliases for this user
#
# OUTPUT:
#
#   returns a list of aliases in the input string (both personal and global)
#   no commas
#

 setunion(iter(edit({%0},\\,,%b), switch(match(%3 %2, ##), 0,, ##)), )

-
&TEST_IF_ALIAS #4167=

#
# %0 - item to test to see if it is an alias
# %1 - user's mailbox dbref
#
# OUTPUT:
#
#   returns 'yes' if %0 is an alias in %1's mailbox and 
#   'no' otherwise.
#

  switch(
    match(get(%1/alias-list) [get(%vm/global-mail-aliases)], %0), 
    0, no, 
    yes
  )

-
&EXPAND_ALIASES #4167=
#
# %0 - list of personal and/or global mail aliases
# %1 - dbref of mailbox
# %2 - %b
# %3 - global mail aliases
# %4 - personal mail aliases
#
# OUTPUT:
#
#   Expand a list of personal and/or global mail aliases.  Weed out
#   anything that isn't a dbref.  Also, weed out dbrefs that do not
#   belong to valid players anymore.
#
# CAUTION:  This function is invoked with ulocal, so global registers
#           are local
#

  iter(
    u(expand_aliases2, %0, %1, %2, %3, %4),
    switch(
      and(isdbref(##), strmatch(type(##), PLAYER)), 
      1, 
      ##, 
    )
  )

-
&EXPAND_ALIASES2 #4167=
#
# Expand a list of personal and/or global aliases into player dbrefs
#
# %0 - list of personal and global mail aliases
# %1 - dbref of user's mailbox
# %2 - list of aliases already expanded (new parameter)
# %3 - list of global mail aliases
# %4 - personal mail aliases
#
# OUTPUT:
#
#   List of dbrefs and possibly also alias names.
#
# CAUTION:  Change this function at your peril
#

  iter(
    escape(trim(%0)),

        [setq(1, get(%1/alias-##))]
        [setq(2, get(%vm/alias-##))]
        [setq(3, get(%vm/global-mail-aliases))]

      switch(
      1, 

      sign(match(%2, ##)),, 

      sign(match(%4, ##)),
      {
        %q1 
        [u(expand_aliases, u(get_aliases, %q1, %1, %q3, %4), %1, %2 ##, %3, %4)]
      }, 

      sign(match(%3, ##)), 
      {
        %q2 
        [u(expand_aliases, u(get_aliases, %q2, %1, %q3, %4), %1, %2 ##, %3, %4)]
      }

      ,
    )
  )

-
&PRETTY_DIST #4167=

#
# %0 - list of aliases, personal and global
# %1 - dbref of mailbox
# %2 - get(%1/alias-list)
# %3 - global aliases
# %4 - player dbrefs
#
# OUTPUT:
#
#   Create a user displayable line identifying which aliases are
#   personal and which are global and a list of player names, all
#   separated by commas.
#

  u(list_names, 
    iter(%0 %4,
      switch(
        1,
        sign(match(%2, ##)),
          ##&(personal&mail&alias),
        sign(match(%3, ##)),
          ##&(global&mail&alias),
        strmatch(type(##), PLAYER), 
          edit(name(##), %b, &),
  )))

-
&IDENTIFY_TO_LIST #4167=
#
# Expected input:
#
#   %0 is a list of names input by the user.
#      Names possibly include personal and global aliases and may be
#      separated with commas
#   %1 is the users' mailbox dbref.
#
# Simply extract out the valid player names and convert them into a list
# of dbrefs. Anything that is not a player name or a mail alias is flagged
# as an error.

  squish(
    setunion(
      iter(
        u(identify_to_list2, %0), 
 
          [setq(1, edit(##, &, %b))]

        switch(
          1, 
          strmatch(type(*%q1), PLAYER), num(*%q1), 
          strmatch(u(test_if_alias, ##, %1), yes), 
            ,
          ABORTOne$or$more$of$the$destinations$specified$is$not$a$player$or$mail$alias.ENDABORT.
        )
      ),
    )
  )

-
&IDENTIFY_TO_LIST2 #4167=

  iter({%0}, switch(type(*##), player, edit(##, %b, &), ##), \,)

-
&FORMAT_NAMES #4167=

  u(format_names2, iter(%0, switch(##, #*, ##,)))

-
&FORMAT_NAMES2 #4167=

  switch(
    words(%0),
    0,,
    1, {[name(%0)]},
    2, {[name(first(%0))] and [name(rest(%0))]},
    {
      [iter(extract(%0, 1, sub(words(%0), 1)), {[name(##)],})] 
      and [name(extract(%0, words(%0), 1))]
    }
  )

-
&LIST_NAMES #4167=

  switch(
    words(%0), 
    0,, 
    1, {[edit(%0, &, %b)]},
    2, {[edit(first(%0), &, %b)] and [edit(rest(%0), &, %b)]},
    {
      [edit(iter(extract(%0, 1, sub(words(%0), 1)), {##,}), &, %b)] 
      and [edit(extract(%0, words(%0), 1), &, %b)]
    }
  )

-
&SECURE_NAMES #4167=

  switch(
    words(%0),
    0,,
    1, {[secure(%0)]},
    2, {[secure(first(%0))] and [secure(rest(%0))]},
    {
      [iter(extract(%0, 1, sub(words(%0), 1)), {[secure(##)],})] 
      and [secure(extract(%0, words(%0), 1))]
    }
  )

-
&FREE_NUM #4167=

#
# Find the first (lowest) available free number to use 
#
# %0 - list of numbers
#
# OUTPUT:
#
#   Returns the lowest number that is not currently being used in the
#   input list.  May potentially return a zero.
#

  first(sort(setdiff(lnum(add(words(%0), 1)), %0), N))

-
&EXPAND_LETTER_RANGE #4167=

#
# Input parameter parsing for:
#
# +skim, +mark, +unmark, +delete, +undelete, +read, +unread, 
#   +save, +unsave, and +move
#
# %0 is the user specified list of ranges
# %1 is the in-list-<folder> from the user's mailbox
# %2 is the current letter in the user's mailbox
#
# Returned is a list of valid mail messages
#
# CAUTION:  Using ulocal() when calling this function
#           so all registers are now available to be stomped on
#
# Do NOT stomp on %q0, we use that, it's the mailbox dbref
#

  squish(
  [setq(6, trim(%0, l))]
   switch(
    0, 

#
# Empty folder
#
    words(%1),,

#
# No parameter specified. Default is to use current message.
# If the current letter no longer exists, select a new one.
#
    strlen(%q6), 
      switch(hasattr(%q0, in-%2-location), 1, %2, u(first_unread, %q0)),

# 
# List of numeric characters/ranges assumed
#
    eq(%0, 0), 

      [setq(3, 
        iter(%0,
          switch(
            ##, 

            *-*, 

                [setq(1, before(##, -))]
                [setq(2, after(##, -))]

              switch(or(lte(%q1, 0), gt(%q2, words(%1)), lt(%q2, %q1)),
                1,
                ABORTInvalid message range specified.ENDABORT,

              lnum(%q1, %q2)),

            *..*, 

                [setq(1, before(##, ..))]
                [setq(2, after(##, ..))]

              switch(or(lte(%q1, 0), gt(%q2, words(%1)), lt(%q2, %q1)),
                1,
                  ABORTInvalid message range specified.ENDABORT,

                lnum(%q1, %q2)),

            switch(or(lte(##, 0), gt(##, words(%1))),
              1,
                ABORTInvalid message number specified.ENDABORT,

              ##)
          )
        )
      )]

      switch(%q3, *ABORT*, %q3, elements(%1, %q3)),

      switch(
        [setq(4, pos(:, %q6))]
        [setq(5, switch(%q4, #-1, Z, mid(%q6, 0, sub(%q4, 1))))]
        1,


#
# Author:<name>
#
# nasty games played here since I normally don't save 'sender', but 
# do for old mail that was converted, so 'old' mail author is obtained
# from -sender field, 'new' mail author is obtained from who stores
# the outgoing letter.
#
        strmatch(author, %q5*),

            [setq(1, trim(after(%0, :)))]

          switch(
            type(*%q1), PLAYER, 
            squish(iter(
              %1, 
 
                [setq(2, u(get_src_dbref, %q0, ##))]

              switch(
                member(
                [get(%q2/out-[u(get_src_num, %q0, ##)]-sender)] 
                [get(%q2/owner_dbref)], num(*%q1)), 0,, ##)
            )), 
            ABORTAuthor specified is not a player.ENDABORT
          ), 

#
# Subject:<text>
#
        strmatch(subject, %q5*),

            [setq(1, trim(after(%0, :)))]

          squish(iter(
             %1, 
             switch(get(u(get_src_dbref, %q0, ##)/out-
               [u(get_src_num, %q0, ##)]-subject) 
               [get(%q0/in-##-subject)]
	       , *%q1*, ##)
          )),

#
# Saved
#
        strmatch(saved, %q6*),
          squish(iter(%1, switch(get(%q0/in-##-flags), *S*, ##,))),

#
# Text:<text>
#
        strmatch(text, %q5*),

            [setq(1, trim(after(%0, :)))]

          squish(iter(
             %1, 
             switch(get(u(get_src_dbref, %q0, ##)/
               out-[u(get_src_num, %q0, ##)]-text), *%q1*, ##)
          )),

#
# All
#
        strmatch(all, %q6*),
          %1,

# 
# First
#
        strmatch(first, %q6*),
          first(%1),

#
# Previous
#
        strmatch(previous, %q6*),
          switch(
            %2, 
            first(%1),
              ABORTYou have reached the beginning of your mail messages.ENDABORT,
            extract(%1, sub(match(%1, %2), 1), 1)
          ),

# 
# Marked
#
        strmatch(marked, %q6*),
          squish(iter(%1, switch(get(%q0/in-##-flags), *M*, ##,))),

#
# Current
#
# Verify the value for current letter is still valid. If not, determine 
# a new value to use.
#
        strmatch(current, %q6*),
          switch(hasattr(%q0, in-%2-location), 1, %2, u(first_unread, %q0)),

# 
# Unread
#
        strmatch(unread, %q6*),
          squish(iter(%1, switch(get(%q0/in-##-time_read), 0, ##, %b))), 

# 
# Deleted
#
        strmatch(deleted, %q6*),
          squish(iter(%1, switch(get(%q0/in-##-flags), *D*, ##,))),

#
# Next
#
        strmatch(next, %q6*),
          switch(
            %2,
            last(%1),
              ABORTYou have reached the end of your mail messages.ENDABORT,
            extract(%1, add(match(%1, %2), 1), 1)
          ),

#
# Last
#
        strmatch(last, %q6*),
          last(%1), 

# 
# Otherwise, unable to parse input
#
        ABORTInvalid keyword specified.ENDABORT
      )
    )
  )

-
&GET_SRC_DBREF #4167 = 
#
# %0 - mailbox dbref
# %1 - internal received message number
#

  first(get(%0/in-%1-location))

-
# The following 2 attributes are for ease of timeout code
&GET_SRC_DBREF #7 = first(get(%0/in-%1-location))
-
&GET_SRC_NUM #7 = rest(get(%0/in-%1-location))
-
&GET_SRC_NUM #4167 = 
#
# %0 - mailbox dbref
# %1 - internal received message number
#

  rest(get(%0/in-%1-location))

-
&FORMAT_REQUEST #4167=

#
# Conversion of user specified input into readable value.
# This is for use in text sent to the user.
#
# Some games played here due to the bloody 30 parameter limit on
# function calls.
#
# CAUTION:  Use ulocal() when calling this function
#

  switch(

      [setq(1, after(%0, :))]

    %0+[strlen(%0)], 
#
# No parameter specified. Default is to use current message.
#
    *+0,
      {%b( current )},

    a*:*,
      {%b( author: %q1 )},
 
    s*, 
      {[switch(%0,*:*, {%b( subject: %q1 )}, {%b( saved )})]},

    t*:*,
      {[switch(%0,
        te*, {%b( text: %q1 )}, 
        {%b( to: %q1 )}, )]
      },

    a*, 
      {%b( all )},

    f*, 
      {%b( first )},

    p*, 
      {%b( previous )},

    m*, 
      {%b( marked )},

    c*, 
      {%b( current )},

    u*, 
      {%b( unread )},

    d*, 
      {%b( deleted )},

    l*, 
      {%b( last )},

    n*, 
      {%b( next )},

  )

-
&CONVERT_NUMS #4167=
#
# %0 - list of internal mail numbers to convert
# %1 - list of all letters in current folder (internal numbers)
#
# output - list of external mail numbers
#

  iter(%0, match(%1, ##))

-
&EXPAND_SINGLE_LETTER_RANGE #4167=

#
# Input parameter parsing for +reply, +forward and +add note
#
# %0 - user input
# %1 - in-list-<folder> of mailbox
# %2 - current letter for mailbox
#
# Register 0 - dbref of mailbox 
# 
# CAUTION:  Using ulocal() when calling this function
#           so all registers are now available to be stomped on
#
# Do NOT stomp on %q0, we use that, it's the mailbox dbref
#

  squish(
    switch(
      1+1, 

#
# Empty folder
#
      *+[eq(words(%1), 0)], 
      ,

#
# No parameter specified. Default is to use current message.
#
      *+[eq(strlen(%0), 0)], 
        switch(hasattr(%q0, in-%2-location), 1, %2, u(first_unread, %q0)),

#
# User input is multi-word
#
      *+[gt(words(%0), 1)],
        ABORTInput parameter may only be a single word.ENDABORT, 

#
# Range specified (a-b)
#
      *+[strmatch(%0, *-*)], 
        ABORTRange specifier (-) not allowed for this command.ENDABORT, 

#
# Range specified (a..b)
#
      *+[strmatch(%0, *..*)], 
        ABORTRange specifier (..) not allowed for this command.ENDABORT, 

# 
# Numeric character
#
      *+[gt(%0, 0)], 
        switch(
          or(
            gt(%0, words(%1)), 
            not(strmatch(%0, sub(%0, 0)))
          ),
          1, ABORTInvalid message number specified.ENDABORT,
          extract(%1, %0, 1)
        ),

#
# First
#
      strmatch(first, %0*)+*,
        first(%1),

#
# Last
#
      strmatch(last, %0*)+*,
        last(%1),

#
# Previous
#
      strmatch(previous, %0*)+*,
        switch(
          %2, 
          first(%1),
            ABORTYou have reached the beginning of your mail messages.ENDABORT,
          extract(%1, sub(match(%1, %2), 1), 1)
        ),

#
# Current
#
      strmatch(current, %0*)+*,
        switch(hasattr(%q0, in-%2-location), 1, %2, u(first_unread, %q0)),

#
# Next
#
      strmatch(next, %0*)+*,
        switch(
          %2,
          last(%1),
            ABORTYou have reached the end of your mail messages.ENDABORT,
          extract(%1, add(match(%1, %2), 1), 1)
        ),

#
# 
# Otherwise, unable to parse input
#
    ABORTUnrecognized keyword specified.ENDABORT
  ))

-
&EXPAND_OUTGOING_LETTER_RANGE #4167=

#
# Input parameter parsing for:
#
# +review
#
# %0 is the user specified list of ranges
# %1 is the out-list from the user's mailbox
# %2 is the current 'out' letter in the user's mailbox
# %3 is the dbref of the mailbox
#
# Returned is a list of valid mail messages
#
# CAUTION:  Using ulocal() when calling this function
#           so all registers are now available to be stomped on
#
# Do NOT stomp on %q0, we use that, it's the mailbox dbref
#

  squish(
  [setq(6, trim(%0, l))]
   switch(
    0, 

#
# No saved outgoing mail
#
    words(%1),, 

#
# No parameter specified. Default is to use current 'out' message.
# If the out_list_current no longer exists, select the most recently
# sent letter.
#
    strlen(%q6), 
      switch(hasattr(%q0, out-%2-text), 1, %2, last(%1)),

# 
# List of numeric characters/ranges assumed
#
    eq(%0, 0), 

      [setq(3, 
        iter(%0,
          switch(
            ##, 

            *-*, 

                [setq(1, before(##, -))]
                [setq(2, after(##, -))]

            switch(or(lte(%q1, 0), gt(%q2, words(%1)), lt(%q2, %q1)),
              1,
              ABORTInvalid message range specified.ENDABORT,

              lnum(%q1, %q2)), 

            *..*,

                [setq(1, before(##, ..))]
                [setq(2, after(##, ..))]

              switch(or(lte(%q1, 0), gt(%q2, words(%1)), lt(%q2, %q1)),
                1,
                  ABORTInvalid message range specified.ENDABORT,

                lnum(%q1, %q2)),

            switch(or(lte(##, 0), gt(##, words(%1))),
              1,
                ABORTInvalid message number specified.ENDABORT,

              ##)
          )
        )
      )]

      switch(%q3, *ABORT*, %q3, elements(%1, %q3)),

      switch(
	[setq(4, pos(:, %q6))]
	[setq(5, switch(%q4, #-1, Z, mid(%q6, 0, sub(%q4, 1))))]
      1,


#
# Text:<text>
#
      strmatch(text, %q5*),

            [setq(1, trim(after(%0, :)))]

        squish(iter(%1, switch(get(%3/out-##-text), *%q1*, ##))),

#
# To:<name>
#
      strmatch(to, %q5*),

            [setq(1, trim(after(%0, :)))]
            [setq(2, num(*%q1))]

        switch(
          type(*%q1), PLAYER, 
          squish(iter(
             %1, 
             switch(
               match(get(%3/out-##-dist), %q2:*), 
               0,, ##))
             ), 
          ABORTName specified is not a player.ENDABORT
        ), 

#
# Subject:<text>
#
      strmatch(subject, %q5*),

            [setq(1, trim(after(%0, :)))]

        squish(iter(%1, switch(get(%3/out-##-subject), *%q1*, ##))),

#
# All
#
      strmatch(all, %q6*),
        %1,

# 
# First
#
      strmatch(first, %q6*),
        first(%1),

#
# Previous
#
      strmatch(previous, %q6*),
        switch(
          %2, 
          first(%1),
            ABORTYou have reached the beginning of your mail messages.ENDABORT,
          extract(%1, sub(match(%1, %2), 1), 1)
        ),

#
# Current
#
# Verify the value for current letter is still valid. If not, determine 
# a new value to use.
#
      strmatch(current, %q6*),
        switch(hasattr(%q0, out-%2-text), 1, %2, last(%1)),

#
# Last
#
      strmatch(last, %q6*),
        last(%1), 

#
# Next
#
      strmatch(next, %q6*),
        switch(
          %2,
          last(%1),
            ABORTYou have reached the end of your mail messages.ENDABORT,
          extract(%1, add(match(%1, %2), 1), 1)
        ), 

# 
# Otherwise, unable to parse input
#
        ABORTInvalid keyword specified.ENDABORT
      )
    )
  )

-
&FILTER_LIST #4167=
#
# %0 - list of letters to perform action on - out of order
# %1 - list of letters in mailbox
#
# This is needed due to setunion's irritating habit of sorting lists.
#
# This function will take a list of internal mail numbers and put them
# back in chronological order again.
#

 squish(switch(%0, *ABORT*, %0, iter(%1, switch(member(%0, ##), 0, , ##))))

-
&FIRST_UNREAD #4167=
#
# Assumptions - this won't be called when in-list-<folder> is empty.
# Obtain the first unread letter, or if they've all been read,
# return the most current letter.
#
# %0 - dbref of mailbox
#
# Note:  registers not used due to muckiness of figuring out the 
# interdependent usage of registers amongst function calls.
#

 first(
   [iter(u(get_folder_in_list, %0)),
     switch(get(%0/in-##-time_read), 0, %b##%b, %b)
   )]%b
   [last(u(get_folder_in_list, %0)))]
 )
   
-
&GET_DELETE_OPTION #4167=

#
# %0 - user's dbref
#
# If the user has specified a value for this option, use it, otherwise
# use the mail system-wide value
#

  switch(
    get(%0/mail_config_options),

    *soft*, 
      soft, 

    *hard*, 
      hard, 

    get(%vm/default_delete_option)
  )
    
-
&GET_FORMAT_OPTION #4167=

#
# %0 - user's mail_config_options
#
# If the user has specified a value for this option, use it, otherwise
# use the mail system-wide value
#

  switch(
    %0, 

    *standard*, standard, 

    *compact*, compact, 

    get(%vm/default_format_option)
  )

-
&GET_SEPARATOR_OPTION #4167=

#
# %0 - user's dbref
#
# If the user has specified a value for this option, use it, otherwise
# use the mail system-wide value.  
#

  switch(
    get(%0/mail_config_options),

    *space*, %b,

    *return*, %r,

    switch(get(%vm/default_separator_option), space, %b, %r)
  )

-
&GET_INBOX #4167=

#
# %0 - user's dbref
#
# If the user has specified a value for this option, use it, otherwise
# return 'main'.
#
# CAUTION:  use ulocal() when invoking this function
#

  switch(

      [setq(1, get(%0/mail_config_options))]

    %q1, 
    *INBOX*, 
      before(after(%q1, INBOX:), :INBOXEND), 
    main
  )

-
&FOLDER_TO_STORE_INTO #4167=

#
# %0 - user's mailbox
# %1 - author
# %2 - subject
# %3 - user's dbref
#
# &author_filter mailbox=dbref|folder~dbref|folder~dbref|folder
# &subject_filter mailbox=text|folder~text|folder~text|folder
#

  first(
    [iter(
      get(%0/subject_filter), 
      switch(strmatch(%2, *[before(##, |)]*), 1, after(##, |)), 
      ~
    )] 
    [iter(
      get(%0/author_filter), 
      switch(strmatch(%1, [before(##, |)]), 1, after(##, |)), 
      ~
    )] 
    [ulocal(get_inbox, %3)]
  )

-
&AUTOFORWARD_TEST #4167=
#
# %0 - dbref of person to determine if an autoforward is set for
#
# CAUTION:  use ulocal() when invoking this function
#

    [setq(1, get(%vm/mailbox_%0))]
    [setq(2, get(%q1/autoforward))]

  switch(
    0, 

    strlen(%q1), 
#
# destination player has no mailbox, no autoforward
#
    %0,

    strlen(%q2), 
#
# destination player has a mailbox, but does not have an autoforward specified
#
    %0,

# 
# destination player has a mailbox, and has an autoforward specified
#
    trim(
      setunion(
        [u(snag_dbrefs, %q2)] 
        [u(expand_aliases, %q2, %q1, %b, get(%vm/global-mail-aliases), 
          get(%q1/alias-list))], 
      )
    )
  )

-
&GET_AUTOFORWARD_OPTION #4167=

#
# %0 - user's dbref
#
# CAUTION:  use ulocal() when invoking this function
#

    [setq(7, get(%vm/mailbox_%0))]
    [setq(4, get(%q7/autoforward))]
    [setq(8, get(%vm/global-mail-aliases))]
    [setq(9, get(%q7/alias-list))]
    
  switch(
    0, 

    strlen(get(%vm/mailbox_%0)), 
      {Mail will not be autoforwarded},

    strlen(%q4), 
      {Mail will not be autoforwarded},

    {Mail will be autoforwarded to [u(pretty_dist, u(get_aliases, %q4, 
      %q7, %q8, %q9), %q7, %q9, %q8, u(snag_dbrefs, %q4))]
    }
  )

-
&GET_PERSONAL_ALIASES #4167=

#
# %0 - user's dbref
#
# CAUTION:  use ulocal() when invoking this function
#

  switch(

      [setq(1, get(%vm/mailbox_%0))]
      [setq(2, get(%q1/alias-list))]

    0, 

    strlen(%q1), 
      No personal mail aliases defined, 

    words(%q2), 
      No personal mail aliases defined, 

    u(list_names, trim(%q2))
  )

-
&GET_ACTIVE_FOLDER #4167 =

#
# %0 - mailbox dbref
#

  secure(get(%0/current_folder))

-
&GET_FOLDERS #4167=

#
# %0 - user's dbref
#
# CAUTION:  use ulocal() when invoking this function
#

  switch(

      [setq(1, get(%vm/mailbox_%0))]

    0, 

    strlen(%q1), 
      secure(ulocal(get_inbox, %0)), 

    u(secure_names, trim(get(%q1/folder-list)))
  )

-
&GET_FILTER_COUNT #4167 = 

#
# %0 - user's dbref
#
# CAUTION:  use ulocal() when invoking this function
#

  switch(

      [setq(1, get(%vm/mailbox_%0))]

    0, 

    strlen(%q1), 
      0, 

    add(
      words(get(%q1/author_filter), ~), 
      words(get(%q1/subject_filter), ~)
    )
  )

-
&WHICH_IN_LIST #4167 =
#
# %0 - mailbox dbref
#

  in-list-[default(%0/current_folder, main)]

-
&WHICH_CURRENT_LETTER #4167 =
#
# %0 - mailbox dbref
#

  current_letter-[default(%0/current_folder, main)]

-
&GET_ALL_IN_LISTS #4167 =
#
# %0 - dbref of mailbox
#

  iter(get(%0/folder-list), get(%0/in-list-##))

-
&GET_FOLDER_IN_LIST #4167 =
#
# %0 - mailbox dbref
#

  get(%0/in-list-[default(%0/current_folder, main)])

-
&GET_FOLDER_CURRENT_LETTER #4167 =
#
# %0 - mailbox dbref
#

  get(%0/current_letter-[default(%0/current_folder, main)])

-
&GET_TIMEOUT_OPTION #4167=

#
# %0 - user's dbref
#
# If the user has specified a value for this option, use it, otherwise
# use the mail system-wide value
#
# (not too worried about performance on this one, only done on a 
# +show mail options and +mail status for <person>
#
# CAUTION:  use ulocal() when invoking this function
#

  [setq(1, get(%vm/mailbox_%0))]
  [setq(2, get(%q1/message_timeout))]
  [setq(3, get(%vm/default_timeout_option))]
  [setq(4, div(%q3, v(seconds_in_day)))]

  switch(
    [strlen(%q1)]+[strlen(%q2)]+%q2,

    0+*+*,
#
# destination player has no mailbox, use system-wide default
#
    switch(
      [strlen(%q3)]+%q3, 

      0+*,
      {0 (timeout capability disabled system-wide)},

      *+0,
      {0 (timeout capability disabled system-wide)},

      {%q4 days}
    ),

    *+0+*,
#
# destination player has a mailbox, but does not have a timeout specified
# use system-wide default
#
    switch(
      [strlen(%q3)]+%q3, 

      0+*,
      {0 (timeout capability disabled system-wide)},

      *+0,
      {0 (timeout capability disabled system-wide)},

      {%q4 days}
    ),

    *+*+0,
#
# destination player has a mailbox, has a timeout specified that is 
# set to zero
#
    0 (timeout capability disabled for this mailbox),

#
# destination player has a mailbox, has a timeout specified that is NOT
# zero
#
    {[div(%q2, v(seconds_in_day))] days}
  )

-
@startup #300 = @wipe me/mail_temp*; @startup me=
-
&GRAB_TIMEOUT_VALUE #4167 =
#
# Get the value in seconds for the 'message timeout' for the specified
# mailbox. If there is no timeout for the mailbox, grab the system default.
#
# %0 - message_timeout in mailbox
# %1 - default timeout option for entire mail system
#

  switch(
    0, 

    strlen(%0), 
      switch(
        0, 

        strlen(%1), 
          200000000, 

        %1, 
          200000000, 

        %1
      ),

    %0, 
      200000000,

    %0
  )
    
-
&PURIFY_ALIAS_LIST #4167=

  squish(iter(%0, switch(##+[type(##)], #*+PLAYER, ##, #*,, ##)))

-
###############################################################################
#
#            H I S T O R Y of the revision changes for this +mailer
#
###############################################################################
#
# Version 13 updates:
#
# General:
#   o  changed code to only store a single copy of all letters, no matter
#        how wide the distribution 
#   o  expanded usage of setq()/r() including removal of ALL temp variable 
#        usage
#   o  restructured things, one new object, three obsolete (and can be 
#        deleted objects)
#   o  performance should be dramatically improved
#
# Added code to support folders, new commands:
#
#   o  +add folder <folder name>
#   o  +remove folder <folder name>
#   o  +list folders
#   o  +move <letter> to <folder>
#   o  +select folder <folder name>
#   o  +add filter author|subject=<name or text> folder=<folder name>
#   o  +remove filter <number>
#   o  +list filters
#
#   updated all commands to work off of current_folder (default is the 
#   inbox 'main' if not otherwise specified)
#
# Misc tweaks the user's may notice:
#   o  Allow autoforward to be a list of people and/or aliases
#   o  show total messages on +read, i.e., Message:  4/23 
#   o  +edit cc, +edit bcc, +edit to, +edit subject, +edit personal alias
#        and +edit global alias now check to see if the text of what you 
#        want to change is actually there.  It also shows you the final
#        result of the edit upon completion (for aliases, others did that
#        before). 
#   o  +skim now shows a 'n' next to messages that have a note registered
#   o  allow +add note=<text> to add note to current letter
#   o  options shown after a +read now include +move and +save
#   o  +expand personal alias and +expand global alias displays are
#        slightly easier to read ('specially if folks have blanks in 
#        their names)
#   o  +set mail option separator = space or return 
#   o  +set mail option inbox = <folder nam>                         
#   o  +set mail option vacation=<text>
#   o  +set mail option reject=<text>
#   o  +show mail options now shows value for 'separator' option
#   o  +show mail options now shows value for 'inbox' option
#   o  +show mail options now shows list of personal aliases
#   o  +show mail options now shows list of folders
#   o  +show mail options now shows count of filters
#   o  +show mail options now shows vacation text
#   o  +show mail options now shows reject text
#   o  +note <text> command added 
#   o  allow author:<name>, subject:<text>, text:<text fragment> to be 
#        used as keywords
#   o  allow +forward <people>=<letter> in addition to the normal +forward cmd.
#        this form allows you to add additional text via '-<text>' before
#        sending.
#   o  Replaced '+review letter to <person>' with
#      '+review [<list of numbers or keyword>]'
#      +review w/no parameter shows one summary line per sent letter
#      keywords allowed:  all, current, first, last, next, previous, 
#        to:<player>, subject:<text>, text:<text fragment>
#   o  Replaced '+retract letter to <person>' with
#      '+retract <letter number or keyword>'
#      keywords allowed:  first, next, previous, last, current
#
# Misc tweaks admin's may notice:
#   o  automatically destroy mailboxes for dest'ed players during
#        periodic mail timeout code
#   o  created command to allow admin to specify when periodic letter purge
#        should run, default is Wednesdays at 4 AM
#        ( format:  +set mail default purge=<day of week> <hour>:<minute> )
#   o  created command to allow admin to enable or disable the +save
#        command for all users. 
#        ( format:  +set mail default save = enabled | disabled )
#   o  +set mail default separator = space | return
#   o  +mail configuration changes:
#        shows the default for the 'separator' option
#        shows when the next letter/mailbox purge is scheduled
#        shows how many attributes are being used to hold the list of mailboxes
#        shows the configured text for: delivery_notification, 
#          pickup_notification, forward_notification, text_added_notification
#        does some verification that things were set up right and warns if not.
#   o  +mail status changes:
#        shows number of defined folders 
#        shows number of defined filters 
#        shows number of sent messages still stored (not deleted by recipient)
#   o  +mail status for <player> changes:
#        shows list of personal aliases defined
#        shows total and list of folders defined
#        shows current folder
#        shows current letter for the selected folder
#        shows total of sent messages still stored (not deleted)
#        shows inbox folder name
#        shows number of filters
#   o  automatically do a +mail configuration at the end of installation
#
# Bug fixes:
#   o  fixed bug - +replyall needs to include the sender as well
#   o  made the code more accurate about overflowing letter size
#   o  fixed semaphore not being notified in +add global alias and 
#        +edit global alias end cases.
#   o  fixed bug in the purge old letters code that resulted in an 
#        infinite loop
#
###############################################################################
#
# Version 12 updates:
#
#   Added setq()/r() usage to improve performance
#
###############################################################################
#
# Version 11 updates:
#
#   New command:
#
#     +replyall [keyword or letter number]
#
#     The following keywords are available to specified the scope of 
#     +replyall:  current (default), first, last, next previous
#
#     This variation of the +reply command will send a response to 
#     all of the people who received the original message.
#
#   New wizard command: 
#
#     +set mail default format = standard | compact 
#
#     Sets the game default is for the format of +mail displays.  
#     Users may specify their own individual default. Installation 
#     default is 'standard'.  'compact' displays have the same
#     information as the 'standard' displays, without the formatting
#     lines and white space.
#
#   New command:  +set mail option format = standard | compact
#
#   Show new 'format' value on the +show mail options command.
#
#   Show new default 'format' value on the +mail configuration command.
#
#   Modified +proof, +show mail options, +review letter, +status of 
#   mail sent, +skim, +read, +list personal aliases, +expand personal alias,
#   +list global aliases, +expand global alias and all admin display commands
#   to use the new 'format' option in determining the format of the displayed 
#   output.
#
###############################################################################
#
# Version 10 updates:
#
#   New wizard-only command:
#
#     +set mail default timeout=<number of days>  
#
#       Sets the number of days before mail messages are timed out and
#       deleted.  (Installation default is 2 weeks). Code to delete
#       timed out messages runs every timeout default divided by 2 days. 
#       For example, since the default timeout is 2 weeks, the code to 
#       delete timed out messages runs once a week.  Or one hour
#       after game startup.
#
#   Show new default 'timeout' value on the +mail configuration command.
#
#   Show 'timeout' value on the +show mail options' command.     
#
#   New wizard-only command:
#
#     +set mail option timeout=<number of days> for <name> 
# 
#       Sets the number of days before mail messages are timed out and 
#       deleted on a specific mailbox, if other than the mail system-wide
#       default is desired.  A value of zero disables the timeout
#       mechanism for the specified mailbox.
#
#   New commands:
#
#     +save [keyword or list of letter numbers]
#
#       Sets the specified letters as not to be timed out
#
#     +unsave [keyword or list of letter numbers]
#
#       Removes the 'S' (saved) flag from the specified letters
#
#   Show new 'S' flag on +skim and +read
#
#   Some performance tweaks
#
#   Added more comments to the code
#
#   Fixed a bug in the handling of registered mail.  It was mishandling if
#   you did a +read that resulted in more than one registered mail being 
#   read.  In some cases, the receipt notification was not being sent 
#   back.
#
# Restructured admin commands to be 'queue nice' (though slower as a 
# result - only one queue entry at a time)  (all +mail status cmds) 
#
# Added '+mail status bad sem*' to show only those mailboxes with
# whacked out semaphores.
#
# Modified +mail status commands to flag mailboxes that are no longer
# associated with a valid player (useful for handling player dests).
#
###############################################################################
#
# Version 9 updates:
#
#   Trimmed excess blanks from attribute lists to make the server happier
#
#   +review letter to <person>
#
#     Use this command to see the text of a letter you have already sent
#     to someone if you want to refresh your mind on what you said (possibly
#     before doing a +retract letter to <person> ;).
#
#   Tweaked +flush to tell you how many messages were deleted and how many
#     remain
#
#   +set mail option autoforward=<person>
#     (I've got a request in to make this be a list of people and to also
#     allow mail aliases - it's a future thing, I haven't gotten to that
#     yet)
#
#   Changed receipt notification to show who letter is from and any flags
#     that are set.
#
###############################################################################
#
# Version 8 updates:
#
# Both personal and global mail aliases may now refer to other aliases
# in addition to player names. (Requested by Marlena of SC)
#
# Added new wizard command: +set mail default delete=hard | soft so the
# administration can configure what the game default is for +delete. Users
# may still specify their own individual defaults of course. Changed the
# default delete option from hard to soft.
#
# Added new wizard command: +set mail default mode=verbose | terse so the
# administration can configure what the game default is for mode. Users
# may still specify their own individual defaults of course. 
#
# Added +mark
# Added +unmark
# Added +mail changes
#
# +mark, +unmark, +delete, +undelete, +read, +unread, +skim now accept the
# following keywords:  all, current, deleted, first, last, marked, next,
# previous, and unread. These commands also accept a list of numbers
# including ranges. For example:  +mark 1 3-5 8. Either a '-' or '..' may be
# used to indicate a range specification.
#
# +reply, +forward, +add note now accept the following keywords:  current,
# first, last, next, previous in addition to letter number.
#
# Allow +cancel letter to be an alias to +retract letter
# Allow +clear to be an alias to +delete
#
# Changed to be more efficient on attribute usage. For example, if the
# internal in-list was 0 2 5 37, the next number to use will be 1 instead
# of 38.
#
# Some minor performance tweaking, i.e., removed a wad'o'extra ['s
#
# fixed some bugs
#
###############################################################################
#
# Version 7 updates:
#
#   Changed to work with player names that contain blanks
#
###############################################################################
#
# Version 6 updates:
#
# Added '+status of mail sent to <person>'
#
# removed the mail-body-in-progress flag. '-' by itself now simply shows
# the available options. Tweaked the verbose/terse messages.
#
# added +edit personal alias <alias>=<old>/<new>
#
# added +edit global alias <alias>=<old>/<new>
#
# (note: any time a +edit <personal or global> alias is done, it automatically
# weeds out the non-players.
#
# fixed bug in +read related to registered mail. It was sending a registered
# response every time a registered mail was read, instead of just the first 
# time.
#
# fixed +edit to, +edit cc and +edit bcc to not force you to enter a
# blank to keep the names separate when using the ^ or $ options.
# ie, used to have to +edit to=$/%bBrandy, now can +edit to=$/Brandy
#
# changed the +mail status summary display to show number of aliases defined
#
# moved the verbose and terse messages onto the mail system object
# and removed all references to the help text module from this file
#
# added a date/time stamp for when the source code was last updated.
# (shows up in +mail credits)
#
# fixed typo in cleanup_forward and cleanup_send which referenced
# master_room instead of mail_system
#
###############################################################################
# Version 5 updates:
#
#   Changed +destroy mailbox for <person> to also accept the dbref of
#   a person, either still around or destroyed.
#
#   Set the mailboxes 'safe' upon creation.
#   Change the destroy mailbox code to use the /override switch
#
#   Cleaned up +mail status, +mail configuration, and destroy mailbox to
#   handle overflow of mailboxes_<whatever>. The make mailbox has handled
#   it all along, but the other ones didn't. Overflow occurs at about
#   600 or so depending on the size of the dbrefs in the list.
#   (to be exact, 557 if all dbrefs are a full 5 digits)
#
#   Added some safety precautions in destroy_mailbox to make sure that
#   a key mail attribute is present in the object before dest'ing it.
#
#   Changed +mail status, +mail status for <person> and +mail status ><num>
#   to show a warning message if it runs across something that doesn't seem
#   to be a valid mailbox.
#
###############################################################################
# Version 4 updates:
#
#   put a blank in between successive -'s. :P 
# 
#   add a pickup_notification attribute (for use in +send, +reply).
#
#   added a forward_notification attribute (for use in +forward).
#
#   Have +check mail and +read tell how many total messages in addition 
#   to how many unread, so they know where to start reading. 
#
#   fixed bug in +add global alias which was referencing %0 instead of %#
#
#   put +add global alias and +remove global alias under semaphore protection
#
#   changed +add global alias and +add personal alias to not allow an alias
#   which is a player's name.
#
#   changed +list global aliases, +list personal aliases, +expand global
#   alias and +expand personal alias to show a warning message if the alias
#   is the name of a player.
#
#   Modified +mail status to show the value of the semaphore for each
#   mailbox to make it easier to identify mailboxes that are potentially
#   hosed.
#
###############################################################################
# Version 3 updates:
#
#   SECURITY changes. Numerous changes were put in to prevent
#   malicious users from doing nasty things like:
#   +mail %[loc(*<player>)%]=whatever
#
#   changed +check mail to tell you how many unread messages you have
#   and also to warn you if a mail message is in progress.
#
#   Also added '--' as an alias for +send.
#
#   Also changed the behavior for a +read with no parameters to do basically
#   the same thing as a +check mail
#
#   Restructured +mail a little so it has the same number of switches before
#   attempting to get the semaphore as '-' and '+send'. This allows attributes
#   on players to include code which does things like 
#   +mail brandy; -stuff; +send
#
###############################################################################
# Version 2 updates:
#
#   +unread <num>, +unread<num> or +unread all
#
#   +cc <list of people>
#   +edit cc=<old text>/<new text>
#
#   +add personal alias <alias>=<list of people>
#   +remove personal alias <alias>
#   +list personal aliases
#   +expand personal alias <alias>
#
#   +add global alias <alias>=<list of people>
#   +remove global alias <alias>
#   +list global aliases
#   +expand global alias <alias>
#
#   changed +mail configuration to show number of global mail aliases
#   changed +mail status for <name> to show number of personal mail aliases
#
#   Modified and enhanced the verbose/terse messages
#
#   added +mail credits
#
#   Some bug fixes and help text improvements (some of which were
#   provided by Zalcor of Singlenesia)
#
#   +reply no longer keeps putting yet another Re: if there is already one
#   there, same thing for +forward.
#
#   added .signature capability. Users that wishes to have a .sig automatically
#     put at the end of their +mail messages, should set whatever .sig they
#     want in an attribute called MAIL_SIG on themselves.
#     example:  &MAIL_SIG me=--%rObligatory cute .sig here
#   (note to admin, you might need to muss about with @attribute permissions
#   on that attribute - also, if this feature is undesired, it is very easy
#   to rip out, just zap a couple lines in &send_command)
#
#   Some performance related changes.
#   (did some munging around with complicating the existing @swi statements
#   to allow me to somewhat reduce some of the nesting levels)
#
###############################################################################
#
# Version 1 - Original Release
#
###############################################################################


#
# At the end here is code to support a +help system.
#
# Since lots of games have their own code to do this, this code is 
# commented out, feel free to use or not use at your discretion.

-
# &HELP_COMMAND #300=
# 
#  $+help *: 
#
#    @pemit %# = 
#
#      [setq(0, sort(iter(lattr(#13/HELP_*), rest(##, _)), a))]
#      [setq(1, match(%q0, [edit(%0, %b, _)]*))]
#
#    switch(
#      %q1, 
#        0, No such global help topic '%0'., 
#
#      {
#        [u(equal_line)]
#        %rHelp text for global function 
#           +[lcstr(edit(extract(%q0, %q1, 1), _, %b))]:
#        %r[u(dash_line)]
#
#        %r%r[u(#13/HELP_[extract(%q0, %q1, 1)], %#)]
# 
#        %r%r[u(equal_line)]
#      }
#
#    )
#
-

#
# Show the installer what the current +mail configuration is.
#

  +mail configuration

-
#
# Do certain checks to verify that the configuration is correct
#

  +verify mail config

-
