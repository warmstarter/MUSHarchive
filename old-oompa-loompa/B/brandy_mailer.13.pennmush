#
# BrandyMailer - Ported to PennMUSH by Javelin 9/7/98
#
# Changes from the original file are marked with "JAVELIN". Otherwise,
# just follow Brandy's instructions below. Very little required changing.
# A copy of amolitor_mush_unformatter.c is also available at 
#  ftp://ftp.pennmush.org/pub/PennMUSH/Accessories
#
# See also, at this directory: TBmE4P-1.0.0.txt
# which is brandy-similar mailer written from scratch that uses @mail
# as its transport.
#
###############################################################################
#                                            code written by Brandy@CrystalMUSH
#                                        for MUSH 2.0.10 patch level 5 or later
# Notes on the formating of this file:                                         
#  - is used to separate attributes
#  # in the first column means a comment
#  all leading blanks should be stripped, but tailing ones should not
#
# This +mail code is available via anonymous FTP from
# caisr2.caisr.cwru.edu (129.22.24.22) in file:
#   /pub/mush/mushcode/brandy_mailer.13
#
# A tool that parses this format is available in the same directory in file:
#   amolitor_mush_unformatter.c
#
# Questions/Problems/Requests go to cag@empros.com
#
# If you have any trouble installing it, feel free to contact me and I'll
# do it for you.  It typically takes me 15 mins to a 1/2 hour for a first 
# time installation.
#
# Carol 
# a.k.a Brandy@CrystalMUSH
#
# CAUTION:  This version is incompatible with previous versions of
# this mailer.  I do have a tool which may be used to convert 'old style'
# mailboxes to the new format, if you want a copy of that, send me
# some email (cag@empros.com).  You can also request that I do the
# upgrade and convert if you want.  The incompatibility was 
# unavoidable due to the completely changed nature of how messages
# are saved (which is now more DB friendly).  Another option, is to 
# just chuck the old mailboxes.
#
# MAILING LIST:
#
# To be kept abreast of patches and upgrades, or if you just want to 
# make comments/suggestions whatever, subscribe to brandy-mail@lupine.org 
# by sending an email message to listserv@lupine.org, with 
# 'subscribe brandy-mail MyNameHere' in the body of the mail message.
#
# Or send me email at cag@empros.com
#
###############################################################################
# Things that still need to be done in the future: 
#
# use %q<number> instead of r(<number>), 2.10.6 or later
#
###############################################################################
#
# CHANGES SINCE THE LAST DISTRIBUTION:
#
#   fixed bug in +set mail default separator
#   show 'a' for mailboxes with autoforward set in +mail status
#   added mail_folders and mail5 to global_commands
#
###############################################################################
#
# Version 13
#
# General:
#   o  changed code to only store a single copy of all letters, no matter
#        how wide the distribution 
#   o  expanded usage of setq()/r() including removal of ALL temp variable 
#        usage
#   o  restructured things, one new object, three obsolete (and can be 
#        deleted objects)
#   o  performance should be dramatically improved
#
# Added code to support folders, new commands:
#
#   o  +add folder <folder name>
#   o  +remove folder <folder name>
#   o  +list folders
#   o  +move <letter> to <folder>
#   o  +select folder <folder name>
#   o  +add filter author|subject=<name or text> folder=<folder name>
#   o  +remove filter <number>
#   o  +list filters
#
#   updated all commands to work off of current_folder (default is the 
#   inbox 'main' if not otherwise specified)
#
# Misc tweaks the user's may notice:
#   o  Allow autoforward to be a list of people and/or aliases
#   o  show total messages on +read, i.e., Message:  4/23 
#   o  +edit cc, +edit bcc, +edit to, +edit subject, +edit personal alias
#        and +edit global alias now check to see if the text of what you 
#        want to change is actually there.  It also shows you the final
#        result of the edit upon completion (for aliases, others did that
#        before). 
#   o  +skim now shows a 'n' next to messages that have a note registered
#   o  allow +add note=<text> to add note to current letter
#   o  options shown after a +read now include +move and +save
#   o  +expand personal alias and +expand global alias displays are
#        slightly easier to read ('specially if folks have blanks in 
#        their names)
#   o  +set mail option separator = space or return 
#   o  +set mail option inbox = <folder nam>                         
#   o  +set mail option vacation=<text>
#   o  +set mail option reject=<text>
#   o  +show mail options now shows value for 'separator' option
#   o  +show mail options now shows value for 'inbox' option
#   o  +show mail options now shows list of personal aliases
#   o  +show mail options now shows list of folders
#   o  +show mail options now shows count of filters
#   o  +show mail options now shows vacation text
#   o  +show mail options now shows reject text
#   o  +note <text> command added 
#   o  allow author:<name>, subject:<text>, text:<text fragment> to be 
#        used as keywords
#   o  allow +forward <people>=<letter> in addition to the normal +forward cmd.
#        this form allows you to add additional text via '-<text>' before
#        sending.
#   o  Replaced '+review letter to <person>' with
#      '+review [<list of numbers or keyword>]'
#      +review w/no parameter shows one summary line per sent letter
#      keywords allowed:  all, current, first, last, next, previous, 
#        to:<player>, subject:<text>, text:<text fragment>
#   o  Replaced '+retract letter to <person>' with
#      '+retract <letter number or keyword>'
#      keywords allowed:  first, next, previous, last, current
#
# Misc tweaks admin's may notice:
#   o  automatically destroy mailboxes for dest'ed players during
#        periodic mail timeout code
#   o  created command to allow admin to specify when periodic letter purge
#        should run, default is Wednesdays at 4 AM
#        ( format:  +set mail default purge=<day of week> <hour>:<minute> )
#   o  created command to allow admin to enable or disable the +save
#        command for all users. 
#        ( format:  +set mail default save = enabled | disabled )
#   o  +set mail default separator = space | return
#   o  +mail configuration changes:
#        shows the default for the 'separator' option
#        shows when the next letter/mailbox purge is scheduled
#        shows how many attributes are being used to hold the list of mailboxes
#        shows the configured text for: delivery_notification, 
#          pickup_notification, forward_notification, text_added_notification
#        does some verification that things were set up right and warns if not.
#   o  +mail status changes:
#        shows number of defined folders 
#        shows number of defined filters 
#        shows number of sent messages still stored (not deleted by recipient)
#   o  +mail status for <player> changes:
#        shows list of personal aliases defined
#        shows total and list of folders defined
#        shows current folder
#        shows current letter for the selected folder
#        shows total of sent messages still stored (not deleted)
#        shows inbox folder name
#        shows number of filters
#   o  automatically do a +mail configuration at the end of installation
#
# Bug fixes:
#   o  fixed bug - +replyall needs to include the sender as well
#   o  made the code more accurate about overflowing letter size
#   o  fixed semaphore not being notified in +add global alias and 
#        +edit global alias end cases.
#   o  fixed bug in the purge old letters code that resulted in an 
#        infinite loop
#
###############################################################################
#
# The following are the mapping of dbref to object in this file.
# 
#    #3478 - Mail System                     
#     #3479 - Wiz-Inherit Object         
#      #3480 - Master Mailbox                  
#     #3481 - Help Text 
#   #3482 - Parent Mail Object   
#
# !!! NOTE:  IMPORTANT!  FOR FOLKS INSTALLING OVER AN EXISTING SYSTEM !!!
#
#   The Parent Mail Object is NEW for this release.  You need to: 
#
#     @create Parent Mail Object 
#     @parent Mail System = Parent Mail Object
#
#   The following objects are no longer needed with this release:
#
#     @destroy Cleanup Module
#     @destroy Generic Mailbox
#     @destroy Generic Info Record
#
# Throughout this file, you'll see lots of attributes getting set to
# nothing.  This is done to remove attributes off the mail system that 
# are not commands, putting them on the (new) parent object for the mail
# system since parent of objects in the master room are not searched
# for commands (thanks to Amberyl for pointing this out).
#
# To modify this file for use on another MUSH, basically, 5 vi commands 
# must be used to change the dbrefs to the ones for the matching objects
# on the MUSH this is being installed on.  Then run it through Andrew 
# Molitor's MUSH code unformatter.  It is then ready for quoting in via 
# tf or whatever.  (For first time installations, see instructions below).
#
#    (brief instructions)
#    create the objects needed 
#    edit brandy_mailer.13 to reference the relevant dbrefs
#    compile the unformatter:         cc amolitor_mush_unformatter.c
#    then run the mailer through it:  a.out brandy_mailer.13 >mailer
#    and install via tf:              /quote 'mailer
#
#   (vi commands to change dbrefs through the file)
#
#   :1,$s/#3478/<the dbref on your MUSH for the mail system object>/g
#   :1,$s/#3479/<the dbref on your MUSH for the wiz-inherit object>/g
#   :1,$s/#3480/<the dbref on your MUSH for the master mailbox object>/g
#   :1,$s/#3481/<the dbref on your MUSH for the help text object>/g
#   :1,$s/#3482/<the dbref on your MUSH for the parent mail object>/g
#
# NOTE:
#
#   The personal mail option commands won't work on #1, since there
#   are permission problems with setting attributes on 'god'.  If
#   'god' is so inclined to use +mail and wants personal options
#   set, s/he will need to set the &mail_config_options attribute
#   on him/herself.
#
###############################################################################
#
# For those installing it for the first time....
#
# @create Mail System (must reside in the master room)
# @create Wiz-Inherit Object 
#   (Note: must reside in the master room, this object holds the few mail 
#    commands that need wiz powers)
# @create Master Mailbox
# @create Help Text
# @create Parent Mail Object
#
# @parent Mail System = Parent Mail Object
#
# @set Wiz-Inherit Object=inherit 
#   (Note: the other objects need not and indeed
#   should not be set inherit)
#
# JAVELIN: @set wiz-inherit object=!no_command
# JAVELIN: @set wiz-inherit object=!inherit
# JAVELIN: @set wiz-inherit object=wizard
# JAVELIN: @set mail system = !no_command
#
# &mail_config_options me=soft
# &mail_config_options me=
# ^_____(just to get that attribute in the list of user attributes)
#
# &mail_sig me=something
# &mail_sig me=
# ^_____(just to get that attribute in the list of user attributes)
#
# @attribute/access mail_config_options=wizard (must be done by god(#1))
# @attribute/access mail_config_options=!private (must be done by god(#1))
# @attribute/access mail_sig=!private (must be done by god(#1))
#
# JAVELIN: Instead of the above, add these to God's @startup:
#   @attribute/access mail_config_options=wizard visual
#   @attribute/access mail_sig=visual
#
# The Mail System object and the Wiz-Inherit Object must reside
# in the Master Room.  The remaining objects should not be in the
# master room.  Just stick them in a bag somewhere and forget about them. ;)
#
# CAUTION:  In order for the +mailer to work, space compression
# MUST be turned on (@admin space_compress=yes).  This shouldn't
# present a problem since most (all?) MUSHes run this way.
#
# JAVELIN: All PennMUSHes always have space compression, so no @admin
#   command is needed
#
-
#
# Set the MAILBOXES_NUM_OF_ATTRIBUTEs, only if not previously set by
# a prior installation.
#

@switch words(get(#3480/mailboxes_num_of_attributes))=0,
  &mailboxes_num_of_attributes #3480=1

-
###############################################################################
#
# Data Structures:
#
#  owner_dbref                dbref of who's mailbox this is
#  autoforward                list of players/aliases to autoforward mail to
#  message_timeout            number of seconds (in day multiples) before 
#                             mail will be automatically timed out and deleted.
#  alias-list                 list of personal mail aliases
#  folder-list                list of folder names           
#  out-list                   list of sent letters that have not been deleted
#  out-list-current           current letter of out list (used in +review)
#  current_folder             current folder (default is inbox)
#  mail-in-progress           boolean indicating if mail message in progress
#  author_filter              dbref|folder~dbref|folder~dbref|folder
#  subject_filter             text|folder~text|folder~text|folder
#  vacation                   if set, all incoming mail is stored, but
#                             this text is sent to originator 
#  reject_msg                 if set, all incoming mail is rejected, and
#                             this text is sent to originator
#  
# per personal distribution list (alias)
#
#   alias-<alias name>        list of dbrefs and/or alias names
#
# per folder
#
#   in-list-<folder>          list of messages in folder
#   current_letter-<folder>   current letter
#
# per mail sent item:
# 
#   out-<num>-time_sent       date/time mail was sent
#   out-<num>-subject         subject of letter (only for 'old' mail)
#   out-<num>-to              TO:    (prettified)
#   out-<num>-cc              CC:    (prettified)
#   out-<num>-bcc             BCC:   (prettified, used in +review)
#   out-<num>-bcc-expanded    dbrefs (used for +read)
#   out-<num>-text            body of mail message
#   out-<num>-replyall_to     sender, to expanded & cc expanded
#   out-<num>-dist            complete distribution list 
#                               <dbref>:<internal # in their mailbox>
#   out-<num>-held            list of who still has a pointer to this letter
#
# per mail received item:
# 
#   in-<num>-time_read        date/time mail was last read
#   in-<num>-flags            U R RR P D M S A<dbref>AEND
#   in-<num>-note             registered via +add note
#   in-<num>-location         <dbref> <number> where letter is stored
#
# Note: each player has a mailbox.  On the Master Mailbox, there is an 
# attribute per player of the format &mailbox_<player dbref> which is 
# set to the dbref of their mailbox.
#
###############################################################################
#
# Several people have asked me about the capability to automatically 
# generate +mail during the processing of a command.  This is easily
# done.  The key points to remember are:
#
#   Only Players can use the +mail system, therefore, the code that actually
#   composes and sends the mail will need to be on a Player character.
#
#   The object that does the trigger on the Player character, will either
#   need to be owned by that same player, or it will need to be wiz-owned.
#   It will also have to be set inherit.
#
#   The Player that has the attribute which composes mail will need to 
#   have a permanent mailbox.  There are several ways to accomplish this, 
#   probably the easiest way is to have that player define a personal
#   mail alias.  Mailboxes with personal mail aliases defined do not
#   get automatically deleted when empty.
#
#   Example:
#
#   &wage_command Money System = 
#
#     $+wage *=* reason=*:
#
#       <handle parameter checking and actual wage deposit code deleted>
#
#       @trigger v(ballybran)/wage_notification=
#         %#, 
#         <dbref of who is being paid the wage>,
#         <amount of wage deposited in account>,
#         <reason the wage is being paid>
#
#     (where v(ballybran) holds the dbref of a Player Character and
#      attribute wage_notification holds the code that actually
#      composes and sends the +mail)
#
#   &wage_notification *Ballybran = 
#
#         In this example:
#
#         %0 - dbref of the invoker of the command
#         %1 - dbref of who mail is being sent to
#         %2 - amount of money that %1 received
#         %3 - reason why %0 deposited money in %1's account
#
#    +mail [name(%1)]=Notification of deposit of wage;
#    -[name(%0)] has deposited %2 credits into your account.;
#    -%r%rReason Specified:%b%b%3;
#    --
#
###############################################################################
#
#                  Administrative Configurable Attributes
#
# Feel free to change as desired before installation, or use the provided
# admin commands to change them on the fly later.
#
###############################################################################

#
# This is the mail system-wide default for the 'delete' option.  There is 
# a wiz-only command '+set mail default delete = hard | soft' to change this 
# and each user may set their own personal default by using command 
# '+set mail option delete = hard | soft'.  Soft deleted messages are just
# marked for deletion and are not actually deleted until a +flush is done.
# They can be recovered by using a +undelete.  Hard deleted messages are
# deleted immediately.
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make 
# upgrades easier for the installer.
#

@switch words(get(#3480/DEFAULT_DELETE_OPTION))=0,
  &DEFAULT_DELETE_OPTION #3480=soft

-
#
# This is the mail system-wide default for the 'mode' option.  There is 
# a wiz-only command '+set mail default mode = terse | verbose' to change 
# this and each user may set their own personal default by using command 
# '+set mail option mode = terse | verbose'.  Verbose mode gives you more 
# information on options while writing mail messages.  Terse mode is for 
# when you are familiar with the mail system.
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make 
# upgrades easier for the installer.
#

@switch words(get(#3480/DEFAULT_MODE_OPTION))=0,
  &DEFAULT_MODE_OPTION #3480=verbose

-
#
# This is the mail system-wide default for if mailboxes should be 
# automatically deleted when empty.  This may be changed by wiz-only
# command:  '+set mail option destroy = yes | no | true | false | on | off'.
#
# 1 - true,  mailboxes are deleted
# 0 - false, mailboxes are not deleted 
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make 
# upgrades easier for the installer.
#

@switch words(get(#3480/DELETE_WHEN_EMPTY))=0,
  &DELETE_WHEN_EMPTY #3480=1

-
#
# This is the mail system-wide default for the 'timeout' option.  There is 
# a wiz-only command '+set mail default timeout = <number of days>' to set 
# this.  Wizards may also set a default for an individual mailbox by using 
# the '+set mail option timeout = <number of days> for <name>' command.
#
# Letters that haven't been read within the timeout value span, will be
# automatically deleted.  To further clarify this:   It deletes already-read
# mail that has not been read within the option-set time limit and it also
# deletes mail that has not been read, but was received longer than the
# option-set time limit ago.  If this results in an empty mailbox, the
# mailbox will also be deleted.  Halfway to the timeout value, a
# letter will show up with a 'T' next to it on a +skim to indicate
# it is 1/2 way to the time when it would be deleted.  Simply
# +read'ing the mail again will remove the 'T'.
#
# Users may '+save' letters that they don't want to be timed out.  
# Hopefully, this will be used sparingly.  I didn't particularly
# want to add it, but the user base asked for it, I can see the 
# usefulness of it and Joe Average +mail user likely won't notice 
# the capability is there. ;)
#
# The value is specified in number of days on the commands, but 
# stored in seconds.
#
# Default value is 2 weeks == 1209600 seconds.  
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make
# upgrades easier for the installer.
#

@switch words(get(#3480/DEFAULT_TIMEOUT_OPTION))=0,
  &DEFAULT_TIMEOUT_OPTION #3480 = 1209600

-
#
# This is the default day of week and time that the periodic letter
# purge will take place.  This value can be changed by admins via
# the '+set mail default purge=<day of week> <hour>:<minute>' 
# It should be set for a day and time that you think the MUSH 
# will be the most idle.  It will take effect the next time 
# the @startup is run on the Master Mailbox.
#
#   <day of week> <hour>:<minute>
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make
# upgrades easier for the installer.
#

@switch words(get(#3480/DEFAULT_PURGE_TIME))=0,
  &DEFAULT_PURGE_TIME #3480 = Wednesday 04:00

-
#
# This is the mail system-wide default for the 'format' option.  There is 
# a wiz-only command '+set mail default format = standard | compact' to 
# change this and each user may set their own personal default by using 
# command '+set mail option format = standard | compact'.  'compact' mode 
# gives you the same information that 'standard' mode gives you, but 
# without the formatting lines and extra white-space.
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make
# upgrades easier for the installer.
#

@switch words(get(#3480/DEFAULT_FORMAT_OPTION))=0,
  &DEFAULT_FORMAT_OPTION #3480=standard

-
#
# This is attribute specifies whether the +save command is enabled
# or disabled for the mail system as a whole.  There is a wiz-only
# command '+set mail default save = enabled | disabled' to change
# this.  This cannot be set for individual mailboxes, although 
# the timeout mechanism can be disabled for a specific mailbox.
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make
# upgrades easier for the installer.
#

@switch words(get(#3480/DEFAULT_SAVE_OPTION))=0,
  &DEFAULT_SAVE_OPTION #3480=enabled

-
#
# This is the mail system-wide default for the 'separator' option.  There is
# a wiz-only command '+set mail default separator = space | return' to change
# this and each user may set their own personal default by using command
# '+set mail option separator = space | return'.  'space' means that there is 
# a space inserted between text entered with multiple '-<text>' commands.
# A 'return' means that there is a carriage return inserted.
#
# The current value of this is shown in +mail configuration.
#
# Only set if not already set from a previous release, this is to make
# upgrades easier for the installer.
#

@switch words(get(#3480/DEFAULT_SEPARATOR_OPTION))=0,
  &DEFAULT_SEPARATOR_OPTION #3480=space

-

&DELIVERY_NOTIFICATION #3478=
-
&DELIVERY_NOTIFICATION #3482=
#
# This is the message which is pemitted to the person who is receiving a 
# new mail message.  Feel free to customize as desired.
#
# Note, this is evaluated, so you can put code in there.  For example:
# 
#   [switch(rand(3), 0, message0, 1, message1, 2, message2)]
#
# Input:
#
# %0 - dbref of who the mail is from
# %1 - urgent flag set? (1 - yes, 0 - no)
# %2 - private flag set? (1 - yes, 0 - no)
# %3 - reply requested flag set? (1 - yes, 0 - no)
# %4 - registered flag set? (1 - yes, 0 - no)
# %5 - folder that letter was stored into
#

  A light blinks on your wrist unit indicating that a new message has been 
  received from [name(%0)] in folder '%5'
  [switch(
    or(%1, %2, %3, %4), 
    1, 
    {
      %b(
      [switch(%1, 1, %b[v(mail_flag_u)])]
      [switch(%2, 1, %b[v(mail_flag_p)])]
      [switch(%3, 1, %b[v(mail_flag_rr)])]
      [switch(%4, 1, %b[v(mail_flag_r)])]
      %b).
    }, 
    .
  )]

-
&PICKUP_NOTIFICATION #3478=
-
&PICKUP_NOTIFICATION #3482=
#
# This is the message which is pemitted to the person who is sending a
# mail message.  Feel free to customize as desired.  Yes, it is evaluated
# so code can be put in there.
#

  The mail has been sent.

-
&FORWARD_NOTIFICATION #3478=
-
&FORWARD_NOTIFICATION #3482=
#
# This is the message which is pemitted to the person who is forwarding a
# mail message.  Feel free to customize as desired.  Yes, it is evaluated
# so code can be put in there.
#
# %0 - active folder
# %1 - user request
#

  Letter %1 in folder '%0' has been forwarded.

-
&TEXT_ADDED_NOTIFICATION #3478 = 
-
&TEXT_ADDED_NOTIFICATION #3482 = 
#
# This is used when a '-<text to add to letter>' command is successfully
# completed.  I know The Way It's Always Been is to not give a prompt,
# but I thought it would be nice to get a response to the command; it
# occasionally freaks me out when I don't.  Feel free to zap this 
# attribute, of course, if y'all'd prefer not having the prompt.  
# That's why it is in its own attribute. :)
#

  Text added.

-

###############################################################################
#
# Miscellaneous attributes:
#
###############################################################################

&MAIL_VERSION #3478=
-
&MAIL_VERSION #3482=Fri Jun 17, 1994
-
&MASTER_MAILBOX #3478=
-
@VM #3482 = #3480
-
&MASTER_MAILBOX #3479=
-
@VM #3479 = #3480
-
&CLEANUP_MODULE #3478=
-
&CLEANUP_MODULE #3482=
-
&CLEANUP_MODULE #3479=
-
&CLEANUP_MODULE #3480=
-
&MAIL_SYSTEM #3480=#3478
-
&MAIL_SYSTEM #3478=
-
&MAIL_SYSTEM #3482=#3478
-
&MAIL_SYSTEM #3479=#3478
-
@drain #3480
-
@no #3480
-
&EQUAL_LINE #3478=
-
&EQUAL_LINE #3482=repeat(=, 78)
-
&DASH_LINE #3478=
-
&DASH_LINE #3482=repeat(-, 78)
-
#
# Text associated with the various mail flags.  You can change them here
# if you wish.  Putting in commas is not advised.
#

&MAIL_FLAG_RR #3478=
-
&MAIL_FLAG_RR #3482=REPLY REQUESTED
-
&MAIL_FLAG_P #3478=
-
&MAIL_FLAG_P #3482=PRIVATE
-
&MAIL_FLAG_U #3478=
-
&MAIL_FLAG_U #3482=URGENT
-
&MAIL_FLAG_R #3478=
-
&MAIL_FLAG_R #3482=REGISTERED
-
&MAIL_FLAG_D #3478=
-
&MAIL_FLAG_D #3482=MARKED FOR DELETION
-
&MAIL_FLAG_T #3478=
-
&MAIL_FLAG_T #3482=TIMEOUT WARNING    
-
&MAIL_FLAG_S #3478=
-
&MAIL_FLAG_S #3482=SAVED 
-
&MAIL_FLAG_M #3478=
-
&MAIL_FLAG_M #3482=MARKED 
-

&SECONDS_IN_DAY #3478 =
-
&SECONDS_IN_DAY #3482 = 86400
-
&SECONDS_IN_DAY #3479 = 86400
-
&ENTER_MSG_VERBOSE #3478=
-
&ENTER_MSG_VERBOSE #3482=

  You may now enter the body of the message.%b This is done by doing a 
  '-<message text>' as many times as desired.%b Once you have completed%b
  entering the message, simply enter a '--' (or +send).%b To see more options,%b
  type a '-' with no text afterwards.
-
&ENTER_MSG_TERSE #3478=
-
&ENTER_MSG_TERSE #3482=

  You may now enter the body of the message.%b%bFinish with a '--'.
  %rTo see more options, type a '-' with no text afterwards.

-
&FINISH_MSG_VERBOSE #3478=
-
&FINISH_MSG_VERBOSE #3482=

 Options:  +proof, +send, +toss, +cc <list of people>, +bcc <list of people>,
 %r+edit <mail part>=<old>/<new> (where mail part=to, cc, bcc, subject or 
 text), 
 %r+set mail flag \[!\]<flag> (where flag=urgent (u), private (p), 
 registered (r) or reply requested (rr))

-
&FINISH_MSG_TERSE #3478=
-
&FINISH_MSG_TERSE #3482=

  Options: %b+proof, +send, +toss, +cc, +bcc, +edit <part>=<old>/<new> or  
  +set mail flag \[!\]<flag>

-
&NOMAIL #3478=
-
&NOMAIL #3482=

  There is no mail in folder '[secure(%0)]'.

-
&NO_SENT_MAIL #3482 = 
  
  There is no mail from you remaining in the mail system.

-
&NOFUNC #3478=
-
&NOFUNC #3482=

  I'm sorry, but function calls are not allowed within an input parameter.

-
&NOT_PLAYER #3482 = 

  You must be a player to use the mail system.

-
&NOT_WRITING_MAIL #3482 = 

  There is not a mail message in progress.

-
&NO_MATCH #3482 = 

  %0:%b%bNo letter matches the specified criteria%1 in folder '%2'.

-
&NO_MAIL_FROM_YOU #3482 = 

  There is no mail from you in %0's mailbox.

-
&overflow_point #3480=
#
# This number represent the bytesize (strlen) that a mailboxes_<num>
# can reach before the list of mailbox dbrefs will overflow into the
# next attribute, mailboxes_<num + 1>
#
# Normally set to 3900, just to be safe. This is in an attribute
# exclusively for the reason of ease of testing the overflow code.
#

3900

-
###############################################################################
#
# READ related commands:
#
###############################################################################


###############################################################################
#
#                           C H E C K   M A I L
#
###############################################################################
&CHECK_MAIL_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to check to see if there is any unread
#   mail in selected folder of the user's mailbox.  If there is unread 
#   mail, the user is notified of how many unread messages there are 
#   in addition to the total number of letters in the folder.
#
# Command Format:
#
#   +check mail
#
# NOTE:
#
#   A warning is also displayed if the user's 'mail-in-progress' flag
#   is set.
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in current folder
#   2 - name of active folder
#   3 - count of unread letters in current folder
#

  $+check mail: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(r(0)),
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#
      @wait r(0) = 
      {

        @pemit %# = 

           [setq(1, u(get_folder_in_list, r(0)))]
           [setq(2, u(get_active_folder, r(0)))]
           [setq(3, 
             switch(strlen(r(1)), 0, 0, words(filter(mail_not_read, r(1))))
           )]

          [switch([strlen(r(1))]+[r(3)], 
            0+*, 
              u(nomail, r(2)), 

            *+0,
              You do not have unread mail in your '[r(2)]' mail folder., 

            You have [r(3)] unread mail message(s) out of a total of 
              [words(r(1))] in your '[r(2)]' mail folder.
          )]

          [switch(get(r(0)/mail-in-progress),
            true, %b%b(Warning:%b Your mail in progress flag is set)
          )];  

         @no r(0)
      }
    }

-
&MAIL_NOT_READ #3482 = 

#
# This helper function is used while processing a filter() on a list
# of letters in a mailbox.  Requirements:  return 1 if the letter
# in question has not been read, return 0 otherwise.  Mail that has
# not been read has a time_read field of zero.
#
# %0 - internal mail number
#
# Assumption:
#
#   r(0) - mailbox dbref
#

  strmatch(get(r(0)/in-%0-time_read), 0)

-
###############################################################################
#
#                              S K I M
#
###############################################################################
&SKIM_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to show summary information about mail
#   in selected folder of the user's mailbox.  
#
# Command Format:
#
#   +skim [keyword or letter number]
#
#   The following keywords may be used to limit the output of +skim:
#
#     all (default), current, deleted, first, last, marked, next, previous, 
#     saved, unread author:<name>, subject:<text>, text:<text fragment>
#
#     only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in current folder
#   2 - current letter in active folder
#   3 - user's timeout value                       
#   4 - list of internal letters which match the user specified criteria
#   9 - user's format option
#
#   skim_bulk reuses 4, and also uses 5-8
#

  $+skim*: 

    @swi/first 

       [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *\[*)),
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(get_folder_in_list, r(0)))]
          [setq(2, u(get_folder_current_letter, r(0)))]
          [setq(3, u(grab_timeout_value, get(r(0)/message_timeout), 
            get(%vm/default_timeout_option))
          )]

#
# register 9 is used to hold the format option so as not to interfere
# with registers used in skim_bulk.
#

          [setq(9, u(get_format_option, get(%#/mail_config_options)))]

        1 = eq(strlen(r(1)), 0), 
        {
#
# There is no mail in the mailbox.  Notify the user and release the semaphore.
#

          @pemit %# = [u(nomail, u(get_active_folder, r(0)))]
            [switch(get(r(0)/mail-in-progress), true,
            %b(Warning:%b Your mail in progress flag is set))];  

          @no r(0)
        },

        eq(strlen(%0), 0),
        {
#
# +skim specified with no params and there IS mail is in the mailbox.
# Simulate the user specifying all letters
#

          @pemit %# = 
            [switch(r(9), standard,
              {[u(equal_line)]%r%r[space(27)]List of Mail Messages%r%r}
            )]
            [space(9)]Sender[space(12)]Subject[space(22)]Size%b%bReceived
            %r[space(9)]------[space(12)]-------[space(22)]----%b%b--------;  

          @dolist r(1) =
          {
            @pemit %# = u(skim_bulk, 
                %#, 
                ##, 
                r(0), 
                r(1), 
                r(2), 
                r(3), 
                u(get_src_dbref, r(0), ##), 
                u(get_src_num, r(0), ##))
          };

          @swi 1 = 1,
          {
#
# Finished showing information about the letter(s) specified. 
# Show the user what the active folder is and release the semaphore.
#
            @pemit %# =

                 [setq(1, u(get_active_folder, r(0)))]
                 [setq(2, s(remove(get(r(0)/folder-list), edit(r(1), %b, $))))]

               %rSelected folder:%b%b[r(1)]
               [switch(strlen(r(2)), 0,, 
               %rOther folders:%b%b[u(secure_names, r(2))])]
               [switch(r(9), standard,%r%r[u(equal_line)])]; 

            @no r(0)
          }
        },

        {
#
# User specified a parameter.
#

#
# Interpret user input and convert into a list of internal mail numbers
#

          @swi/first 

            [setq(4, 
              u(expand_letter_range, %0, r(1), 
                u(get_folder_current_letter, r(0)))
            )]

          1 = strmatch(r(4), *ABORT*),
          {
#
# Error detected in input parameter.  Notify the user and release the semaphore.
#

            @pemit %# = after(before(r(4), ENDABORT), ABORT);  
            @no r(0)
          },

          eq(strlen(r(4)), 0),
          {
#
# Could not find any letters to match the specified input parameter.
# Notify the user and release the semaphore.
#

            @pemit %# = u(no_match, +skim, u(format_request, trim(%0)), 
              u(get_active_folder, r(0))); 
            @no r(0)
          },

          {
#
# Otherwise, no error and one or more letters match the input criteria.
#

            @pemit %# = 
              [switch(r(9), standard,
                {[u(equal_line)]
                %r%r[space(27)]List of Mail Messages%r%r}
              )]
              [space(9)]Sender[space(12)]Subject[space(22)]Size%b%bReceived
              %r[space(9)]------[space(12)]-------[space(22)]----%b%b--------;  

            @dolist 

#
# Reorder the list of letters to 'skim' into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
              [setq(4, u(filter_list, setunion(r(4), ), r(1)))]

            r(4) = 
            {
#
# Display information to user about one letter
# 
              @pemit %# = u(skim_bulk, 
                %#, 
                ##, 
                r(0), 
                r(1), 
                r(2), 
                r(3), 
                u(get_src_dbref, r(0), ##), 
                u(get_src_num, r(0), ##))
            };

            @swi 1 = 1,
            {
#
# Finished showing information about the letter(s) specified. 
# Show the user what the active folder is and release the semaphore.
#

              @pemit %# = 

                 [setq(1, u(get_active_folder, r(0)))]
                 [setq(2, s(remove(get(r(0)/folder-list), edit(r(1), %b, $))))]

               %rSelected folder:%b%b[r(1)]
               [switch(strlen(r(2)), 0,, 
               %rOther folders:%b%b[u(secure_names, r(2))])]
               [switch(r(9), standard,%r%r[u(equal_line)])]; 
              @no r(0)
            }
          }
        }
      }
    }

-
&SKIM_BULK #3478=
-
&SKIM_BULK #3482=
#
# PURPOSE:
#
#   Obtain summary information for one letter in a mailbox.
#   (This is a helper routine for +skim)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - internal mail message number of letter to obtain information about
#   %2 - dbref of mailbox
#   %3 - list of letters in folder
#   %4 - current letter in active folder
#   %5 - user's timeout value
#   %6 - dbref of where letter is stored
#   %7 - internal mail message where letter is stored
#
# OUTPUT
#
#   A single line of information for the letter specified in %1
#
# Don't stomp on registers 0, 1, 2, 3 or 9, they are used in skim_command
# Note:  registers 4, 7 and 8 are also used in skim_command but may be 
# stomped on.
#
# Registers Used:
#
#   4 - flags for one letter
#   5 - external letter number
#   6 - name of sender                  
#   7 - subject of letter                          
#   8 - time the letter was read
#

  [setq(4, get(%2/in-%1-flags))]
  [setq(5, member(%3, %1))]
  [setq(6, get(%6/out-%7-sender))]
  [setq(6, switch(words(r(6)), 0, get(%6/owner_dbref), r(6)))]
  [setq(6, switch(type(r(6)), PLAYER, name(r(6)), destroyed player))]
  [setq(7, trim(get(%6/out-%7-subject)))]
  [setq(8, get(%2/in-%1-time_read))]

#
# a '+' is shown before the summary line that represents the current letter
#
  [switch(%1, %4, +, %b)]

#
# a 'M' is shown if the letter is marked (via +mark)
# a 'D' is shown if the letter is marked for deletion (via +delete),
# a 'S' is shown if the letter is marked as 'saved' (via +save)
# a 'T' is shown if the letter is close to being timed out
# A 'U' is shown if the letter has not been read yet,
# otherwise, just a blank
#
  [switch(
    [gt(match(r(4), m), 0)]+
    [gt(match(r(4), d), 0)]+
    [gt(match(r(4), s), 0)]+
    [r(8)]+
    [gte(sub(secs(), convtime(r(8))), div(%5, 2))]
    , 1+*+*+*+*, M, *+1+*+*+*, D, *+*+1+*+*, S, 0+0+0+0+*, U, 0+0+0+*+1, T, %b
  )]

#
# Show a 'n' if there is a note associated with this letter.
#

  [switch(words(get(%2/in-%1-note)), 0, %b, n)]

#
# The letter number
#
  [rjust([r(5)]\)%b%b, 6)]

#
# The sender of the letter, the name is truncated to sixteen characters
#
  [ljust(mid(r(6), 0, min(16, strlen(r(6)))), 18)]

#
# The subject of the letter, truncated to 27 characters
#
  [ljust(mid(r(7), 0, min(27, strlen(r(7)))), 29)]

#
# Size of the body of the letter, in bytes
#
  [ljust(strlen(u(%6/out-%7-text)), 6)]

#
# Date and time the letter was received
#
  [mid(get(%6/out-%7-time_sent), 0, 16)]

-
###############################################################################
#
#                              R E A D
#
###############################################################################
&READ_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to read one or more mail messages in the 
#   selected folder.
#
# Command Format:
#
#   +read [keyword or letter number]
#
#   The following keywords may be used to limit the output of +read:
#
#     all, current, deleted, first, last, marked, next, previous, saved, unread
#     author:<name>, subject:<text>, text:<text fragment>
#
#     Only the first character of the keyword needs to be specified
#
#   A +read with no parameters is equivalent to a +check mail
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - name of active folder           
#   3 - count of unread messages (if no user parameter specified) otherwise,
#       list of internal mail messages which match user criteria
#   4 - user's timeout value                       
#   9 - user's format option                       
#
#   registers 5 - 8 are used in read_bulk
#

  $+read*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *\[*)),
    {
#
# Function calls are not allowed within an input parameter
#

      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(get_folder_in_list, r(0)))]
          [setq(2, u(get_active_folder, r(0)))]

#
# register 9 is used to hold the format option so as not to interfere
# with registers used in read_bulk.
#

          [setq(9, u(get_format_option, get(%#/mail_config_options)))]

        0 = strlen(r(1)), 
        {
#
# There is no mail in the user's mailbox.  Notify the user
# and release the semaphore.
#

          @pemit %# = [u(nomail, r(2))]
            [switch(get(r(0)/mail-in-progress), true,
            %b(Warning:%b Your mail in progress flag is set))];  

          @no r(0)
        },

        strlen(%0), 
        {
#
# +read specified with no params, do a +check mail instead
# There IS mail in the user's mailbox.
#

          @pemit %# = 

              [setq(3, switch(strlen(r(1)), 0, 0, 
                words(filter(mail_not_read, r(1)))))]

            [switch([strlen(r(1))]+[r(3)], 
              0+*, 
                u(nomail, r(2)), 

              *+0,
                You do not have unread mail in your '[r(2)]' mail folder., 

              You have [r(3)] unread mail message(s) out of a total of 
                [words(r(1))] in your '[r(2)]' mail folder.
            )]

            [switch(get(r(0)/mail-in-progress),
              true, %b%b(Warning:%b Your mail in progress flag is set)
            )];  

           @no r(0)
        },

        {
         
          @swi/first 

#
# Interpret user input and convert into a list of internal mail numbers
# representing the user specified criteria.
#
          [setq(3, 
            u(expand_letter_range,
              %0,
              r(1), 
              u(get_folder_current_letter, r(0))
            )
          )]

          1 = 

          strmatch(r(3), *ABORT*),
          {
#
# Error detected in input parameter.
#
# Notify the user and release the semaphore.
#

            @pemit %# = after(before(r(3), ENDABORT), ABORT);  
            @no r(0)
          },

          eq(strlen(r(3)), 0),
          {
#
# Could not find any letters to match the specified input parameter.
#
# Notify the user and release the semaphore.
#
            @pemit %# = u(no_match, +read, u(format_request, trim(%0)), r(2)); 
            @no r(0)
          },
          {

            @dolist 

#
# Reorder the list of letters to 'read' into the same order as the 
# in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
              [setq(3, u(filter_list, setunion(r(3), ), r(1)))]
              [setq(4, u(grab_timeout_value, get(r(0)/message_timeout), 
                get(%vm/default_timeout_option))
              )]

            r(3) =
            {
#
# Display information to user about one letter
# 
              @pemit %# = u(read_bulk, 
                %#, 
                r(2), 
                ##, 
                r(1), 
                r(9), 
                r(0), 
                r(4), 
                u(get_src_dbref, r(0), ##), 
                u(get_src_num, r(0), ##)); 

              @tr me/check_if_registered = 
                %#, 
                r(0), 
                ##, 
                u(get_src_dbref, r(0), ##), 
                u(get_src_num, r(0), ##)
            }; 

            @swi 1 = 1, 
            {
#
# Set current letter to be the last letter read
#

              &[u(which_current_letter, r(0))] [r(0)] = first(revwords(r(3))); 

#
# Finished showing information about the letter(s) specified.  Release
# the semaphore.  Extra switch is needed to keep the queue accurate.
#
              @swi 1 = 1,
              {
                @no r(0)
              }
            }
          }
        }
      }
    }

-
&READ_BULK #3478=
-
&READ_BULK #3482=
#
# PURPOSE:
#
#   Obtain detailed information for one letter in a mailbox.
#   (This is a helper routine for +read)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - name of active folder
#   %2 - internal mail number of letter to obtain information for
#   %3 - list of letters in active folder
#   %4 - user's format option
#   %5 - dbref of mailbox
#   %6 - user's timeout value
#   %7 - dbref of where letter is stored
#   %8 - internal mail message where letter is stored
#
# OUTPUT
#
#   Detailed display for a single letter
#
# NOTE:  Registers 0, 1, 2, 3, 4 and 9 are set/used in read_command 
#        and shouldn't be stomped on.
#
# Registers Used:
#
#   5 - external letter number
#   6 - cc for one letter               
#   7 - flags for one letter
#   8 - time the letter was read
#

  [setq(5, match(%3, %2))]
  [setq(6, get(%7/out-%8-cc))]
  [setq(7, get(%5/in-%2-flags))]
  [setq(8, get(%5/in-%2-time_read))]

  [switch(%4, standard, {[u(equal_line)]%r})]

#
# Message number
#
  [ljust(Message:%b%b[r(5)]/[words(%3)] in folder %1, 43)]

#
# Date and time received
#
  Received:%b%b[get(%7/out-%8-time_sent)]

#
# Name of sender
#
# (games played here since normally I don't save the 'sender' information
# since it is clear who the sender is by where the mail is stored.  However,
# if the conversion code was used to 'save' mail from older versions, 
# there will be a sender field, which is the only way to determine sender
# at older levels.
#
  %rFrom:[space(5)]

    [switch(words(get(%7/out-%8-sender)), 0, 
      switch(
        type(get(%7/owner_dbref)), PLAYER, 
        name(get(%7/owner_dbref)), destroyed player
      ), 
      switch(
        type(get(%7/out-%8-sender)), PLAYER, 
        name(get(%7/out-%8-sender)), destroyed player
      )
    )]

#
# Who the mail was addressed to
#
  %rTo:[space(7)][trim(get(%7/out-%8-to))]

#
# The CC list 
#
  [switch(words(r(6)), 0,,%rCc:[space(7)][trim(r(6))])]

#
# If the person reading this mail is on the BCC list, show a BCC line
# with just that person's name.  Other people on the BCC list are not
# identified
#
  [switch(
    match(get(%7/out-%8-bcc-expanded), %0),
    0,,
    %rBcc:[space(6)][name(%0)]
  )]

#
# Subject of the letter
#
  %rSubject:%b%b[trim(get(%7/out-%8-subject))]
  [switch(
    r(7), *A*,%b\( autoforwarded from [name(after(before(r(7), AEND), A))] \)
  )]

#
# If any flags are set, display the flags header text
#
  [switch(words(setinter(r(7), RR P U R D T S M)), 0,, %rFlags:%b%b%b%b)]

#
# check for the URGENT (U) flag
#
  [switch(match(r(7), u), 0,, [v(mail_flag_u)]%b%b)]

#
# check for the REQUEST REPLY (RR) flag
#
  [switch(match(r(7), rr), 0,, [v(mail_flag_rr)]%b%b)]

#
# check for the REGISTERED (R) flag
#
  [switch(match(r(7), r), 0,, [v(mail_flag_r)]%b%b)]

#
# check for the PRIVATE (P) flag
#
  [switch(match(r(7), p), 0,, [v(mail_flag_p)]%b%b)]

#
# check for the MARKED FOR DELETION (D) flag
#
  [switch(match(r(7), d), 0,, [v(mail_flag_d)]%b%b)]

#
# check for the MARKED (M) flag
#
  [switch(match(r(7), m), 0,, [v(mail_flag_m)]%b%b)]

#
# check for the SAVED (S) flag
#
  [switch(match(r(7), s), 0,, [v(mail_flag_s)]%b%b)]

#
# check for the TIMEOUT WARNING (T) flag
#
# (shown if the letter HAS been read, but not within the message
# timeout/2 timeframe) and is not marked as 'saved'
#

  [switch(
    and(
      eq(match(r(7), s), 0),
      not(strmatch(r(8), 0)),
      gte(sub(secs(), convtime(r(8))), div(%6, 2))
    ),
    0,,
    { 
      [switch(words(r(7)), 0, %rFlags:%b%b%b%b)][v(mail_flag_t)]%b%b
    }
  )]

  [switch(%4, standard, {%r[u(dash_line)]%r%r},%rText:[space(5)])]

#
# main body of text
#
  [u(%7/out-%8-text)]

#
# If there is a note registered with this mail message, show it.
#
  [switch(
    gt(words(get(%5/in-%2-note)), 0), 
    1,
    {[switch(%4, standard, {%r%r[u(dash_line)]})]
    %rNote:[space(5)][get_eval(%5/in-%2-note)]}
  )]

  [switch(%4, standard, {%r%r[u(equal_line)]})]
  %rOptions:%b +add note=<text>, +delete, +forward, +move, +reply, 
  +replyall, +save

-
&CHECK_IF_REGISTERED #3482=
#
# PURPOSE:
#
#   Determine if a receipt notification needs to be sent.  A receipt
#   notification is sent to the originator of a piece of mail when it
#   has been sent as 'registered' and this is the first time it was
#   read.
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - dbref of mailbox
#   %2 - internal mail number of letter just read
#   %3 - dbref of source mailbox
#   %4 - internal mail number in source mailbox
#
# OUTPUT
#
#   None
#
# Registers used:
#
#   NOTE:  Registers 0, 1, 2, 3, 4 and 9 are set/used in read_command 
#        and shouldn't be stomped on.
#
#   5 - dbref of who to send receipt to            
#   6 - time read
#

  &in-%2-time_read %1 = [setq(6, get(%1/in-%2-time_read))]time(); 

  @swi/first 

    [setq(5, get(%3/out-%4-sender))]
    [setq(5, switch(words(r(5)), 0, get(%3/owner_dbref), r(5)))]

  1 = 

  and(
    strmatch(r(6), 0), 
    sign(match(get(%1/in-%2-flags), r))
  ), 
  {
#
# The mail was REGISTERED and this is the first time it was read, send an
# acknowledge back to the sender.  
#

    @tr me/store_letter = 
      %1, 
      Receipt Notification, 
      name(r(5)), 
      r(5), 
      , 
      , 
      , 
      , 
      , 
      {[name(%0)] has read the message which had a subject 
      line of "[trim(get(%3/out-%4-subject))]" which was originally 
      sent by you on [get(%3/out-%4-time_sent)].}
  }

-
###############################################################################
#
#                                U N R E A D          
#
###############################################################################
&UNREAD_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to mark one or more letters previously
#   read as unread again.
#
# Command Format:
#
#   +unread <keyword or letter number>
#
#   The following keywords are available to specify the scope of +unread:
#
#     all, current, deleted, first, last, marked, next, previous, saved
#     author:<name>, subject:<text>, text:<text fragment>
#
#     only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - list of internal message numbers reflecting the specified criteria
#

  $+unread*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *\[*)), 
    {
#
# Function calls are not allowed within input parameters.
#

      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
#
# User does not have a mailbox.
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(get_folder_in_list, r(0)))]

#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(2, 
            u(expand_letter_range, %0, r(1), u(get_folder_current_letter, r(0)))
          )]

        1 = eq(strlen(r(1)), 0), 
        {
#
# There is no mail in the user's mailbox.  Notify the user and 
# release the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, r(0))); 
          @no r(0)
        },

        strmatch(r(2), *ABORT*), 
        {
#
# Error detected in user input.  Notify the user and release the
# semaphore.
#

          @pemit %# = after(before(r(2), ENDABORT), ABORT); 
          @no r(0)
        },

        eq(strlen(r(2)), 0),
        {
#
# No letters match the user specified criteria.  Notify the user
# and release the semaphore.
#

          @pemit %# = u(no_match, +unread, u(format_request, trim(%0)), 
             u(get_active_folder, r(0))); 
          @no r(0)
        },
        {
#
# Reorder the list of letters to 'unread' into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#

          @dolist 

            [setq(2, u(filter_list, setunion(r(2), ), r(1)))]

          r(2) =
          {
#
# Zap the time_read field for the specified letter.  A value of '0'
# for time_read indicates that the letter has not been read yet.
#

            &in-##-time_read [r(0)] = 0
          }; 

          @swi 1 = 1, 
          {
#
# Finished showing information about the letter(s) specified. 
# Notify user, clean up global variables and release the semaphore.
#

#
# Set 'current letter' to be the last letter marked as unread
#

            &[u(which_current_letter, r(0))] [r(0)] = first(revwords(r(2)));  

            @pemit %# = Letter(s) [u(convert_nums, r(2), r(1))]
              [u(format_request, trim(%0))] marked as 'unread' 
                in folder '[u(get_active_folder, r(0))]'.;

            @no r(0)
          }
        }
      }
    }

-
###############################################################################
#
#                           A D D   N O T E
#
###############################################################################
&ADD_NOTE_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to store a personal note associated with 
#   the letter specified.  This note will show up on subsequent +read's
#   of this letter.  Warning:  it is also sent along if the letter it
#   is associated with is forwarded to another player.
#
# Command Format:
#
#   +add note to <keyword or letter number>=<text>
#
#   The following keywords are available to specify the scope of +add note:
#
#     current (default), first, last, next, previous 
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - internal message number reflecting the specified criteria
#

  $+add note to *=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *\[*)), 
    {
#
# Function calls are not allowed within input parameters
#

      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
#
# User does not have a mailbox
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(get_folder_in_list, r(0)))]

#
# Interpret user input and convert into an internal mail number
#
          [setq(2, 
            u(expand_single_letter_range, 
            trim(%0), r(1), u(get_folder_current_letter, r(0)))
          )]

        1 = eq(strlen(r(1)), 0), 
        {
#
# Mailbox is empty.  Notify user, clear global variable and release
# the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, r(0)));
          @no r(0)
        },

        strmatch(r(2), *ABORT*), 
        {
#
# Error detected in user input.  Notify user, clear global variables
# and release the semaphore.
#

          @pemit %# = after(before(r(2), ENDABORT), ABORT); 
          @no r(0)
        },

        eq(strlen(r(2)), 0), 
        {
#
# No letter matches the user specified criteria.  Notify the user,
# clear the global variables and release the semaphore.
#

          @pemit %# = u(no_match, +add note, u(format_request, trim(%0)), 
             u(get_active_folder, r(0))); 
          @no r(0)
        },

        {
#
# Store the note with the specified letter, update current_letter, 
# notify the user of the action taken and release the semaphore.
#

          &in-[r(2)]-note [r(0)] = escape(edit(%1, \\, )); 
          &[u(which_current_letter, r(0))] [r(0)] = r(2);
          @pemit %# = Note [switch(strlen(%1), 0, removed from, added to)] 
            message 
            [u(convert_nums, r(2), r(1))]
            [u(format_request, trim(%0))] 
            in folder '[u(get_active_folder, r(0))]'.;

          @no r(0)
        }
      }
    }

-
###############################################################################
#
#                           A D D   N O T E
#
# part 2 (added for user convenience)
#
###############################################################################
&ADD_NOTE_2_COMMAND #3478=

  $+add note=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(r(0)), 
    {
#
# User does not have a mailbox
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(get_folder_in_list, r(0)))]
          [setq(2, u(get_folder_current_letter, r(0))))]

        1 = eq(strlen(r(1)), 0), 
        {
#
# Mailbox is empty.  Notify user, clear global variable and release
# the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, r(0)));
          @no r(0)
        },

        {
#
# Store the note with the current letter, 
# notify the user of the action taken and release the semaphore.
#

          &in-[r(2)]-note [r(0)] = escape(edit(%0, \\, )); 
          @pemit %# = Note [switch(strlen(%0), 0, removed from, added to)] 
            message [u(convert_nums, r(2), r(1))] (%bcurrent%b) 
            in folder '[u(get_active_folder, r(0))]'.;

          @no r(0)
        }
      }
    }

-
&ADD_NOTE #3478 = 

  $+add note: @pemit %# = The syntax is +add note to <number>=<text>.

-
###############################################################################
#
#                              D E L E T E
#
###############################################################################
&DELETE_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to delete one or more of the messages in 
#   a mailbox.  +delete with no parameters will delete the last mail
#   message read.  Either a keyword (listed below) or a list of 
#   mail numbers may be specified.  Example:  +delete 3..5, +delete marked
#
# Command Format:
#
#   +delete <keyword or a list of letter number>
#
#   The following keywords are available to specify the scope of +delete:
#
#     all, current (default), first, last, marked, next, previous, saved, 
#     unread, author:<name>, subject:<text>, text:<text fragment>
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - list of internal message numbers reflecting the specified criteria
#   3 - new current letter
#   4 - external message numbers to delete
#   5 - current folder
#   6 - user's delete option
#

  $+delete*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *\[*)), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(get_folder_in_list, r(0)))]
          [setq(6, u(get_delete_option, %#))]

#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(2, 
            u(expand_letter_range, %0, r(1), u(get_folder_current_letter, r(0)))
          )]

          [setq(5, u(get_active_folder, r(0)))]

        1 = eq(strlen(r(1)), 0),  
        {
#
# Mailbox is empty.  Notify user and release the semaphore.
#

          @pemit %# = u(nomail, r(5));
          @no r(0)
        },

        strmatch(r(2), *ABORT*), 
        {
#
# Error detected in input parameter.  Notify user and release the semaphore.
#

          @pemit %# = after(before(r(2), ENDABORT), ABORT); 
          @no r(0)
        },

        eq(strlen(r(0)), 0), 
        {
#
# No letters match the specified user input criteria.  Notify user
# and release the semaphore.
#

          @pemit %# = u(no_match, +delete, u(format_request, trim(%0)), 
             r(5)); 
          @no r(0)
        },

        {

          @dolist 
#
# Reorder the list of letters to delete into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
            [setq(2, u(filter_list, setunion(r(2), ), r(1)))]

# Temp variable. List of in-list after deletions.

            [setq(3, s(u(filter_list, setdiff(r(1), r(2)), r(1))))]
#
# Determine what the 'current letter' will be after all requested
# deletions have occurred.  If the last letter in the in-list-<folder> is
# deleted, set 'current letter' to the first letter in the in-list-<folder>.
# Otherwise, set 'current letter' to the letter after the last
# one deleted if hard deleted, and the last letter marked for deletion,
# if soft deleted.
#
            [setq(3, 
              switch(r(6), soft, first(revwords(r(2))), 
              switch(first(revwords(r(2))), first(revwords(r(1))), 
              first(r(3)), extract(r(1), add(match(r(1), 
              first(revwords(r(2)))), 1), 1))))]

#
# Convert the list of internal mail numbers to external mail numbers
# for use in later display to the user.
#
            [setq(4, u(convert_nums, r(2), r(1)))]

          r(2) = 
          {

            @swi r(6) = soft, 
            {
#
# User has their mail configuration option 'delete' set to soft.  Simply
# mark the bugger for deletion
#
              &in-##-flags [r(0)] = setunion(get(r(0)/in-##-flags) D, )
            }, 

            {
#
# Hard delete.  
#

              @tr me/remove_letter = 
                u(get_src_dbref, r(0), ##), 
                u(get_src_num, r(0), ##), 
                %#, 
                r(0), 
                ##, 
                edit(r(5), %b, $)
            }
          }; 

          @swi 1 = 1,
          {
#
# Done processing the +delete command.  Notify user of action taken.
#

            &current_letter-[r(5)] [r(0)] = r(3); 

            @pemit %# = Message(s) [r(4)]
                [u(format_request, trim(%0))] 
                [switch(u(get_delete_option, %#), 
                hard, deleted from, marked for deletion in)] 
                folder '[r(5)]'.; 

            @no r(0)
          }
        }
      }
    }

-
&CLEANUP_DELETE #3482=
-
###############################################################################
#
#                             U N D E L E T E      
#
###############################################################################
&UNDELETE_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to remove the 'marked for deletion' flag 
#   previously set by a 'soft' +delete.  Either a keyword (listed below)
#   or a list of letter numbers as shown on a +read or +skim may be
#   specified.  Example:  +undelete 3 or +undelete marked
#
# Command Format:
#
#   +undelete <keyword or a list of letter numbers>
#
#   The following keywords are available to specify the scope of +undelete:
#
#     all, current (default), deleted, first, last, marked, next, previous, 
#     saved, unread, author:<name>, subject:<text>, text:<text fragment>
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - list of internal message numbers reflecting the specified criteria
#

  $+undelete*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *\[*)), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(get_folder_in_list, r(0)))]
#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(2, 
            u(expand_letter_range, %0, r(1), u(get_folder_current_letter, r(0)))
          )]

        1 = eq(strlen(r(1)), 0),  
        {
#
# There is no mail in the user's mailbox.  Notify the user 
# and release the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, r(0)));
          @no r(0)
        },

        strmatch(r(2), *ABORT*), 
        {
#
# Error detected in input parameter.  Notify the user and release the semaphore.
#

          @pemit %# = after(before(r(2), ENDABORT), ABORT); 
          @no r(0)
        },

        eq(strlen(r(2)), 0), 
        {
#
# Could not find any letters to match the specified input parameter.
# Notify the user and release the semaphore.
#

          @pemit %# = u(no_match, +undelete, u(format_request, trim(%0)), 
             u(get_active_folder, r(0))); 
          @no r(0)
        },

        {
          @dolist 
#
# Reorder the list of letters to 'undelete' into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
              [setq(2, u(filter_list, setunion(r(2), ), r(1)))]

          r(2) = 
          {
            &in-##-flags [r(0)] = s(remove(get(r(0)/in-##-flags), D))
          }; 

          @swi 1 = 1, 
          {

#
# Finished removing the 'marked for deletion' flag from the letter(s) 
# specified.  Set 'current letter' to be the last letter that had the 
# marked for deletion flag removed from it.  Notify the user and release 
# the semaphore.
#

            &[u(which_current_letter, r(0))] [r(0)] = first(revwords(r(2))); 

            @pemit %# = 'Marked for deletion' flag(s) removed from 
              message(s) [u(convert_nums, r(2), r(1))]
              [u(format_request, trim(%0))] 
              in folder '[u(get_active_folder, r(0))]'.; 

            @no r(0)
          }
        }
      }
    }

-
###############################################################################
#
#                              C L E A R   
#                          (alias for +delete)
#
###############################################################################
&CLEAR_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to clear one or more of the messages in 
#   a mailbox.  +clear with no parameters will delete the last mail
#   message read.  Either a keyword (listed below) or a list of 
#   mail numbers may be specified.  Example:  +clear 3..5, +clear marked
#
# Command Format:
#
#   +clear <keyword or a list of letter number>
#
#   The following keywords are available to specify the scope of +clear:
#
#     all, current (default), first, last, marked, next, previous, saved, unread
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - list of internal message numbers reflecting the specified criteria
#   3 - new current letter
#   4 - external message numbers to delete
#   5 - current folder
#   6 - user's delete option
#

  $+clear*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *\[*)), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(get_folder_in_list, r(0)))]

#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(2, 
            u(expand_letter_range, %0, r(1), u(get_folder_current_letter, r(0)))
          )]

          [setq(5, u(get_active_folder, r(0)))]
          [setq(6, u(get_delete_option, %#))]

        1 = eq(strlen(r(1)), 0),  
        {
#
# Mailbox is empty.  Notify user and release the semaphore.
#

          @pemit %# = u(nomail, r(5));
          @no r(0)
        },

        strmatch(r(2), *ABORT*), 
        {
#
# Error detected in input parameter.  Notify user and release the semaphore.
#

          @pemit %# = after(before(r(2), ENDABORT), ABORT); 
          @no r(0)
        },

        eq(strlen(r(0)), 0), 
        {
#
# No letters match the specified user input criteria.  Notify user
# and release the semaphore.
#

          @pemit %# = u(no_match, +clear, u(format_request, trim(%0)), 
             r(5)); 
          @no r(0)
        },

        {

          @dolist 
#
# Reorder the list of letters to delete into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
            [setq(2, u(filter_list, setunion(r(2), ), r(1)))]

# Temp variable. List of in-list after deletions.

            [setq(3, s(u(filter_list, setdiff(r(1), r(2)), r(1))))]
#
# Determine what the 'current letter' will be after all requested
# deletions have occurred.  If the last letter in the in-list-<folder> is
# deleted, set 'current letter' to the first letter in the in-list-<folder>.
# Otherwise, set 'current letter' to the letter after the last
# one deleted.
#
            [setq(3, 
              switch(r(6), soft, first(revwords(r(2))), 
              switch(first(revwords(r(2))), first(revwords(r(1))), 
              first(r(3)), extract(r(1), add(match(r(1), 
              first(revwords(r(2)))), 1), 1))))]

#
# Convert the list of internal mail numbers to external mail numbers
# for use in later display to the user.
#
            [setq(4, u(convert_nums, r(2), r(1)))]

          r(2) = 
          {

            @swi r(6) = soft, 
            {
#
# User has their mail configuration option 'delete' set to soft.  Simply
# mark the bugger for deletion
#
              &in-##-flags [r(0)] = setunion(get(r(0)/in-##-flags) D, )
            }, 

            {
#
# Hard delete.  
#

              @tr me/remove_letter = 
                u(get_src_dbref, r(0), ##), 
                u(get_src_num, r(0), ##), 
                %#, 
                r(0), 
                ##, 
                edit(r(5), %b, $)
            }
          }; 

          @swi 1 = 1,
          {
#
# Done processing the +clear command.  Notify user of action taken.
#

            &current_letter-[r(5)] [r(0)] = r(3); 

            @pemit %# = Message(s) [r(4)]
                [u(format_request, trim(%0))] 
                [switch(u(get_delete_option, %#), 
                hard, cleared from, marked for deletion in)] 
                folder '[r(5)]'.; 

            @no r(0)
          }
        }
      }
    }

-
###############################################################################
#
#                                F L U S H         
#
###############################################################################
&FLUSH_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to flush (delete) all messages that have 
#   been targeted for deletion by doing a soft delete.  These messages
#   show up with a 'D' next to their number on a +skim.  
#
# Command Format:
#
#   +flush
#
# Registers Used:
#
#   0 - dbref of mailbox
#   1 - list of letters in folder
#   2 - count of messages before flush
#   4 - count of messages after flush
#   5 - internal list of letters to flush
#   8 - active folder
#   9 - new current_letter-<folder>
#

  $+flush: 

    @swi 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(r(0)),
    {
      @pemit %# = There is no mail marked for deletion 
        in folder '[u(get_inbox, %#)]'.
    },
    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(get_folder_in_list, r(0)))]
          [setq(5, u(find_letters_to_flush, r(0), r(1)))]
          [setq(8, u(get_active_folder, r(0)))]
          [setq(9, s(u(filter_list, setdiff(r(1), r(5)), r(1))))]
          [setq(9, 
            switch(
              first(revwords(r(5))), 
              first(revwords(r(1))), 
                first(r(9)), 
              extract(
                r(1), 
                add(member(r(1), first(revwords(r(5)))), 1), 
                1
              )
            )
          )]

        0 = strlen(r(1)), 
        {
#
# There is no mail in the user's mailbox.  Notify the user 
# and release the semaphore.
#

          @pemit %# = There is no mail marked for deletion in folder '[r(8)]'.;
          @no r(0)
        },

        words(r(5)),  
        {
          @pemit %# = There is no mail marked for deletion in folder '[r(8)]'.;
          @no r(0)
        },

        {
          @dolist 

#
# Temporarily save away a count of how many messages are in the mailbox.
#
            [setq(2, words(r(1)))]

          r(5) = 
          {
            @tr me/remove_letter = 
              u(get_src_dbref, r(0), ##), 
              u(get_src_num, r(0), ##), 
              %#, 
              r(0), 
              ##, 
              edit(r(8), %b, $)
           }; 

           @swi 1 = 1, 
           {
#
# Done purusing the mailbox, perform cleanup processing.
#

              @pemit %# = 

                  [setq(4, words(r(5)))]

                All messages that were marked for deletion have been deleted 
                from folder '[r(8)]'. 
                (%b[r(4)] deleted, [sub(r(2), r(4))] remain%b); 

              &[u(which_current_letter, r(0))] [r(0)] = r(9); 
              @no r(0)
          }
        }
      }
    }

-
&FIND_LETTERS_TO_FLUSH #3482 = 
#
# PURPOSE:
#
#   This is a helper routine for +flush.  Scan through the list of received 
#   +mail messages, and return a list of internal mail numbers for any
#   that have the 'D' (marked for deletion) flag set.
#
# %0 - mailbox dbref
# %1 - in-list for active folder
#
 
  iter(%1, switch(member(get(%0/in-##-flags), D), 0,, ##))

-
###############################################################################
#
#                             R E P L Y             
#
###############################################################################
&REPLY_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to reply to a received mail message.  A +reply
#   with no parameter specified will reply to the last message read.  A
#   +reply with a <letter # or keyword> specified will reply to the specified
#   message.  The destination will be set to where the original letter came
#   from, the subject will be the same as the original letter, with a 'Re: '
#   prefixed to it.
#
# Command Format:
#
#   +reply [keyword or letter number]
# 
#   The following keywords are available to specify which letter to reply to:
#
#     current (default), first, last, next, previous
#
#   Only the first character of the keyword needs to be specified.
#
# Registers Used:
#
#   0 - dbref of mailbox
#   1 - list of letters in folder
#   2 - internal message number reflecting the specified criteria
#   3 - subject of letter to reply to
#   4 - dbref of source mailbox
#   5 - internal number of source mail in source mailbox
#   6 - originator of mail to reply to
#

  $+reply*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = strmatch(%0, all*),,
#
# +replyall - ignore
#

    not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    strmatch(escape(%0), *\[*), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(r(0)), 0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(get_folder_in_list, r(0)))]

#
# Interpret user input and convert into an internal mail number
#
          [setq(2, u(expand_single_letter_range, trim(%0), r(1), 
            u(get_folder_current_letter, r(0))))]

          [setq(4, u(get_src_dbref, r(0), r(2)))]

          [setq(5, u(get_src_num, r(0), r(2)))]

          [setq(6, get(r(4)/out-[r(5)]-sender))]
          [setq(6, switch(words(r(6)), 0, get(r(4)/owner_dbref), r(6)))]

        1 = strmatch(get(r(0)/mail-in-progress), true),
        {
#
# Mail message is already in progress.  Notify user 
# and release the semaphore.
#

          @pemit %# = You are already in the middle of sending a message. 
            You must complete that one before you reply to this one.; 

          @no r(0)
        },

        eq(strlen(r(1)), 0), 

        {
#
# There is no mail in the user's mailbox.  Notify user and release 
# the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, r(0)));
          @no r(0)
        },

        strmatch(r(2), *ABORT*), 
        {
#
# Error detected in input parameter.  Notify the user and release the 
# semaphore.
#

          @pemit %# = after(before(r(2), ENDABORT), ABORT); 
          @no r(0)
        },

        eq(strlen(r(2)), 0), 
        {
#
# Could not find any letter to match the specified input parameter.
# Notify the user and release the semaphore.
#

          @pemit %# = u(no_match, +reply, u(format_request, trim(%0)), 
             u(get_active_folder, r(0))); 
          @no r(0)
        },

        not(strmatch(type(r(6)), PLAYER)), 
        {
#
# Original sender is no longer a player.
# Notify the user and release the semaphore.
#

          @pemit %# = Originator of letter 
             [u(convert_nums, r(2), r(1))][u(format_request, trim(%0))] 
             in folder '[u(get_active_folder, r(0))]' is no longer a player.; 
          @no r(0)
        },

        {
#
# - Set current letter to the letter being replied to
# - Set mail-in-progress to true
# - Preset 'to' list and 'subject' based on letter being replied to
# - Let user know what to do next
# - Release the semaphore
#

          &[u(which_current_letter, r(0))] [r(0)] = r(2);
          &mail-in-progress [r(0)] = true; 
          &mail-in-progress-to [r(0)] = name(r(6)); 
          &mail-in-progress-to-expanded [r(0)] = r(6); 

          &mail-in-progress-subject [r(0)] = 

            [setq(3, get(r(4)/out-[r(5)]-subject))]

            switch(mid(r(3), 0, 3), Re:, r(3), Re:%b%b[r(3)]); 

          @pemit %# = 
            switch(
              u(get_mode_option, %#),
              verbose, 
                u(enter_msg_verbose),
              u(enter_msg_terse)
            ); 

          @no r(0)
        }
      }
    }

-
###############################################################################
#
#                             R E P L Y A L L
#
###############################################################################
&REPLYALL_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to send a reply to all recipients of a 
#   specified mail message.  A +replyall with no parameter specified 
#   will reply to the last message read.  A +replyall with a 
#   <letter # or keyword> specified will reply to the specified
#   message.  The subject will be the same as the original letter, 
#   with a 'Re: ' prefixed to it.
#
# Command Format:
#
#   +replyall [keyword or letter number]
# 
#   The following keywords are available to specify which letter to reply to:
#
#     current (default), first, last, next, previous
#
#   Only the first character of the keyword needs to be specified.
#
# Registers Used:
#
#   0 - dbref of mailbox
#   1 - list of letters in folder
#   2 - internal message number reflecting the specified criteria
#   3 - subject of letter to reply to
#   4 - dbref of source mailbox
#   5 - internal number of source mail in source mailbox
#

  $+replyall*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    strmatch(escape(%0), *\[*), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(r(0)), 0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(get_folder_in_list, r(0)))]
 
#
# Interpret user input and convert into an internal mail number
#
          [setq(2, u(expand_single_letter_range, trim(%0), r(1), 
            u(get_folder_current_letter, r(0))))]
 
          [setq(4, u(get_src_dbref, r(0), r(2)))]

          [setq(5, u(get_src_num, r(0), r(2)))]

        1 = strmatch(get(r(0)/mail-in-progress), true),
        {
#
# Mail message is already in progress.  Notify user and release the semaphore.
#

          @pemit %# = You are already in the middle of sending a message. 
            You must complete that one before you reply to this one.; 

          @no r(0)
        },

        eq(strlen(r(1)), 0),
        {
#
# There is no mail in the user's mailbox.  Notify user and release the 
# semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, r(0)));
          @no r(0)
        },

        strmatch(r(2), *ABORT*), 
        {
#
# Error detected in input parameter.  Notify the user and release the semaphore.
#

          @pemit %# = after(before(r(2), ENDABORT), ABORT); 
          @no r(0)
        },

        eq(strlen(r(2)), 0), 
        {

# Could not find any letter to match the specified input parameter.
# Notify the user and release the semaphore.
#

          @pemit %# = u(no_match, +replyall, u(format_request, trim(%0)), 
             u(get_active_folder, r(0))); 
          @no r(0)
        },

        eq(words(get(r(4)/out-[r(5)]-replyall_to)), 0),
        {
#
# no 'replyall_to' attribute exists for the letter specified, 
# unable to perform a +replyall.
#
          @pemit %# = +replyall:%b%bUnable to perform this function 
            on the specified letter[u(format_request, trim(%0))] 
            in folder '[u(get_active_folder, r(0))]'.;

          @no r(0)
        },

        {
#
# - Set current letter to the letter being replied to
# - Set mail-in-progress to true
# - Preset 'to' list and 'subject' based on letter being replied to
# - Let user know what to do next
# - Release the semaphore
#

          &[u(which_current_letter, r(0))] [r(0)] = r(2);
          &mail-in-progress [r(0)] = true; 

          &mail-in-progress-to [r(0)] = 
            u(format_names, get(r(4)/out-[r(5)]-replyall_to)); 

          &mail-in-progress-to-expanded [r(0)] = 
            get(r(4)/out-[r(5)]-replyall_to); 

          &mail-in-progress-subject [r(0)] = 

            [setq(3, get(r(4)/out-[r(5)]-subject))]

            switch(mid(r(3), 0, 3), Re:, r(3), Re:%b%b[r(3)]); 

          @pemit %# = 
            switch(
              u(get_mode_option, %#),
              verbose, 
                u(enter_msg_verbose),
              u(enter_msg_terse)
            ); 

          @no r(0)
        }
      }
    }

-
###############################################################################
#
#                             F O R W A R D         
#
###############################################################################
&FORWARD_MAIL #3478=
#
# PURPOSE:
#
#   This command may be used to reply to forward a piece of received mail  
#   to a list of destinations.  +forward to <list of destinations> will
#   forward the current letter.  +forward <letter # or keyword> to 
#   <list of destinations> will forward the letter specified.  The
#   subject line will be the same as the original letter, with a 'Fwd: '
#   prefixed to it.  Text within the letter cannot be changed. 
#
# Command Format:
#
#   +forward [keyword or letter number] to <list of destinations>
#
#   The following keywords are available to specify which letter to +forward:
#
#     current (default), first, last, next, previous
#
#   Only the first character of the keyword needs to be specified.
#
# NOTE:
#
#   If a note is registered with the letter (by having previously done
#   a +add note to <letter>=<text>, this note will be carrying along with
#   the forwarded message.  
#
# Registers Used:
#
#   0 - dbref of mailbox
#   1 - list of letters in folder 
#   2 - holds the internal message number of the mail to forward
#   3 - dbrefs of player names use specified to forward to and then later
#       it holds the dbref of a single player to forward the mail to
#   4 - aliases specified of who to forward to, also used to hold
#       the subject, and another time to hold the note
#   5 - player dbrefs + alias names expanded into player dbrefs
#   6 - aliases specified identified as personal or global
#   7 - dbref of mailbox to write into
#   8 - used lots, in one case to hold the subject
#       in another to hold the note, in another to be the internal
#       mail number to write into.
#
# Yuck.
#

  $+forward* to *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    or(
      strmatch(escape(%0), *\[*),
      strmatch(escape(%1), *\[*)
    ),
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(r(0)), 0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

            [setq(1, u(get_folder_in_list, r(0)))]

#
# Interpret user input and convert into an internal mail number
#
            [setq(2, 
              u(expand_single_letter_range, 
                trim(%0), 
                r(1), 
                u(get_folder_current_letter, r(0))
              )
            )]

#
# Convert list of names specified by the user into dbrefs
#
            [setq(3, u(identify_to_list, {%1}, r(0)))]

# 4, 7, 8 are just temp/working registers and are stomped on later

            [setq(7, get(%vm/global-mail-aliases))]
            [setq(8, get(r(0)/alias-list))]
            [setq(4, u(get_aliases, {%1}, r(0), r(7), r(8)))]

# 5 - 'real' list of destinations (dbrefs)

            [setq(5, 
              setunion([r(3)] [u(expand_aliases, r(4), r(0), %b, r(7), r(8))], )
            )]

# 6 - 'pretty' list of destinations, for use in display to the user

            [setq(6, 
              [u(pretty_dist, r(4), r(0), r(8), r(7), r(3))]
            )]

        0 = strlen(%1), 
        {
#
# No destination specified for who to forward the letter to.  Notify user
# and release the semaphore.
#

          @pemit %# = You must specify a destination to forward this piece 
            of mail to.; 
          @no r(0)
        },

        strlen(r(1)),
        {
#
# There is no mail in the user's mailbox.  Notify user 
# and release the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, r(0)));
          @no r(0)
        },

        not(strmatch(r(2), *ABORT*)), 
        {
#
# Error detected in input parameter.  Notify user and release the semaphore.
#

          @pemit %# = after(before(r(2), ENDABORT), ABORT); 
          @no r(0)
        },

        strlen(r(2)), 
        {
#
# Could not find a letter to match the specified input parameter.
# Notify user and release the semaphore.
#

          @pemit %# = u(no_match, +forward, u(format_request, trim(%0)), 
            u(get_active_folder, r(0))); 
          @no r(0)
        },

        not(strmatch(r(3), *ABORT*)), 
        {
#
# Error detected in input parameter.  Notify user 
# and release the semaphore.
#
          @pemit %# = secure(after(before(r(3), ENDABORT), ABORT)); 
          @no r(0)
        },

        {
          @trigger me/store_letter =

              [setq(3, u(get_src_dbref, r(0), r(2)))]
              [setq(4, u(get_src_num, r(0), r(2)))]
              [setq(7, get(r(3)/out-[r(4)]-sender))]
              [setq(7, switch(words(r(7)), 0, get(r(3)/owner_dbref), r(7)))]
              [setq(8, get(r(3)/out-[r(4)]-subject))]
              [setq(9, get(r(0)/in-[r(2)]-note))]

            r(0), 
            switch(mid(r(8), 0, 4), Fwd:, r(8), Fwd:%b%b[r(8)]), 
            r(6), 
            r(5), 
              , 
              , 
              , 
              , 
              , 
            {Received from:%b%b
             [name(r(7))]
             %r[u(r(3)/out-[r(4)]-text)]

             [switch(
               words(r(9)),
               0,,
                 %r%r[u(dash_line)]
                 %r%N's comment section:
                 %r%r[r(9)]
             )]}; 

          &[u(which_current_letter, r(0))] [r(0)] = r(2);

          @pemit %# = 
            u(forward_notification, 
              u(get_active_folder, r(0)), 
              [u(convert_nums, r(2), r(1))]
              [u(format_request, trim(%0))]); 

          @no r(0)
        }
      }
    }

-
&FORWARD_COMMAND #3478=

  $+forward: 

    @pemit %# = u(#3481/forward_help)

-
###############################################################################
#
#                             F O R W A R D         
#
# Second version
#
###############################################################################
&FORWARD_MAIL2 #3478=
#
# PURPOSE:
#
#   This command may be used to forward a received mail message to one
#   or more destinations.  You will be allowed to add text via '-<text>'
#   before sending it.  The subject will be the same as the original 
#   letter, with a 'Fwd: ' prefixed to it.
#
# This command is being provided for compatibility with Amberyl's
# mailer.
#
# Command Format:
#
#   +forward <list of people>=[keyword or letter number]
# 
#   The following keywords are available to specify which letter to forward:
#
#     current (default), first, last, next, previous
#
#   Only the first character of the keyword needs to be specified.
#
# Registers Used:
#
#   0 - dbref of mailbox
#   1 - list of letters in folder
#   2 - internal message number reflecting the specified criteria
#   3 - list of dbrefs associated with names entered for who to forward to
#   4 - list of aliases to forward to
#   5 - 'real' list of destinations (dbrefs)
#   6 - 'pretty' list of destinations
#   7 - global mail aliases
#   8 - personal mail aliases
#   9 - subject of letter to forward
#

  $+forward *=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = 

    not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    or(
      strmatch(escape(%0), *\[*), 
      strmatch(escape(%1), *\[*)
    ), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(r(0)), 0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

# Get list of letters for the active folder

          [setq(1, u(get_folder_in_list, r(0)))]

# Interpret user input and convert into an internal mail number

          [setq(2, u(expand_single_letter_range, trim(%1), r(1), 
            u(get_folder_current_letter, r(0))))]

# Convert list of names specified by the user into dbrefs

          [setq(3, u(identify_to_list, {%0}, r(0)))]

# Global mail aliases

          [setq(7, get(%vm/global-mail-aliases))]

# Personal mail aliases

          [setq(8, get(r(0)/alias-list))]

# List of aliases specified by the user for who to forward to

          [setq(4, u(get_aliases, {%0}, r(0), r(7), r(8)))]

# 'real' list of destinations (dbrefs) 

          [setq(5,
            setunion([r(3)] [u(expand_aliases, r(4), r(0), %b, r(7), r(8))], )
          )]

# 'pretty' list of destinations, for use in display to the user

          [setq(6,
            [u(pretty_dist, r(4), r(0), r(8), r(7), r(3))]
          )]

        1 = 

        eq(strlen(%0), 0), 
        {
#
# No destination specified for who to forward the letter to.  Notify user
# and release the semaphore.
#

          @pemit %# = You must specify a destination to forward this piece
            of mail to.;
          @no r(0)
        },

        strmatch(get(r(0)/mail-in-progress), true),
        {
#
# Mail message is already in progress.  Notify user 
# and release the semaphore.
#

          @pemit %# = You are already in the middle of sending a message. 
            You must complete that one before you can forward another.; 

          @no r(0)
        },

        eq(strlen(r(1)), 0), 

        {
#
# There is no mail in the user's mailbox.  Notify user and release 
# the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, r(0)));
          @no r(0)
        },

        strmatch(r(2), *ABORT*), 
        {
#
# Error detected in input parameter.  Notify the user and release the 
# semaphore.
#

          @pemit %# = after(before(r(2), ENDABORT), ABORT); 
          @no r(0)
        },

        eq(strlen(r(2)), 0), 
        {
#
# Could not find any letter to match the specified input parameter.
# Notify the user and release the semaphore.
#

          @pemit %# = u(no_match, +forward, u(format_request, trim(%1)), 
             u(get_active_folder, r(0))); 
          @no r(0)
        },

        strmatch(r(3), *ABORT*),
        {
#
# Error detected in input parameter.  Notify user
# and release the semaphore.
#
          @pemit %# = secure(after(before(r(3), ENDABORT), ABORT));
          @no r(0)
        },

        {
#
# - Set current letter to the letter being forwarded
# - Set mail-in-progress to true
# - Preset body and subject based on letter being forwarded
# - Let user know what to do next
# - Release the semaphore
#

          &[u(which_current_letter, r(0))] [r(0)] = r(2);
          &mail-in-progress [r(0)] = true; 
          &mail-in-progress-to [r(0)] = r(6); 
          &mail-in-progress-to-expanded [r(0)] = r(5); 

          &mail-in-progress-body [r(0)] = 
            [u(u(get_src_dbref, r(0), r(2))/
              out-[u(get_src_num, r(0), r(2))]-text)]
            %r%r---- Below this line are comments added by %N ----%r; 

          &mail-in-progress-subject [r(0)] = 

            [setq(9, u(u(get_src_dbref, r(0), r(2))/
              out-[u(get_src_num, r(0), r(2))]-subject))]

            switch(mid(r(9), 0, 4), Fwd:, r(9), Fwd:%b%b[r(9)]); 

          @pemit %# = You may now enter text to send along with the 
            message to forward.; 

          @no r(0)
        }
      }
    }

-
###############################################################################
#
#                               M A R K    
#
###############################################################################
&MARK_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to tag one or more of the messages in
#   a mailbox for future operations.  +mark with no parameter will 
#   mark the last mail message read.  Either a keyword (listed below) 
#   or a list of mail numbers may be specified.  Example:  +mark 3..5, 
#   +mark unread
#
# Command Format:
#
#   +mark [keyword or a list of letter numbers]
#
#   The following keywords are available to specify the scope of +mark:
#
#     all, current (default), deleted, first, last, next, previous, 
#     saved, unread, author:<name>, subject:<text>, text:<text fragment>
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - new current letter
#   3 - name of active folder
#   4 - list of internal message numbers reflecting the specified criteria
#

  $+mark*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    strmatch(escape(%0), *\[*), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(r(0)), 0),
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first  

          [setq(1, u(get_folder_in_list, r(0)))]
          [setq(2, u(get_folder_current_letter, r(0)))]
          [setq(3, u(get_active_folder, r(0)))]

#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(4, u(expand_letter_range, %0, r(1), r(2)))]

        0 = strlen(r(1)), 
        {
#
# There is no mail in the user's mailbox.  Notify the user and 
# release the semaphore.
#

          @pemit %# = u(nomail, r(3));
          @no r(0)
        },

        not(strmatch(r(4), *ABORT*)), 
        {
#
# Error detected in input parameter.  Notify the user 
# and release the semaphore.
#

          @pemit %# = after(before(r(4), ENDABORT), ABORT); 
          @no r(0)
        },

        strlen(r(4)), 
        {
#
# Could not find any letters to match the specified input parameter.
# Notify the user and release the semaphore.
#

          @pemit %# = u(no_match, +mark, u(format_request, trim(%0)), r(3)); 
          @no r(0)
        },
        {

          @dolist 

#
# Reorder the list of letters to mark into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
            [setq(4, u(filter_list, setunion(r(4), ), r(1)))]

          r(4) = 
          {
            &in-##-flags [r(0)] = setunion(get(r(0)/in-##-flags) M, )
          }; 

          @swi 1 = 1,
          {
#
# Finished marking the letter(s) specified.  Set the 'current letter' 
# to be the last one marked.  Notify the user and release the semaphore.
#

            &[u(which_current_letter, r(0))] [r(0)] = first(revwords(r(4))); 

            @pemit %# = Message(s) [u(convert_nums, r(4), r(1))]
              [u(format_request, trim(%0))] marked in folder '[r(3)]'.; 

            @no r(0)
          }
        }
      }
    }

-
###############################################################################
#
#                               U N M A R K          
#
###############################################################################
&UNMARK_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to remove a tag previously set by a call to 
#   +mark. +unmark with no parameter will unmark the last mail message read.  
#   Either a keyword (listed below) or a list of mail numbers may be 
#   specified.  Example:  +unmark 3..5, +unmark marked
#
# Command Format:
#
#   +unmark [<keyword or a list of letter numbers>]
#
#   The following keywords are available to specify the scope of +unmark:
#
#     all, current (default), deleted, first, last, marked, next, previous,
#     saved, unread, author:<name>, subject:<text>, text:<text fragment>
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - new current letter
#   3 - name of active folder
#   4 - list of internal message numbers reflecting the specified criteria
#

  $+unmark*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    strmatch(escape(%0), *\[*), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(r(0)), 0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(get_folder_in_list, r(0)))]
          [setq(2, u(get_folder_current_letter, r(0)))]
          [setq(3, u(get_active_folder, r(0)))]

#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(4, u(expand_letter_range, %0, r(1), r(2)))]

        0 = strlen(r(1)), 
        {
#
# Mailbox is empty.  Notify user and release semaphore.
#

          @pemit %# = u(nomail, r(3));
          @no r(0)
        },

        not(strmatch(r(4), *ABORT*)), 
        {
#
# Error detected in input parameter.  Notify user and release semaphore.
#

          @pemit %# = after(before(r(4), ENDABORT), ABORT); 
          @no r(0)
        },

        strlen(r(4)), 
        {
#
# Could not find any letters to match the specified input parameter.
# Notify user and release semaphore.
#

          @pemit %# = u(no_match, +unmark, u(format_request, trim(%0)), r(3)); 
          @no r(0)
        },
        {
#
# Reorder the list of letters to 'unmark' into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#

          @dolist 

            [setq(4, u(filter_list, setunion(r(4), ), r(1)))]

          r(4) = 
          {
            &in-##-flags [r(0)] = s(remove(get(r(0)/in-##-flags), M))
          }; 

          @swi 1 = 1,
          {
#
# Finished removing the 'M' flag from the letter(s) specified. 
# Notify user and release the semaphore.
#

#
# Set the 'current letter' to be the last one unmarked
#

            &[u(which_current_letter, r(0))] [r(0)] = first(revwords(r(4))); 

            @pemit %# = Mark(s) removed from message(s) 
              [u(convert_nums, r(4), r(1))]
              [u(format_request, trim(%0))] in folder '[r(3)]'.; 

            @no r(0)
          }
        }
      }
    }

-
###############################################################################
#
#                               S A V E    
#
###############################################################################
&SAVE_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to exclude a message from normal mail 
#   timeouts. +save with no parameter will tag the last mail message read.  
#   Either a keyword (listed below) or a list of mail numbers may be 
#   specified.  Example:  +save 3..5, +save current
#
# Command Format:
#
#   +save [keyword or a list of letter numbers]
#
#   The following keywords are available to specify the scope of +save:
#
#     all, current (default), deleted, first, last, marked, next, previous,
#     unread, author:<name>, subject:<text>, text:<text fragment>
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - new current letter
#   3 - name of active folder
#   4 - list of internal message numbers reflecting the specified criteria
#

  $+save*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    strmatch(get(%vm/default_save_option), disabled), 
    {
      @pemit %# = I'm sorry, but the +save command has been disabled 
        by the game administrators.
    },

    strmatch(escape(%0), *\[*), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(r(0)), 0),
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(get_folder_in_list, r(0)))]
          [setq(2, u(get_folder_current_letter, r(0)))]
          [setq(3, u(get_active_folder, r(0)))]

#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(4, u(expand_letter_range, %0, r(1), r(2)))]

        0 = strlen(r(1)), 
        {
#
# There is no mail in the user's mailbox.  Notify the user and 
# release the semaphore.
#

          @pemit %# = u(nomail, r(3));
          @no r(0)
        },

        not(strmatch(r(4), *ABORT*)), 
        {
#
# Error detected in input parameter.  Notify the user 
# and release the semaphore.
#

          @pemit %# = after(before(r(4), ENDABORT), ABORT); 
          @no r(0)
        },

        strlen(r(4)), 
        {
#
# Could not find any letters to match the specified input parameter.
# Notify the user and release the semaphore.
#

          @pemit %# = u(no_match, +save, u(format_request, trim(%0)), r(3)); 
          @no r(0)
        },
        {
#
# Reorder the list of letters to 'save' into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#

          @dolist 
 
            [setq(4, u(filter_list, setunion(r(4), ), r(1)))]

          r(4) = 
          {
#
# Only add the 'S' (saved) flag if it is not already there.
#

            &in-##-flags [r(0)] = setunion(get(r(0)/in-##-flags) S, )
          }; 

          @swi 1 = 1, 
          {
#
# Finished saving the letter(s) specified. 
# Set the 'current letter' to be the last one 'saved'.
# Notify user and release the semaphore.
#

            &[u(which_current_letter, r(0))] [r(0)] = first(revwords(r(4))); 

            @pemit %# = Message(s) [u(convert_nums, r(4), r(1))]
              [u(format_request, trim(%0))] marked as 'saved' in 
              folder '[r(3)]'.; 
            @no r(0)
          }
        }
      }
    }

-
###############################################################################
#
#                               U N S A V E          
#
###############################################################################
&UNSAVE_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to remove a tag previously set by a call to
#   +save.  +unsave with no parameter will unsave the last mail message read.
#   Either a keyword (listed below) or a list of mail numbers may be
#   specified.  Example:  +unsave 3..5, +unsave saved
#
# Command Format:
#
#   +unsave [keyword or a list of letter numbers]
#
#   The following keywords are available to specify the scope of +unsave:
#
#     all, current (default), deleted, first, last, marked, next, previous,
#     saved, unread, author:<name>, subject:<text>, text:<text fragment>
#
#   Only the first character of the keyword needs to be specified
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of letters in active folder
#   2 - current letter
#   3 - list of internal message numbers reflecting the specified criteria
#   4 - name of active folder
#

  $+unsave*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    strmatch(escape(%0), *\[*), 
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    eq(strlen(r(0)), 0), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(get_folder_in_list, r(0)))]
          [setq(2, u(get_folder_current_letter, r(0)))]

#
# Interpret user input and convert into a list of internal mail numbers
#
          [setq(3, u(expand_letter_range, %0, r(1), r(2)))]
          [setq(4, u(get_active_folder, r(0)))]

        0 = strlen(r(1)), 
        {
#
# Mailbox is empty.  Notify user and release semaphore.
#

          @pemit %# = u(nomail, r(4));
          @no r(0)
        },

        not(strmatch(r(3), *ABORT*)), 
        {
#
# Error detected in input parameter.  Notify user and release semaphore.
#

          @pemit %# = after(before(r(3), ENDABORT), ABORT); 
          @no r(0)
        },

        strlen(r(3)), 
        {
#
# Could not find any letters to match the specified input parameter.
# Notify user and release the semaphore.
#

          @pemit %# = u(no_match, +unsave, u(format_request, trim(%0)), r(4)); 
          @no r(0)
        },
        {
#
# Reorder the list of letters to 'unsave' into the same order as is in 
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#


          @dolist 

            [setq(3, u(filter_list, setunion(r(3), ), r(1)))]

          r(3) = 
          {
            &in-##-flags [r(0)] = s(remove(get(r(0)/in-##-flags), S))
          }; 

          @swi 1 = 1,
          {
#
# Finished removing the 'S' flag from the letter(s) specified. 
# Set the 'current letter' to be the last one unsaved.
# Notify user and release the semaphore.
#

            &[u(which_current_letter, r(0))] [r(0)] = first(revwords(r(3))); 

            @pemit %# = The 'S' flag has been removed from 
              message(s) [u(convert_nums, r(3), r(1))]
              [u(format_request, trim(%0))] 
              in folder '[r(4)]'.; 

            @no r(0)
          }
        }
      }
    }

-
###############################################################################
#
# WRITE related commands:
#
###############################################################################


###############################################################################
#
#                                M A I L         
#
###############################################################################
&MAIL_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to start the letter writing process.
#
# Command Format:
#
#   +mail <name1>[,] [<name2> ...]=<Subject line text>
#
#   You may specify any number of players, personal mail aliases, or 
#   global mail aliases to send the letter to, and a subject line.  
#   Both of these may be changed any time before the letter is actually
#   sent, using the commands +edit to and +edit subject.  Once issued,
#   the mail system will respond with instructions for writing your letter.
#
#   Note:  If the players' names contain spaces, each name should be 
#   separated by a comma.  Example:  +mail Joe Jones, Jane Smith, wizards=FYI
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of names specified by the user converted to dbrefs
#   2 - list of mail aliases specified by the user
#   3 - list of dbrefs for all destinations (player and expanded aliases) 
#   4 - mailbox dbref created for user who had no mailbox
#   6 - global mail aliases
#   7 - personal mail aliases
#

  $+mail *=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = or(strmatch(escape(%0), *\[*), strmatch(escape(%1), *\[*)),
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    eq(strlen(r(0)), 0), 
    {
#
# No mailbox exists for user
#

      @swi/first  

#
# Convert list of names specified by the user into dbrefs
#
        [setq(6, get(%vm/global-mail-aliases))]
        [setq(1, u(identify_to_list, {%0}, %vm))]
        [setq(2, u(get_aliases, 
                   {%0}, 
                   #0, 
                   r(6), 
                 ))]
        [setq(3, 
          setunion(
            [r(1)] 
            [u(expand_aliases, r(2), #0, %b, r(6), )], 
          )
        )]
 
      1 = strmatch(r(1), *ABORT*),
      {
#
# Error detected in input parameter.
#
        @pemit %# = secure(after(before(r(1), ENDABORT), ABORT))
      },

      eq(strlen(r(3)), 0),
      {
        @pemit %# = You must specify a destination for this piece of mail.
      },

      {
#
# Create a new mailbox.
#

        @create %N's Mailbox; 
        @set [setq(4, con(me))]r(4) = quiet; 
        @drain [r(4)]; 
        @tel r(4) = %vm; 
        &mailbox_%# %vm = r(4); 
        @trigger %vm/add_mailbox = r(4); 
        &owner_dbref [r(4)] = %#; 
        @startup [r(4)] = {@drain me; @no me}; 
        @set r(4) = safe; 
        &current_folder [r(4)] = u(get_inbox, %#); 
        &folder-list [r(4)] = get(r(4)/current_folder); 
 
        &mail-in-progress [r(4)] = true; 
        &mail-in-progress-to [r(4)] = u(pretty_dist, r(2), #0, , r(6), r(1)); 
        &mail-in-progress-to-expanded [r(4)] = r(3); 
        &mail-in-progress-subject [r(4)] = %1; 

        @pemit %# = 

            switch(
              u(get_mode_option, %#),
              verbose, u(enter_msg_verbose),
              u(enter_msg_terse)
            );

        @no r(4)
      }
    },

    {

#
# User has a mailbox. Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

#
# Convert list of names specified by the user into dbrefs
#
            [setq(1, u(identify_to_list, {%0}, r(0)))]
            [setq(7, get(r(0)/alias-list))]
            [setq(6, get(%vm/global-mail-aliases))]
            [setq(2, u(get_aliases, {%0}, r(0), r(6), r(7)))]

        1 = strmatch(get(r(0)/mail-in-progress), true),
        {
#
# User is already in the middle of writing a mail message.
#

          @pemit %# = You are already in the middle of sending a message. %b
            You must complete that one before you begin another.; 
          @no r(0)
        },

        eq(strlen(%0), 0),
        {
#
# No destination specified for this piece of mail.
#

          @pemit %# = You must specify a destination for this piece of mail.; 
          @no r(0)
        },

        strmatch(r(1), *ABORT*),
        {
#
# Error detected in input parameter.
#
          @pemit %# = secure(after(before(r(1), ENDABORT), ABORT)); 
          @no r(0)
        },

        {
#
# Otherwise, everything looks fine so far, start storing the data 
# in the user's mailbox.
#

          &mail-in-progress [r(0)] = true; 

          &mail-in-progress-to [r(0)] = 
            u(pretty_dist, r(2), r(0), r(7), r(6), r(1)); 

          &mail-in-progress-to-expanded [r(0)] = 
              [r(1)] [u(expand_aliases, r(2), r(0), %b, r(6), r(7))]; 

          &mail-in-progress-subject [r(0)] = %1; 

          @swi words(get(r(0)/mail-in-progress-to-expanded)) = 0,
          {
#
# Destinations specified could not be expanded into dbrefs.
#

            @pemit %# = You must specify a destination for this piece of mail.; 
            &mail-in-progress [r(0)] = false; 
            &mail-in-progress-to [r(0)] ; 
            &mail-in-progress-to-expanded [r(0)] ; 
            &mail-in-progress-subject [r(0)] ; 
            @no r(0)
          },
          {
#
# Notify the user of the next step.
#

            @pemit %# = 
              switch(
                u(get_mode_option, %#),
                verbose, u(enter_msg_verbose),
                u(enter_msg_terse)
              ); 

            @no r(0)
          }
        }
      }
    }

-
&MAIL_NO_PARAM #3478 = 

  $+mail: 

    @pemit %# = You must specify the name(s) of the individual(s) that you 
      wish to send mail to, and an optional 'subject' line.%b (format: +mail 
      <name1 name2 .. nameN>=<Subject line>)

-
###############################################################################
#
#                              +N O T E                              
#
###############################################################################
&NOTE_COMMAND #3478 = 
#
# PURPOSE:
#
#   This command may be used to send a small note to yourself.
#
# Command Format:
#
#   +note <text>
#
# Registers Used:
#
#   0 - dbref of mailbox
#

  $+note*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = 

    strlen(%0), 
    {
#
# No text specified.
#

      @pemit %# = No text specified for note.%b Syntax:%b +note <text>
    },

    strlen(r(0)), 
    {
#
# Mailbox doesn't exist, store_letter requires the 'sender' to have a 
# mailbox.
#
      @create %N's Mailbox;
      @set [setq(0, con(me))]r(0) = quiet;
      @drain [r(0)];
      @no r(0);
      @tel r(0) = %vm;
      &mailbox_%# %vm = r(0);
      @trigger %vm/add_mailbox = r(0); 
      &owner_dbref [r(0)] = %#;
      @startup [r(0)] = {@drain me; @no me};
      @set r(0) = safe;
      &mail-in-progress [r(0)] = false;
      &current_folder [r(0)] = u(get_inbox, %#);
      &folder-list [r(0)] = get(r(0)/current_folder); 

      @tr me/store_letter = 
        r(0), 
        Personal Note, 
        %N, 
        %#, 
        , 
        , 
        , 
        , 
        , 
        escape(trim(edit(%0, \\, ))); 

      @pemit %# = A personal note has been stored in your mailbox.
    },

    {
      @tr me/store_letter = 
        r(0), 
        Personal Note, 
        %N, 
        %#, 
        , 
        , 
        , 
        , 
        , 
        escape(trim(edit(%0, \\, ))); 

      @pemit %# = A personal note has been stored in your mailbox.
    }

-
###############################################################################
#
#                                   -           
#
###############################################################################
&DASH_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to add text to a body of a letter in progress.
#
# Command Format:
#
#   -<text to add to letter>
#
#   Once a letter has begun, using the +mail, +reply or +forward command, 
#   the '-' command is used to add text to the body of the letter.  
#   Consecutive commands append text to the letter in process. 
#   Whatever is configured for mail option 'separator' is used to
#   separate the text (either a blank or a carriage return).
#
#   Issuing a '-' without any text following it will show the 
#   available options.
#
#   You may perform any other mush actions while you are entering a
#   message, so long as they do not start with the '-' character.
#
#   Standard MUSH substitutions may be used, %r to insert a carriage
#   return, %t to insert a tab character, etc.
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - size of mail in progress
#   4 - body
#
#   register 2 is used in helper function size_of_mail_in_progress
#   register 3 is used in get_separator_option
#

  $-*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = strmatch(%0, -),,
#
# Command is '--', ignore and let the $-- handler handle it.
#

    not(strmatch(type(%#), PLAYER)),
    {
      @pemit %# = u(not_player)
    },

    eq(strlen(r(0)), 0),
    {
#
# User does not have a mailbox and therefore cannot be writing mail.
#

      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(4, get(r(0)/mail-in-progress-body))]

        1 = strmatch(get(r(0)/mail-in-progress), false),
        {
#
# User is not writing mail.
#

          @pemit %# = u(not_writing_mail); 
          @no r(0)
        },

        eq(strlen(escape(%0)), 0),
        {
#
# '-' Single dash specified, show user help information
#

          @pemit %# = u(finish_msg_verbose); 
          @no r(0)
        },

        {
#
# Add text to mail message in progress.
#

          &mail-in-progress-body [r(0)] = 
            switch(words(r(4)), 0, %0, 
            escape(trim(edit([r(4)][u(get_separator_option, %#)]%0, \\\\, )))); 

          @pemit %# = 

              [setq(1, u(size_of_mail_in_progress, r(0)))]

            [u(text_added_notification)]
            [switch(
              gt(r(1), 4000), 
              1, 
                %b%bWarning, message is [sub(4000, r(1))] characters 
                  too long and will be truncated.
              ,
            )]; 

          @no r(0)
        }
      }
    }

-
&SIZE_OF_MAIL_IN_PROGRESS #3482 =

#
# This is a helper function for dash_command.
#
# Purpose:  Calculate as close as reasonably possible the size of
# the current mail message in progress (from the perspective of
# the eventual reader).  This is done so the mail writer has
# an idea if the message is getting too long for the reader to
# see it all.  The reader is limited by a 4000 byte pemit.
#
# %0 - dbref of mailbox
#
# 196 comes from:  the message line, the from line, the to line,
# the subject line, the options line, plus some various carriage
# returns.
#
# Need to assume the receiver is reading in standard format since
# we don't know (for sure) at this stage.
#

  add(
    196, 
    mul(strlen(u(equal_line)), 2), 
    strlen(u(dash_line)), 
    strlen(u(%0/mail-in-progress-subject)), 
    strlen(u(%0/mail-in-progress-to)), 

    switch(
      strlen(get(%0/mail-in-progress-cc)), 
      0, 0, 
      {[add(11, strlen(u(%0/mail-in-progress-cc)))]}
    ), 

    switch(
      strlen(get(%0/mail-in-progress-bcc)), 
      0, 0, 
      {[add(11, strlen(u(%0/mail-in-progress-bcc)))]}
    ), 

    strlen(u(%0/mail-in-progress-body)), 

    [setq(2, get(%0/mail-in-progress-flags))]

    switch(
      words(r(2)), 
      0, 0, 

      {[add(
        11, 

        switch(match(r(2), RR), 0, 0, strlen(v(mail_flag_rr))), 

        switch(match(r(2), P), 0, 0, strlen(v(mail_flag_p))), 

        switch(match(r(2), U), 0, 0, strlen(v(mail_flag_u))), 

        switch(match(r(2), R), 0, 0, strlen(v(mail_flag_r))
        ), 

        mul(sub(words(r(2)), 1), 2)
      )]}
    )
  )

-
###############################################################################
#
#                                   --          
#
###############################################################################
&DOUBLE_DASH_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to send a letter.
#
# Command Format:
#
#   --
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of dbrefs to deliver to (to, cc, bcc)
#

  $--: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(r(0)),
    {
      @pemit %# = u(not_writing_mail)
    },
    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

#
# Grab the complete destination list.  Includes TO, CC and BCC.
# Weed out duplicates.
#
          [setq(1, u(get_final_delivery_list, r(0)))]

        1 = strmatch(get(r(0)/mail-in-progress), false), 
        {
#
# There is no mail in progress to send.
#

          @pemit %# = You do not have a mail message ready to send.; 
          @no r(0)
        },

        eq(strlen(r(1)), 0), 
        {  
          @pemit %# = You do not have a destination specified.; 
          @no r(0)
        },

        {
          @trigger me/store_letter = 
            r(0), 
            get(r(0)/mail-in-progress-subject), 
            get(r(0)/mail-in-progress-to), 
            get(r(0)/mail-in-progress-to-expanded), 
            get(r(0)/mail-in-progress-cc), 
            get(r(0)/mail-in-progress-cc-expanded), 
            get(r(0)/mail-in-progress-bcc), 
            get(r(0)/mail-in-progress-bcc-expanded), 
            get(r(0)/mail-in-progress-flags), 
            get(r(0)/mail-in-progress-body); 

          @tr me/cleanup_send = %#, r(0)
        }
      }
    }

-
&STORE_LETTER #3482 = 
#
# PURPOSE:  store an outgoing letter
# 
# INPUT:
#
#   %0 - dbref of mailbox for sender
#   %1 - subject of letter
#   %2 - TO:   (prettified)
#   %3 - TO:   (dbrefs)
#   %4 - CC:   (prettified)
#   %5 - CC:   (dbrefs)
#   %6 - BCC:  (prettified)
#   %7 - BCC:  (dbrefs)
#   %8 - flags
#   %9 - text of letter
#
# OUTPUT:
# 
#   None.
#
# For the sending mailbox:
#
#   Update field:
#
#     out-list
#     out-list-current (possibly)
#
#   Set fields:
# 
#     out-<num>-time_sent      date/time mail was sent
#     out-<num>-subject        subject of letter
#     out-<num>-to             TO:    (prettified)
#     out-<num>-cc             CC:    (prettified)
#     out-<num>-bcc            BCC:   (prettified, used during +review)
#     out-<num>-bcc-expanded   dbrefs (used during +read)
#     out-<num>-text           body of mail message
#     out-<num>-replyall_to    sender, to & cc dbrefs
#     out-<num>-dist           total distribution list
#     out-<num>-held           list of who still has a pointer to this letter
#
# For each receiving mailbox:
#
#   Update field:
# 
#     in-list-<inbox or filter folder>
#
#   Set fields:
#
#     in-<num>-time_read        date/time mail was last read
#     in-<num>-flags            U R RR P D M S A<dbref>AEND
#     in-<num>-note             registered via +add note
#     in-<num>-location         <dbref> <number> where letter is stored
#
# Registers used:
#
#   0 - internal number to store outgoing message in
#   1 - dbref of existing destination mailbox 
#   2 - dbref of newly created destination mailbox
#   3 - dbref of sender
#   4 - mail_sig of sender
#   6 - internal number to store incoming message information in
#   7 - list of messages in in-list-<inbox> for destination mailbox
#   8 - final distribution list
#   9 - inbox
#

#
# Store information about outgoing mail in sender's mailbox.
#

  &[setq(0, u(free_num, get(%0/out-list)))]out-[r(0)]-time_sent %0 = time(); 
  &[setq(3, get(%0/owner_dbref))]out-[r(0)]-subject %0 = %1; 
  &out-list %0 = [get(%0/out-list)] [r(0)]; 
  &out-list-current %0 = 
    switch(words(get(%0/out-list)), 1, r(0), get(%0/out-list-current)); 
  &out-[r(0)]-to %0 = %2; 
  &out-[r(0)]-cc %0 = %4; 
  &out-[r(0)]-bcc %0 = %6; 
  &out-[r(0)]-bcc-expanded %0 = %7; 
  &out-[r(0)]-text %0 = 
      %9
      [switch(
        [setq(4, get(r(3)/MAIL_SIG))]
        strlen(r(4)), 0,, %r[r(4)]
      )]; 
  &out-[r(0)]-replyall_to %0 = setunion([r(3)] %3 %5, ); 
  &out-[r(0)]-held %0 = [setq(8, 
    setunion(iter(setunion(%3 %5 %7, ), u(autoforward_test, ##)), ))]r(8); 
  &out-[r(0)]-dist %0 = iter(r(8), ##:); 

  @dolist r(8) = 
  {

    @swi/first 

      [setq(1, get(%vm/mailbox_##))]
      [setq(9, u(folder_to_store_into, r(1), get(%0/owner_dbref), %1, ##))]

    1 = 
    and(
      strmatch(type(##), PLAYER), 
      eq(strlen(r(1)), 0)
    ),
    {
#
# Mailbox doesn't exist for this destination player, create one.
#
      @create [name(##)]'s Mailbox; 
      @set [setq(2, con(me))]r(2) = quiet; 
      @drain [r(2)]; 
      @tel r(2) = %vm; 
      &mailbox_## %vm = r(2); 
      @trigger %vm/add_mailbox = r(2); 
      &owner_dbref [r(2)] = ##; 
      @startup [r(2)] = {@drain me; @no me}; 
      @set r(2) = safe; 
      &mail-in-progress [r(2)] = false; 
      &current_folder [r(2)] = r(9); 
      &folder-list [r(2)] = r(9); 

#
# Store information about newly received letter.
#

      &in-list-[r(9)] [r(2)] = 0; 
      &current_letter-[r(9)] [r(2)] = 0; 
      &in-0-time_read [r(2)] = 0; 
      &in-0-flags [r(2)] = %8; 
      &in-0-note [r(2)] ; 
      &in-0-location [r(2)] = %0 [r(0)]; 
      @edit %0/out-[r(0)]-dist = ##:,##:0; 

#
# Notify receiver that mail message has arrived ('cept if it is
# a result of a '+note' command.
#
      @pemit ## = 
        switch(%1, Personal Note,, {u(delivery_notification, 
          r(3), 
          sign(match(%8, u)),
          sign(match(%8, p)),
          sign(match(%8, rr)),
          sign(match(%8, r)), 
          secure(r(9))
        )}); 

      @no r(2)
    }, 

    strmatch(type(##), PLAYER), 
    {
#
# Mailbox exists.  Store information about newly received mail.
#

      &folder-list [r(1)] = setunion([r(9)] [get(r(1)/folder-list)], ); 

      &in-list-[r(9)] [r(1)] = 

          [setq(6, u(free_num, u(get_all_in_lists, r(1))))]
          [setq(7, get(r(1)/in-list-[r(9)]))]

        s([r(7)] [r(6)]); 

      &current_letter-[r(9)] [r(1)] = 
        switch(words(r(7)), 0, r(6), get(r(1)/current_letter-[r(9)])); 

      &in-[r(6)]-time_read [r(1)] = 0; 
      &in-[r(6)]-flags [r(1)] = %8; 
      &in-[r(6)]-note [r(1)] ; 
      &in-[r(6)]-location [r(1)] = %0 [r(0)]; 

      @edit %0/out-[r(0)]-dist = ##:,##:[r(6)]; 

#
# Notify receiver that mail message has arrived ('cept if it is
# a result of a '+note' command or rejected).
#

      @pemit ## = 

        switch(1, 
          strmatch(%1, Personal Note),, 
          sign(words(get(r(1)/reject_msg))),, 
          {u(delivery_notification, 
          r(3), 
          sign(match(%8, u)),
          sign(match(%8, p)),
          sign(match(%8, rr)),
          sign(match(%8, r)), 
          secure(r(9))
        )}); 

      @swi 1 = 

      strmatch(%1, On Vacation),,
#
# Avoid looping 'vacation' messages.
#

      strmatch(%1, Letter Rejected),,
#
# Avoid looping 'reject' messages.
#

      sign(words(get(r(1)/reject_msg))), 
      {
#
# Reject set, remove the letter from the mailbox.
#
        @tr me/remove_letter = 
          %0, 
          r(0), 
          get(r(1)/owner_dbref), 
          r(1), 
          r(6), 
          r(9); 

#
# Store a letter in originator's mailbox indicating that the
# mail was rejected, and why.
#
        @tr me/store_letter = 
          r(1), 
          Letter Rejected, 
          name(get(%0/owner_dbref)), 
          get(%0/owner_dbref), 
          ,  
          , 
          ,  
          , 
          , 
          {Message with subject line "%1" has been rejected 
          by [name(get(%0/owner_dbref))]'s mailbox.
          %r%r----- Reject Message -----
          %r%r[get(r(1)/reject_msg)]
          }
      },

      sign(words(get(r(1)/vacation))), 
      {
#
# Store a letter in the originator's mailbox with the
# registered vacation text from the destination mailbox.
#
        @tr me/store_letter = 
          r(1), 
          On Vacation, 
          name(get(%0/owner_dbref)), 
          get(%0/owner_dbref), 
          ,  
          , 
          ,  
          , 
          , 
          {Message with subject line "%1" has been stored in 
          [name(get(%0/owner_dbref))]'s mailbox.
          %r%r----- Vacation Message -----
          %r%r[get(r(1)/vacation)]
          }
      }
    }, 
    
    {
      @pemit get(%0/owner_dbref) = Unable to deliver message.
    } 
  }

-
&REMOVE_LETTER #3482 = 

#
# PURPOSE:  Remove a letter from an incoming mailbox
#
# DESCRIPTION:
#
#   Remove all references to the letter in the received (IN) mailbox.
#   Remove this single reference in the originator's (OUT) mailbox.
#   If all references to this letter have been removed, entirely
#   remove letter from OUT mailbox.  Check to see if either the
#   IN or OUT mailbox may be deleted.
#
# %0 - dbref of mailbox (OUT)
# %1 - internal letter number to remove (OUT)
# %2 - dbref of 'holder'
# %3 - dbref of mailbox (IN)
# %4 - internal letter number to remove (IN)
# %5 - folder (IN)
#

#
# Nail attributes, incoming side.
#

  &in-%4-time_read %3 ; 
  &in-%4-flags %3 ; 
  &in-%4-note %3 ; 
  &in-%4-location %3 ; 
  &in-list-%5 %3 = s(remove(get(%3/in-list-%5), %4)); 

  @swi 1 = u(ok_to_dest_mailbox, %3),
  {
    @tr %vm/destroy_mailbox = name(get(%3/owner_dbref)), num(me), %3
  };  

#
# Remove 'holder' from the -held list for this letter.
#

  &out-%1-held %0 = s(remove(get(%0/out-%1-held), %2)); 

#
# If the 'held' is now none, no other players have a 'pointer' to
# this mail message.  Nail the attributes on the source mail object.
#

  @swi get(%0/out-%1-held) = ,
  {
    &out-%1-time_sent %0 ; 
    &out-%1-subject %0 ; 
    &out-%1-sender %0 ; 
    &out-%1-to %0 ; 
    &out-%1-cc %0 ; 
    &out-%1-bcc %0 ; 
    &out-%1-bcc-expanded %0 ; 
    &out-%1-text %0 ; 
    &out-%1-dist %0 ; 
    &out-%1-replyall_to %0 ; 
    &out-list %0 = s(remove(get(%0/out-list), %1)); 
    &out-list-current %0 = 
      switch(
        member(get(%0/out-list), get(%0/out-list-current)), 
        0, 
          first(revwords(get(%0/out-list))), 
        get(%0/out-list-current)
      ); 

    @swi 1 = u(ok_to_dest_mailbox, %0),
    {
      @tr %vm/destroy_mailbox = name(get(%0/owner_dbref)), num(me), %0;
    } 
  } 

-
###############################################################################
#
#                               P R O O F       
#
###############################################################################
&PROOF_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to proof read the mail message that you 
#   are currently writing.  It will show all information that is
#   registered for the piece of mail in progress.
#
# Command Format:
#
#   +proof
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - cc  
#   2 - bcc
#   3 - flags
#   4 - user's format option
#

  $+proof: 
   
    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(r(0)),
    {
      @pemit %# = You are not currently writing a mail message.
    },
    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {
        @pemit %# = 

          switch(
            get(r(0)/mail-in-progress),
            false, You are not currently writing a mail message.,
            {
              [setq(1, get(r(0)/mail-in-progress-cc))]
              [setq(2, get(r(0)/mail-in-progress-bcc))]
              [setq(3, get(r(0)/mail-in-progress-flags))]
              [setq(4, u(get_format_option, get(%#/mail_config_options)))]

              [switch(r(4), standard, {[u(equal_line)]%r})]

              To:[space(7)][trim(get(r(0)/mail-in-progress-to))]

              [switch(words(r(1)), 0,, %rCc:[space(7)][trim(r(1))])]

              [switch(words(r(2)), 0,, %rBcc:[space(6)][trim(r(2))])]

              %rSubject:%b%b[trim(get(r(0)/mail-in-progress-subject))]

              [switch(words(r(3)), 0,, %rFlags:%b%b%b%b)]

              [switch(match(r(3), u), 0,, [v(mail_flag_u)]%b%b)]

              [switch(match(r(3), rr), 0,, [v(mail_flag_rr)]%b%b)]

              [switch(match(r(3), r), 0,, [v(mail_flag_r)]%b%b)]
          
              [switch(match(r(3), p), 0,, [v(mail_flag_p)]%b%b)]

              [switch(r(4), standard, {%r[u(dash_line)]%r%r},%rText:[space(5)])]

              [get_eval(r(0)/mail-in-progress-body)]

              [switch(r(4), standard, {%r%r[u(equal_line)]})]

              %r[switch(
                u(get_mode_option, %#),
                verbose, u(finish_msg_verbose),
                u(finish_msg_terse)
              )]
            }
          ); 

        @no r(0)
      }
    }

-
###############################################################################
#
#                               T O S S 
#
###############################################################################
&TOSS_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to discard the current mail message in 
#   progress.
#
# Command Format:
#
#   +toss
#
# Registers Used:
#
#   0 - user's mailbox dbref
#

  $+toss: 
   
    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(r(0)),
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi get(r(0)/mail-in-progress) = false,
        {
          @pemit %# = u(not_writing_mail); 
          @no r(0)
        },
        {
          @pemit %# = The mail message has been discarded.; 

          &mail-in-progress [r(0)] = false; 
          &mail-in-progress-subject [r(0)]; 
          &mail-in-progress-to [r(0)]; 
          &mail-in-progress-to-expanded [r(0)]; 
          &mail-in-progress-cc [r(0)]; 
          &mail-in-progress-cc-expanded [r(0)]; 
          &mail-in-progress-bcc [r(0)]; 
          &mail-in-progress-bcc-expanded [r(0)]; 
          &mail-in-progress-flags [r(0)]; 
          &mail-in-progress-body [r(0)]; 

          @swi 1 = u(ok_to_dest_mailbox, r(0)),

          {
            @tr %vm/destroy_mailbox = %N, num(me), r(0); 
            @no r(0)
          },

          {
            @no r(0)
          }
        }
      }
    }

-
###############################################################################
#
#                                C C
#
###############################################################################
&CC_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to register a list of people to carbon
#   copy the current piece of mail being written.  The list may 
#   include player names, personal aliases and global aliases.
#
# Command Format:
#
#   +cc <list of people> 
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of dbrefs matching names specified for who to CC to
#   2 - global mail alias names
#   3 - personal mail alias names
#   4 - list of aliases specified
#

  $+cc*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *\[*)), 
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, u(identify_to_list, {%0}, r(0)))]
          [setq(2, get(%vm/global-mail-aliases))]
          [setq(3, get(r(0)/alias-list))]
          [setq(4, u(get_aliases, {%0}, r(0), r(2), r(3)))]

        1 = 

        strmatch(get(r(0)/mail-in-progress), false),
        {
          @pemit %# = u(not_writing_mail); 
          @no r(0)
        },

        strmatch(r(1), *ABORT*),
        {
#
# Error detected in input parameter.
#

          @pemit %# = secure(after(before(r(1), ENDABORT), ABORT)); 
          @no r(0)
        },
        {
#
# Set user displayable text for who to CC the letter to.
#

          &mail-in-progress-cc [r(0)] = 
            u(pretty_dist, r(4), r(0), r(3), r(2), r(1)); 
#
# Set the list of raw dbrefs for who to CC the letter to.
#

          &mail-in-progress-cc-expanded [r(0)] = 
            setunion([r(1)] [u(expand_aliases, r(4), r(0), %b, r(2), r(3))], ); 

          @pemit %# = 
            switch(
              words(get(r(0)/mail-in-progress-cc-expanded)), 
              0, 
                No carbon copy (cc) set., 
              The carbon copy (cc) line now reads:
                %b%b[get(r(0)/mail-in-progress-cc)]
            ); 

          @no r(0)
        }
      }
    }

-
&CC_NO_PARAM #3478=

  $+cc: 

    @pemit %# = You must specify the name of the individual(s) that you 
      wish to be carbon copied on this piece of mail.

-
###############################################################################
#
#                            E D I T   C C
#
###############################################################################
&EDIT_MAIL_CC #3478=
#
# PURPOSE:
#
#   This command may be used to edit the current 'CC' that is registered
#   for this piece of mail (originally registered via the +cc command).
#   The standard '^' and '$' may be used for <old text> to prepend and
#   append <new text> respectively.
#
# Command Format:
#
#   +edit cc=<old text>/<new text>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - old text with leading and trailing spaces removed
#   2 - new text with leading and trailing spaces removed
#   3 - user displayable CC before edit
#

  $+edit cc*=*/*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%2), *\[*)),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, lcstr(trim(%1)))]
          [setq(2, trim(%2))]
          [setq(3, lcstr(get(r(0)/mail-in-progress-cc)))]

        1 = strmatch(get(r(0)/mail-in-progress), false), 
        {
#
# No mail message is in progress. 
#

          @pemit %# = u(not_writing_mail); 
          @no r(0)
        },

        eq(words(get(r(0)/mail-in-progress-cc)), 0), 
        {

          @swi or(
                 strmatch(r(1), $), 
                 strmatch(r(1), ^), 
                 eq(strlen(r(1)), 0)
               ) = 1, 
          {
#
# There is no CC currently set.  Make the value of CC to be <new text>.
# User requested text to be either appended ($) or prefixed (^), or
# did not specify <old text> to replace.
#
            @tr me/cleanup_edit_mail_cc = %#, u(clean_dist, r(2)), r(0)
          },
          {
#
# There is no CC currently set and therefore <old text> is not present.
#
            @pemit %# = Unable to find '[r(1)]' in current value for CC.; 
            @no r(0)
          }
        },

        strmatch(r(1), $), 
        {
#
# Append <new text> to the end of the current CC.
#

          @tr me/cleanup_edit_mail_cc = 
            %#, 
            u(clean_dist, {[r(3)], [r(2)]}), 
            r(0)
        },

        strmatch(r(1), ^), 
        {
#
# Add <new text> to the beginning of the current CC.
#

          @tr me/cleanup_edit_mail_cc = 
            %#, 
            u(clean_dist, {[r(2)], [r(3)]}), 
            r(0)
        },

        strmatch(r(3), *[r(1)]*),
        {
#
# Replace <old text> with <new text>
#
          @tr me/cleanup_edit_mail_cc = 
            %#, u(clean_dist, edit(r(3), r(1), r(2))), r(0)
        },

        {
          @pemit %# = Unable to find '[r(1)]' in current value for CC.%b 
          Please check the exact format of the current value for CC by 
          doing a +proof.; 
          @no r(0)
        }
      }
    }

-
&CLEAN_DIST #3482 = 

  s(remove(edit(edit(%0, \(personal mail alias\), ), 
  \(global mail alias\), ), and))

-
&CLEANUP_EDIT_MAIL_CC #3482=
#
# PURPOSE:
#
#   This routine does cleanup processing for the +edit cc command.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - list of dbrefs and alias names
#   %2 - dbref of invoker's mailbox
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of dbrefs of who to CC to
#   2 - global mail aliases
#   3 - personal mail aliases
#   4 - aliases in %1
#

#
# Convert list of names specified by the user into dbrefs
#

  @swi 
  
    [setq(1, u(identify_to_list, {%1}, %2))]
    [setq(2, get(%vm/global-mail-aliases))]
    [setq(3, get(%2/alias-list))]
    [setq(4, u(get_aliases, {%1}, %2, r(2), r(3)))]

  r(1) = *ABORT*, 
  {
#
# Error detected in final CC list, no change.  
#

    @pemit %0 = secure(after(before(r(1), ENDABORT), ABORT)); 
    @no %2
  },
  {
#
# Set user displayable text for who to CC the letter to.
#

    &mail-in-progress-cc %2 = u(pretty_dist, r(4), %2, r(3), r(2), r(1)); 

#
# Set the list of raw dbrefs for who to CC the letter to.
#

    &mail-in-progress-cc-expanded %2 = 
      setunion([r(1)] [u(expand_aliases, r(4), %2, %b, r(2), r(3))], ); 

    @swi words(get(%2/mail-in-progress-cc-expanded)) = 0,
    {
#
# CC cleared.
#

      @pemit %0 = No carbon copy set.; 
      @no %2
    },
    {
#
# Show current value of CC
#

      @pemit %0 = The carbon copy (cc) line now reads:
        %b%b[get(%2/mail-in-progress-cc)]; 
      @no %2
    }
  }

-

  &edit_cc_blank #3478 = $+edit cc: @pemit %# = The syntax is 
    +edit cc=<old text>/<new text>.

-
###############################################################################
#
#                               B C C
#
###############################################################################
&BCC_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to register a list of people to blind 
#   carbon copy the current piece of mail being written.  The list may
#   include player names, personal aliases and global aliases.
#
# Command Format:
#
#   +bcc <list of people>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of dbrefs matching names specified for who to BCC to
#   2 - global mail alias names
#   3 - personal mail alias names
#   4 - list of aliases specified
#

  $+bcc*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *\[*)), 
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 
 
#
# Convert list of names specified by the user into dbrefs
#
          [setq(1, u(identify_to_list, {%0}, r(0)))]
          [setq(2, get(%vm/global-mail-aliases))]
          [setq(3, get(r(0)/alias-list))]
          [setq(4, u(get_aliases, {%0}, r(0), r(2), r(3)))]

        1 = strmatch(get(r(0)/mail-in-progress), false),
        {
          @pemit %# = u(not_writing_mail); 
          @no r(0)
        },

        strmatch(r(1), *ABORT*),
        {
#
# Error detected in input parameter.
#

          @pemit %# = secure(after(before(r(1), ENDABORT), ABORT)); 
          @no r(0)
        },
        {
#
# Set user displayable text for who to BCC the letter to.
#

          &mail-in-progress-bcc [r(0)] = 
            u(pretty_dist, r(4), r(0), r(3), r(2), r(1)); 

#
# Set the list of raw dbrefs for who to BCC the letter to.
#

          &mail-in-progress-bcc-expanded [r(0)] = 
            setunion([r(1)] [u(expand_aliases, r(4), r(0), %b, r(2), r(3))], ); 

          @pemit %# = 
            switch(
              words(get(r(0)/mail-in-progress-bcc-expanded)), 
              0,
                No blind carbon copy (bcc) set.,
              The blind carbon copy (bcc) line now reads:
                %b%b[get(r(0)/mail-in-progress-bcc)]
            ); 

          @no r(0)
        }
      }
    }

-
&BCC_NO_PARAM #3478=

  $+bcc: 

    @pemit %# = You must specify the name of the individual(s) that you 
      wish to be blind carbon copied on this piece of mail.

-
###############################################################################
#
#                            E D I T   B C C
#
###############################################################################
&EDIT_MAIL_BCC #3478=
#
# PURPOSE:
#
#   This command may be used to edit the current 'BCC' that is registered
#   for this piece of mail (originally registered via the +bcc command).
#   The standard '^' and '$' may be used for <old text> to prepend and
#   append <new text> respectively.
#
# Command Format:
#
#   +edit bcc=<old text>/<new text>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - old text with leading and trailing spaces removed
#   2 - new text with leading and trailing spaces removed
#   3 - list of names of current BCC before edit (names separated by commas)
#

  $+edit bcc*=*/*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%2), *\[*)),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, lcstr(trim(%1)))]
          [setq(2, trim(%2))]
          [setq(3, lcstr(get(r(0)/mail-in-progress-bcc)))]

        1 =  strmatch(get(r(0)/mail-in-progress), false), 
        {
#
# No mail message is in progress.
#

          @pemit %# = u(not_writing_mail); 
          @no r(0)
        },

        eq(words(get(r(0)/mail-in-progress-bcc)), 0),
        {

          @swi or(
                 strmatch(r(1), $), 
                 strmatch(r(1), ^), 
                 eq(strlen(r(1)), 0)
               ) = 1, 
          {
#
# There is no BCC currently set.  Make the value of BCC to be <new text>.
# User requested text to be either appended ($) or prefixed (^), or
# did not specify <old text> to replace.
#
            @tr me/cleanup_edit_mail_bcc = %#, u(clean_dist, r(2)), r(0)
          },
          {
#
# There is no BCC currently set and therefore <old text> is not present.
#
            @pemit %# = Unable to find '[r(1)]' in current value for BCC.; 
            @no r(0)
          }
        },

        strmatch(r(1), $),
        {
#
# Append <new text> to the end of the current BCC.
#

          @tr me/cleanup_edit_mail_bcc = 
            %#, 
            u(clean_dist, {[r(3)], [r(2)]}), 
            r(0)
        },

        strmatch(r(1), ^),
        {
#
# Add <new text> to the beginning of the current BCC.
#

          @tr me/cleanup_edit_mail_bcc = 
            %#, 
            u(clean_dist, {[r(2)], [r(3)]}), 
            r(0)
        },

        strmatch(r(3), *[r(1)]*),
        {
#
# Replace <old text> with <new text>
#

          @tr me/cleanup_edit_mail_bcc = 
            %#, u(clean_dist, edit(r(3), r(1), r(2))), r(0)
        },

        {
          @pemit %# = Unable to find '[r(1)]' in current value for BCC.%b 
          Please check the exact format of the current value for CC by
          doing a +proof.; 
          @no r(0)
        }
      }
    }

-
&CLEANUP_EDIT_MAIL_BCC #3482=
#
# PURPOSE:
#
#   This routine does cleanup processing for the +edit bcc command.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - user displayable value for BCC after action taken
#   %2 - dbref of invoker's mailbox
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of dbrefs of who to BCC to
#   2 - global mail aliases
#   3 - personal mail aliases
#   4 - aliases in %1
#

  @swi 
#
# Convert list of names specified by the user into dbrefs
#
    [setq(1, u(identify_to_list, {%1}, %2))]
    [setq(2, get(%vm/global-mail-aliases))]
    [setq(3, get(%2/alias-list))]
    [setq(4, u(get_aliases, {%1}, %2, r(2), r(3)))]

  r(1) = *ABORT*,
  {
#
# Error detected in final BCC list.  No change.
#

    @pemit %0 = secure(after(before(r(1), ENDABORT), ABORT)); 
    @no %2
  },
  {
#
# Set user displayable text for who to BCC the letter to.
#

    &mail-in-progress-bcc %2 = u(pretty_dist, r(4), %2, r(3), r(2), r(1)); 

#
# Set the list of raw dbrefs for who to BCC the letter to.
#

    &mail-in-progress-bcc-expanded %2 = 
      [r(1)] [u(expand_aliases, r(4), %2, %b, r(2), r(3))]; 

    @swi words(get(%2/mail-in-progress-bcc-expanded)) = 0,
    {
#
# BCC cleared.
#

      @pemit %0 = No blind carbon copy set.; 
      @no %2
    },
    {
#
# Show current value of BCC
#

      @pemit %0 = The blind carbon copy (bcc) line now reads:
        %b%b[get(%2/mail-in-progress-bcc)]; 
      @no %2
    }
  }

-
&EDIT_BCC_BLANK #3478 =

  $+edit bcc: @pemit %# = The syntax is +edit bcc=<old text>/<new text>.

-
###############################################################################
#
#                            E D I T   T O 
#
###############################################################################
&EDIT_MAIL_TO #3478=
#
# PURPOSE:
#
#   This command may be used to edit the current 'TO' that is registered
#   for this piece of mail (originally registered via the +mail command).
#   The standard '^' and '$' may be used for <old text> to prepend and
#   append <new text> respectively.
#
# Command Format:
#
#   +edit to=<old text>/<new text>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - old text with leading and trailing spaces removed
#   2 - new text with leading and trailing spaces removed
#   3 - list of names of current TO before edit (names separated by commas)
#

  $+edit to*=*/*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%2), *\[*)),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, lcstr(trim(%1)))]
          [setq(2, trim(%2))]
          [setq(3, lcstr(get(r(0)/mail-in-progress-to)))]

        1 = strmatch(get(r(0)/mail-in-progress), false),
        {
#
# No mail message is in progress.
#

          @pemit %# = u(not_writing_mail); 
          @no r(0)
        },

        eq(words(get(r(0)/mail-in-progress-to)), 0),
        {

          @swi or(
                 strmatch(r(1), $), 
                 strmatch(r(1), ^), 
                 eq(strlen(r(1)), 0)
               ) = 1, 
          {
#
# There is no TO currently set.  Make the value of TO to be <new text>.
# User requested text to be either appended ($) or prefixed (^), or
# did not specify <old text> to replace.
#
            @tr me/cleanup_edit_mail_to = %#, u(clean_dist, r(2)), r(0)
          },
          {
#
# There is no TO currently set and therefore <old text> is not present.
#
            @pemit %# = Unable to find '[r(1)]' in current value for TO.; 
            @no r(0)
          }
        },

        strmatch(r(1), $),
        {
#
# Append <new text> to the end of the current TO.
#

          @tr me/cleanup_edit_mail_to = 
            %#, 
            u(clean_dist, {[r(3)], [r(2)]}), 
            r(0)
        },

        strmatch(r(1), ^),
        {
#
# Add <new text> to the beginning of the current TO.
#

          @tr me/cleanup_edit_mail_to = 
            %#, 
            u(clean_dist, {[r(2)], [r(3)]}), 
            r(0)
        },

        strmatch(r(3), *[r(1)]*),
        {
#
# Replace <old text> with <new text>
#

          @tr me/cleanup_edit_mail_to = 
            %#, u(clean_dist, edit(r(3),r(1), r(2))), r(0)
        },
        {
          @pemit %# = Unable to find '[r(1)]' in current value for TO.%b 
          Please check the exact format of the current value for TO by
          doing a +proof.; 
          @no r(0)
        }
      }
    }

-
&CLEANUP_EDIT_MAIL_TO #3482=
#
# PURPOSE:
#
#   This routine does cleanup processing for the +edit to command.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - user displayable value for TO after action taken
#   %2 - dbref of invoker's mailbox
#
# Registers Used:
#
#   1 - list of dbrefs for TO list     
#   2 - global mail aliases
#   3 - personal mail aliases
#   4 - aliases in %1
#

  @swi 
 
#
# Convert list of names specified by the user into dbrefs
#
    [setq(1, u(identify_to_list, {%1}, %2))]
    [setq(2, get(%vm/global-mail-aliases))]
    [setq(3, get(%2/alias-list))]
    [setq(4, u(get_aliases, {%1}, %2, r(2), r(3)))]

  r(1) = *ABORT*, 
  {
#
# Error detected in input parameter.
#

    @pemit %0 = secure(after(before(r(1), ENDABORT), ABORT)); 
    @no %2
  },

  {
#
# Set user displayable text for who to TO the letter to.
#

    &mail-in-progress-to %2 = u(pretty_dist, r(4), %2, r(3), r(2), r(1)); 

#
# Set the list of raw dbrefs for who to send the letter to.
#

    &mail-in-progress-to-expanded %2 = 
      [r(1)] [u(expand_aliases, [r(4)], %2, %b, r(2), r(3))]; 

    @swi words(get(%2/mail-in-progress-to-expanded)) = 0,
    {
#
# TO cleared.
#

      @pemit %0 = No destination set.; 
      @no %2
    },
    {
#
# Show current value of TO
#

      @pemit %0 = The 'TO' line now reads:%b%b[get(%2/mail-in-progress-to)]; 
      @no %2
    }
  }

-
&EDIT_TO_BLANK #3478 = 

  $+edit to: @pemit %# = The syntax is +edit to=<old text>/<new text>.

-
###############################################################################
#
#                        E D I T   S U B J E C T                     
#
###############################################################################
&EDIT_MAIL_SUBJECT #3478=
#
# PURPOSE:
#
#   This command may be used to edit the current subject line that is 
#   registered for this piece of mail (originally registered via the 
#   +mail command). The standard '^' and '$' may be used for <old text> 
#   to prepend and append <new text> respectively.
#
# Command Format:
#
#   +edit subject=<old text>/<new text>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - old text with leading and trailing spaces removed
#   2 - new text with leading and trailing spaces removed
#

  $+edit sub*=*/*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%2), *\[*)),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, trim(%1))]
          [setq(2, trim(%2))]

        1 = strmatch(get(r(0)/mail-in-progress), false),
        {
          @pemit %# = u(not_writing_mail); 
          @no r(0)
        },

        eq(words(get(r(0)/mail-in-progress-subject)), 0),
        {

          @swi or(
                 strmatch(r(1), $), 
                 strmatch(r(1), ^), 
                 eq(strlen(r(1)), 0)
               ) = 1, 
          {
#
# There is no SUBJECT currently set.  Make the value of SUBJECT to be 
# <new text>.  User requested text to be either appended ($) or 
# prefixed (^), or did not specify <old text> to replace.
#
            &mail-in-progress-subject [r(0)] = r(2); 
            @pemit %# = The subject line now reads:
              %b%b[get_eval(r(0)/mail-in-progress-subject)]; 
            @no r(0)
          },
          {
#
# There is no SUBJECT currently set and therefore <old text> is not present.
#
            @pemit %# = Unable to find '[r(1)]' in current value for 
              SUBJECT.; 
            @no r(0)
          }
        },
 
        strmatch(r(1), $),
        {
          @edit r(0)/mail-in-progress-subject = r(1), {[r(2)]}; 
          @pemit %# = The subject line now reads:
            %b%b[get_eval(r(0)/mail-in-progress-subject)]; 
          @no r(0)
        },

        strmatch(r(1), ^),
        {
          @edit r(0)/mail-in-progress-subject = r(1), {[r(2)]}; 
          @pemit %# = The subject line now reads:
            %b%b[get_eval(r(0)/mail-in-progress-subject)]; 
          @no r(0)
        },

        strmatch(get(r(0)/mail-in-progress-subject), *[r(1)]*), 
        {
          @edit r(0)/mail-in-progress-subject = {[r(1)]}, {[r(2)]}; 
          @pemit %# = The subject line now reads:
            %b%b[get_eval(r(0)/mail-in-progress-subject)]; 
          @no r(0)
        },
        {
          @pemit %# = Unable to find '[r(1)]' in current value for 
            SUBJECT.; 
          @no r(0)
        }
      }
    }

-
&EDIT_SUBJECT_BLANK #3478=

  $+edit subject: @pemit %# = The syntax is +edit subject=<old text>/<new text>.

-
###############################################################################
#
#                            E D I T   T E X T 
#
###############################################################################
&EDIT_MAIL_TEXT #3478=
#
# PURPOSE:
#
#   This command may be used to edit the text for the mail message in 
#   progress.  The standard '^' and '$' may be used for <old text>
#   to prepend and append <new text> respectively.
#
# Command Format:
#
#   +edit text=<old text>/<new text>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - old text with leading and trailing spaces removed
#   2 - new text with leading and trailing spaces removed
#

  $+edit text*=*/*: 

    @swi 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(r(0)),
    {
      @pemit %# = u(not_writing_mail)
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, trim(%1))]
          [setq(2, trim(%2))]

        1 = strmatch(get(r(0)/mail-in-progress), false),
        {
          @pemit %# = u(not_writing_mail); 
          @no r(0)
        }, 

        eq(words(get(r(0)/mail-in-progress-body)), 0),
        {

          @swi or(
                 strmatch(r(1), $), 
                 strmatch(r(1), ^), 
                 eq(strlen(r(1)), 0)
               ) = 1, 
          {
#
# There is no TEXT currently set.  Make the value of TEXT to be 
# <new text>.  User requested text to be either appended ($) or 
# prefixed (^), or did not specify <old text> to replace.
#
            &mail-in-progress-body [r(0)] = escape(edit(r(2), \\,)); 
            @tr me/cleanup_edit_mail_text = %#, r(0)
          },
          {
#
# There is no TEXT currently set and therefore <old text> is not present.
#
            @pemit %# = Unable to find '[r(1)]' in current value for TEXT.; 
            @no r(0)
          }
        }, 

        strmatch(r(1), $),
        {
          @edit r(0)/mail-in-progress-body = r(1), {[escape(r(2))]}; 
          @tr me/cleanup_edit_mail_text = %#, r(0)
        },

        strmatch(r(1), ^),
        {
          @edit r(0)/mail-in-progress-body = r(1), {[escape(r(2))]}; 
          @tr me/cleanup_edit_mail_text = %#, r(0)
        },

        strmatch(get(r(0)/mail-in-progress-body), *[r(1)]*),
        {
          @edit r(0)/mail-in-progress-body = {[r(1)]}, {[escape(r(2))]}; 
          @tr me/cleanup_edit_mail_text = %#, r(0)
        },

        {
          @pemit %# = Unable to find '[r(1)]' in current value for TEXT.; 
          @no r(0)
        }
      }
    }

-
&CLEANUP_EDIT_MAIL_TEXT #3482=
#
# PURPOSE:
#
#   This routine does cleanup processing for the +edit text command.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - dbref of invoker's mailbox
#
# Registers Used:
#
#   0 - user's format option
#   1 - cc
#   2 - bcc
#   3 - flags
#

  &mail-in-progress-body %1 = escape(edit(get(%1/mail-in-progress-body),\\,)); 

  @pemit %0 = 

    [setq(0, u(get_format_option, get(%0/mail_config_options)))]
    [setq(1, get(%1/mail-in-progress-cc))]
    [setq(2, get(%1/mail-in-progress-bcc))]
    [setq(3, get(%1/mail-in-progress-flags))]

    [switch(r(0), standard, {[u(equal_line)]%r})]

    To:[space(7)][trim(get(%1/mail-in-progress-to))]

    [switch(words(r(1)), 0,, %rCc:[space(7)][trim(r(1))])]

    [switch(words(r(2)), 0,, %rBcc:[space(6)][trim(r(2))])]

    %rSubject:%b%b[get(%1/mail-in-progress-subject)]

    [switch(words(r(3)), 0,, %rFlags:%b%b%b%b)]

    [switch(match(r(3), u), 0,, [v(mail_flag_u)]%b%b)]

    [switch(match(r(3), rr), 0,, [v(mail_flag_rr)]%b%b)]

    [switch(match(r(3), r), 0,, [v(mail_flag_r)]%b%b)]

    [switch(match(r(3), o), 0,, [v(mail_flag_p)]%b%b)]

    [switch(r(0), standard, {%r[u(dash_line)]%r%r},%rText:%b%b)]

    [get_eval(%1/mail-in-progress-body)]

    [switch(r(0), standard, {%r%r[u(equal_line)]})]

    %r
    [switch(
      u(get_mode_option, %0), 
      verbose, u(finish_msg_verbose),
      u(finish_msg_terse)
    )]; 

  @no %1

-
&EDIT_TEXT_BLANK #3478=

  $+edit text: @pemit %# = The syntax is +edit text=<old text>/<new text>.

-
&EDIT_BLANK #3478=

  $+edit: 

    @pemit %# = You must specify what you wish to edit. The syntax of the 
      command is +edit <mail part>=<old text>/<new text>, where mail part 
      may be one of the following:%b%bto, cc, bcc, subject or text.

-
###############################################################################
#
#                         S E T   M A I L   F L A G
#
###############################################################################
&SET_MAIL_FLAG #3478=
#
# PURPOSE:
#
#   This command may be used to set or clear flags associated with the
#   mail message in progress.                                      
#
# Command Format:
#
#   +set mail flag <flag>  - sets the flag
#   +set mail flag !<flag> - clears the flag
#
#   Flags available:
#
#     URGENT (U)
#
#             Assigns an urgent priority to the mail
#
#     REPLY REQUESTED (RR)
#
#             Indicates the sender wishes a reply from the receiver of
#             the mail
#
#     PRIVATE (P)
#
#             Indicates the sender is requesting that the mail contents be
#             viewed in a 'for your eyes only' mode by the receiver
#
#     REGISTERED (R)
#
#             Perhaps the most intriguing flag. Mail sent with this flag
#             set will result in a mail message being sent back to the
#             originator when the person the mail was addressed to reads it.
#             This 'receipt notification' mail will tell you the date and
#             time the mail was read by the recipient, in addition to the
#             date and time of the original mail and the subject line.
#
# Registers Used:
#
#   0 - user's mailbox dbref
#

  $+set mail flag *: 

    @swi 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strlen(r(0)),
    {
      @pemit %# = u(not_writing_mail)
    },
    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 1 = 

        strmatch(get(r(0)/mail-in-progress), false),
        {
          @pemit %# = u(not_writing_mail); 
          @no r(0)
        },

#
# Set the flag
#
        strmatch(%0, r), 
        {
          @tr me/set_flag_guts = %#, R, v(mail_flag_r) (R), r(0)
        },

        strmatch(%0, rr), 
        {
          @tr me/set_flag_guts = %#, RR, v(mail_flag_rr) (RR), r(0)
        },

        strmatch(%0, u*), 
        {
          @tr me/set_flag_guts = %#, U, v(mail_flag_u) (U), r(0)
        },

        strmatch(%0, p*), 
        {
          @tr me/set_flag_guts = %#, P, v(mail_flag_p) (P), r(0)
        },

        strmatch(%0, rep*), 
        {
          @tr me/set_flag_guts = %#, RR, v(mail_flag_rr) (RR), r(0)
        },

        strmatch(%0, reg*), 
        {
          @tr me/set_flag_guts = %#, R, v(mail_flag_r) (R), r(0)
        }, 

#
# Clear the flag
#

        strmatch(%0, !r), 
        {
          @tr me/clear_flag_guts = %#, R, v(mail_flag_r) (R), r(0)
        },

        strmatch(%0, !rr), 
        {
          @tr me/clear_flag_guts = %#, RR, v(mail_flag_rr) (RR), r(0)
        },
 
        strmatch(%0, !u*), 
        {
          @tr me/clear_flag_guts = %#, U, v(mail_flag_u) (U), r(0)
        },
 
        strmatch(%0, !p*), 
        {
          @tr me/clear_flag_guts = %#, P, v(mail_flag_p) (P), r(0)
        },

        strmatch(%0, !rep*), 
        {
          @tr me/clear_flag_guts = %#, RR, v(mail_flag_rr) (RR), r(0)
        },

        strmatch(%0, !reg*), 
        {
          @tr me/clear_flag_guts = %#, R, v(mail_flag_r) (R), r(0)
        },

        {
          @pemit %# = That is not a valid mail flag. Available flags 
            are: 
            [v(mail_flag_u)] (U), 
            [v(mail_flag_rr)] (RR), 
            [v(mail_flag_p)] (P), 
            [v(mail_flag_r)] (R);  

          @no r(0)
        }
      }
    }

-
&CLEAR_FLAG_GUTS #3478=
-
&CLEAR_FLAG_GUTS #3482=
#
# PURPOSE:
#
#   This is a helper routine for 'set mail flag !<flag>'.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - flag to clear
#   %2 - user displayable value of flag to clear
#   %3 - dbref of user's mailbox
#
# Registers Used:
#
#   0 - flags
#

  @pemit %0 = 

      [setq(0, get(%3/mail-in-progress-flags))]

    switch(
      match(r(0), %1), 
      0, The %2 flag is not currently set for this mail message.,
      The %2 flag has been cleared.
    ); 

  &mail-in-progress-flags %3 = s(remove(r(0), %1)); 

  @no %3

-
&SET_FLAG_GUTS #3478=
-
&SET_FLAG_GUTS #3482=
#
# PURPOSE:
#
#   This is a helper routine for 'set mail flag <flag>'.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - flag to set
#   %2 - user displayable value of flag to set
#   %3 - dbref of user's mailbox
#
# Registers Used:
#
#   0 - flags
#

  @pemit %0 = 

      [setq(0, get(%3/mail-in-progress-flags))]

    switch(
      match(r(0), %1), 
      0, The %2 flag has been set., 
      The %2 flag is already set for this mail message.
    ); 

  &mail-in-progress-flags %3 = setunion(get(%3/mail-in-progress-flags) %1, ); 

  @no %3

-
&SET_MAIL_FLAG_BLANK #3478=

  $+set mail flag: 

    @pemit %# = You must specify which flag you wish to set. 
      Current options are: Private (P), Urgent (U), Registered (R) 
      and Reply Requested (RR).

-
###############################################################################
#
#                                S E N D         
#
###############################################################################
&SEND_COMMAND #3478=
#
# PURPOSE:
#
#   This command may be used to send a letter.
#
# Command Format:
#
#   +send
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of dbrefs to deliver to (to, cc, bcc)
#

  $+send: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER), 
    {
      @pemit %# = u(not_player)
    }, 

    strlen(r(0)), 
    {
      @pemit %# = u(not_writing_mail)
    }, 
    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

#
# Grab the complete destination list.  Includes TO, CC and BCC.
# Weed out duplicates.
#
          [setq(1, u(get_final_delivery_list, r(0)))]

        1 = strmatch(get(r(0)/mail-in-progress), false), 
        {
#
# There is no mail in progress to send.
#

          @pemit %# = You do not have a mail message ready to send.; 
          @no r(0)
        }, 

        eq(strlen(r(1)), 0), 
        {  
          @pemit %# = You do not have a destination specified.; 
          @no r(0)
        }, 

        {
          @trigger me/store_letter = 
            r(0), 
            get(r(0)/mail-in-progress-subject), 
            get(r(0)/mail-in-progress-to), 
            get(r(0)/mail-in-progress-to-expanded), 
            get(r(0)/mail-in-progress-cc), 
            get(r(0)/mail-in-progress-cc-expanded), 
            get(r(0)/mail-in-progress-bcc), 
            get(r(0)/mail-in-progress-bcc-expanded), 
            get(r(0)/mail-in-progress-flags), 
            get(r(0)/mail-in-progress-body); 

          @tr me/cleanup_send = %#, r(0)
        }
      }
    }

-
&GET_FINAL_DELIVERY_LIST #3478=
-
&GET_FINAL_DELIVERY_LIST #3482=
#
# PURPOSE:
#
#   This is a helper routine for '+send' and '--'. 
#
#   Basically, all it does it put together a single list of dbrefs that
#   a mail message is to be sent to, including all TO, CC and BCC
#   recipients (with duplicates weeded out).
#
# INPUT:
#
#   %0 - dbref of user's mailbox
#
# OUTPUT:
# 
#   list of dbrefs of who to send the message to
#

  trim(setunion(
    [get(%0/mail-in-progress-to-expanded)] 
    [get(%0/mail-in-progress-cc-expanded)] 
    [get(%0/mail-in-progress-bcc-expanded)], 
  ))

-
&CLEANUP_SEND #3482=
#
# PURPOSE:
#
#   This routine does cleanup processing for the '+send' and '--' commands.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - dbref of invoker's mailbox
#

#
# Notify user that mail has been sent.
#

  @pemit %0 = u(pickup_notification); 

#
# Clear temporary attributes in mailbox that are used during mail message
# composition.
#

  &mail-in-progress-subject %1; 
  &mail-in-progress-to %1; 
  &mail-in-progress-to-expanded %1; 
  &mail-in-progress-cc %1; 
  &mail-in-progress-cc-expanded %1; 
  &mail-in-progress-bcc %1; 
  &mail-in-progress-bcc-expanded %1; 
  &mail-in-progress-flags %1; 
  &mail-in-progress-body %1; 
  &mail-in-progress %1 = false; 

  @no %1

-
###############################################################################
#
#                         R E T R A C T
#
###############################################################################
&RETRACT_MAIL #3478=
#
# PURPOSE:
#
#   This command may be used to retract, or in other words, delete a 
#   letter you have previously sent but changed your mind about.  You
#   can only retract a letter if no one on the distribution has read 
#   it yet.
#
# Command Format:
#
#   +retract <letter number or keyword>
#
#   allowed keywords are:  first, next, previous, last, current
#
# Registers Used:
#
#   0 - dbref of invoker's mailbox 
#

  $+retract*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(strmatch(escape(%0), *\[*)), 
    {
#
# Function calls are not allowed within input parameters
#

      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
#
# No mailbox, therefore, no messages to retract.
#
      @pemit %# = There is no mail to retract in your mailbox.
    },

    {

      @wait r(0) = 
      {
          
        @swi/first 

          [setq(1, get(r(0)/out-list))]

#
# Interpret user input and convert into an internal mail number
#
          [setq(2,
            u(expand_single_letter_range,
            trim(%0), r(1), get(r(0)/out-list-current))
          )]

        1 = eq(strlen(r(1)), 0), 
        {
#
# Previously sent mail list is empty.  
# Notify user, clear global variable and release the semaphore.
#

          @pemit %# = There is no mail to retract in your mailbox.; 
          @no r(0)
        }, 

        strmatch(r(2), *ABORT*), 
        {
#
# Error detected in user input.  Notify user, clear global variables
# and release the semaphore.
#

          @pemit %# = after(before(r(2), ENDABORT), ABORT); 
          @no r(0)
        },

        u(any_read, r(0), r(2)), 
        {
          @pemit %# = One or more recipients of the designated letter 
            has already read it, therefore it cannot be retracted.; 
          @no r(0)
        }, 

        {
#
# Call RETRACT_MAIN to do the actual processing of the retract letter
#

          @tr me/retract_main = 
            %#, 
            r(0), 
            r(2), 
            [u(convert_nums, r(2), r(1))][u(format_request, trim(%0))] 
        }
      }
    }

-
&ANY_READ #3482 = 
#
# PURPOSE:
# 
#   Determine if a previously sent letter has been read by any of
#   the recipients.  This is a helper routine for +retract.
#
# %0 - dbref of mailbox
# %1 - internal number of sent mail
#
# Returns a 1 if any of the distributed copies of the specified 
# letter has been read.  A 0 otherwise.
#
# Registers used:
#
#   3 - dbref of destination
#   4 - internal mail number of destination
#

  strmatch(
    iter(
      get(%0/out-%1-dist), 
       
          [setq(3, get(#3480/mailbox_[before(##, :)]))]
          [setq(4, after(##, :))]

        and(
          strmatch(
            get(r(3)/in-[r(4)]-time_read), 
            0
          ), 
          strmatch(first(get(r(3)/in-[r(4)]-location)), %0), 
          strmatch(rest(get(r(3)/in-[r(4)]-location)), %1)
        )
    ), 
    *0*
  )

-
&CANCEL_MAIL #3478=
-
&RETRACT_MAIN #3478=
-
&RETRACT_MAIN #3482=
#
# PURPOSE:
#
#   This is a helper routine for '+retract' and '+destroy mailbox'.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - dbref of mailbox
#   %2 - internal number of letter to retract
#   %3 - formatted user request (or %b if called from destroy mailbox)
#
# Registers used:
#
# 0 - mail list
# 1 - current letter
# 2 - mailbox dbref for receiving mailbox
# 3 - internal number in receiving mailbox
#

  @dolist get(%1/out-%2-dist) = 
  {
    &

      [setq(2, get(%vm/mailbox_[before(##, :)]))]
      [setq(3, after(##, :))]

    in-[r(3)]-time_read [r(2)] ; 
    &in-[r(3)]-flags [r(2)] ; 
    &in-[r(3)]-note [r(2)] ; 
    &in-[r(3)]-location [r(2)] ; 
    @trigger me/remove_letter2 = r(2), r(3)
  }; 

  @swi 1 = 1, 
  {
    &out-list-current %1 = 
  
        [setq(0, get(%1/out-list))]
        [setq(1, get(%1/out-list-current))]

      switch(
        [r(1)]+[first(revwords(r(0)))], 
        %2+%2, first(rest(revwords(r(0)))), 
        %2+*, extract(r(0), add(member(r(0), %2), 1), 1), 
        r(1)
      );  
    
    &out-list %1 = s(remove(r(0), %2)); 
    &out-%2-time_sent %1 ; 
    &out-%2-subject %1 ; 
    &out-%2-to %1 ; 
    &out-%2-cc %1 ; 
    &out-%2-bcc %1 ; 
    &out-%2-bcc-expanded %1 ; 
    &out-%2-text %1 ; 
    &out-%2-replyall_to %1 ; 
    &out-%2-dist %1 ; 
    &out-%2-held %1 ; 
    @pemit %0 = Letter %3 has been retracted.; 
    @no %1
  }

-
&REMOVE_LETTER2 #3482 =
#
# %0 - dbref of mailbox
# %1 - internal letter number
#

  @dolist get(%0/folder-list) = 
  {
    &current_letter-## %0 = 
  
        [setq(0, get(%0/in-list-##))]
        [setq(1, get(%0/current_letter-##))]

      switch(
        [r(1)]+[first(revwords(r(0)))], 
        %1+%1, first(rest(revwords(r(0)))), 
        %1+*, extract(r(0), add(member(r(0), %1), 1), 1), 
        r(1)
      );  
    
    &in-list-## %0 = s(remove(get(%0/in-list-##), %1))
  }

-
###############################################################################
#
#                         R E V I E W   L E T T E R S
#
###############################################################################
&REVIEW_LETTERS #3478=
#
#   This command may be used to review (skim), all previously sent letters
#   that have not been deleted by all recipients.
#
#   Command Format:
#
#     +review 
#
#   The following keywords may be used to specify the scope of +review:
#
#     all, current, first, last, next, previous, to:<name>, subject:<text>,
#       text:<text fragment>
#
#   Registers Used:
#
#     0 - dbref of mailbox
#     1 - list of previously sent letters
#     2 - current letter (outgoing)
#     9 - user's format option
#

  $+review: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(1, get(r(0)/out-list))]
      [setq(2, get(r(0)/out-list-current))]
      [setq(9, u(get_format_option, get(%#/mail_config_options)))]

    0 = strlen(r(0)),
    {
#
# User has no mailbox.
#

      @pemit %# = u(no_sent_mail)
    },

    words(r(1)), 
    {
      @pemit %# = u(no_sent_mail)
    }, 

    {
      @pemit %# =
        [switch(r(9), standard,
          {[u(equal_line)]
          %r%r[center(List of Previously Sent Mail Messages, 78)]%r%r}
        )]
        [space(8)][ljust(Subject, 46)]%b%bSize%b%bSent
        %r[space(8)]-------[space(41)]----%b%b--------;

      @dolist get(r(0)/out-list) =
      {
        @pemit %# = u(review_brief, %#, ##, r(0), r(1), r(2))
      };

      @swi 1 = 1,
      {
        @pemit %# = switch(r(9), standard, %r[u(equal_line)],,)
      }
    }

-
&REVIEW_BRIEF #3482 = 
#
# PURPOSE:
#
#   Obtain summary information for one previously sent letter.
#   (This is a helper routine for +review)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - internal mail message number of letter to obtain information about
#   %2 - dbref of mailbox
#   %3 - list of previously sent letters
#   %4 - current letter
#
# OUTPUT
#
#   A single line of information for the letter specified in %1
#
# Registers Used:
#
#   2 - external letter number
#   3 - subject of letter                          
#

  [setq(2, member(%3, %1))]
  [setq(3, trim(get(%2/out-%1-subject)))]

#
# a '+' is shown before the summary line that represents the current letter
#
  [switch(%1, %4, +, %b)]

#
# The letter number
#
  [rjust([r(2)]\)%b%b, 7)]

#
# The subject of the letter, truncated to 46 characters
#
  [ljust(mid(r(3), 0, min(46, strlen(r(3)))), 48)]

#
# Size of the body of the letter, in bytes
#
  [ljust(strlen(u(%2/out-%1-text)), 6)]

#
# Date and time the letter was sent
#
  [mid(get(%2/out-%1-time_sent), 0, 16)]

-
###############################################################################
#
#                               R E V I E W 
#
###############################################################################
&REVIEW_LETTER #3478=
#
#   This command may be used to review, or read a letter you have   
#   previously sent to the specified person.  Mainly just to refresh
#   your mind about what you sent if you didn't +cc or +bcc yourself
#   on it.  It also is a reasonable thing to do before doing a +retract
#   letter.
#
#   The following keywords are available to specify the scope of +review:
#
#     all, current, first, last, next, previous, to:<name>, 
#       subject:<text>, text:<text fragment>
#
#   Only the first character of the keyword needs to be specified.
#
#   This command also accepts a list of numbers including ranges.%b 
#   For example:%b +review 1 3-5 8.%b Either a '-' or '..' may be used to 
#   indicate a range specification.  The numbers to be used are those
#   shown on +review letters output.
#
# Command Format:
#
#   +review <number or keyword>
#
# Registers Used:
#
#   0 - dbref of mailbox for <person>
#

  $+review*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    words(%0),,
#
# Let +review cmd handle it
#
   
    not(strmatch(escape(%0), *\[*)),
    {
#
# Function calls are not allowed within an input parameter
#

      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(no_sent_mail)
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, get(r(0)/out-list))]

#
# register 9 is used to hold the format option so as not to interfere
# with registers used in read_bulk_private.
#

          [setq(9, u(get_format_option, get(%#/mail_config_options)))]

        0 = strlen(r(1)), 
        {
#
# There is no stored (outgoing) mail in the user's mailbox.  
# Notify the user and release the semaphore.
#

          @pemit %# = u(no_sent_mail); 
          @no r(0)
        },

        {
         
          @swi/first 

#
# Interpret user input and convert into a list of internal mail numbers
# representing the user specified criteria.
#
          [setq(3, 
            u(expand_outgoing_letter_range, 
              %0, 
              r(1), 
              get(r(0)/out-list-current), 
              r(0)
            )
          )]

          1 = 

          strmatch(r(3), *ABORT*),
          {
#
# Error detected in input parameter.
#
# Notify the user and release the semaphore.
#

            @pemit %# = after(before(r(3), ENDABORT), ABORT);  
            @no r(0)
          },

          eq(strlen(r(3)), 0),
          {
#
# Could not find any letters to match the specified input parameter.
#
# Notify the user and release the semaphore.
#
            @pemit %# = 
              u(no_match, +review, u(format_request, trim(%0)), r(2)); 
            @no r(0)
          },
          {

            @dolist 

#
# Reorder the list of letters to 'review' into the same order as the 
# out-list attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
              [setq(3, u(filter_list, setunion(r(3), ), r(1)))]

            r(3) =
            {
#
# Display information to user about one outgoing letter
# 
              @pemit %# = u(read_bulk_private, %#, r(0), ##, r(9))
            }; 

            @swi 1 = 1, 
            {
#
# Set out-list-current to be the last letter reviewed
#

              &out-list-current [r(0)] = first(revwords(r(3))); 

#
# Finished showing information about the letter(s) specified.  Release
# the semaphore.  Extra switch is needed to keep the queue accurate.
#
              @swi 1 = 1,
              {
                @no r(0)
              }
            }
          }
        }
      }
    }

-
&READ_BULK_PRIVATE #3478=
-
&READ_BULK_PRIVATE #3482=
#
# PURPOSE:
#
#   Obtain detailed information for one letter in a mailbox.
#   (This is a helper routine for +review <number or keyword>)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - dbref of mailbox
#   %2 - internal number of letter
#   %3 - user's format option
#
# OUTPUT
#
#   Detailed information for one previously sent letter.
#
# Registers used:
#
#   4 - cc list
#   5 - bcc list
#   6 - external number
#   7 - out-list
#
 
    [setq(4, get(%1/out-%2-cc))]
    [setq(5, get(%1/out-%2-bcc))]
    [setq(7, get(%1/out-list))]
    [setq(6, member(r(7), %2))]

  [switch(%3, standard, {[u(equal_line)]%r})]

  [ljust(Message:, 10)][ljust([r(6)]/[words(r(7))], 9)]

#
# Date and time sent
#
  [rjust(Sent:%b%b[get(%1/out-%2-time_sent)], 59)]

#
# Who the mail was addressed to
#
  %r[ljust(To:, 10)][trim(get(%1/out-%2-to))]

#
# The CC list
#
  [switch(words(r(4)), 0,,%r[ljust(Cc:, 10)][trim(r(4))])]

#
# The BCC list
#
  [switch(words(r(5)), 0,,%r[ljust(Bcc:, 10)][trim(r(5))])]

#
# Still held by
#

  %r[ljust(Held By:, 10)][u(format_names, get(%1/out-%2-held))]

#
# Subject of the letter
#
  %r[ljust(Subject:, 10)][trim(get(%1/out-%2-subject))]

#
# line of dashes
#
  [switch(%3, standard, {%r[u(dash_line)]%r%r},%rText:[space(11)])]

#
# main body of text
#
  [u(%1/out-%2-text)]

  [switch(%3, standard, {%r%r[u(equal_line)]})]

-
###############################################################################
#
#           S T A T U S   O F   M A I L   S E N T   T O   <P E R S O N>
#
###############################################################################
# ==============================================================================
#
#             Status of messages you have sent to Brandy
#
# Subject                            Sent on           Read
# ------------------------------------------------------------------------------
# mail code                          Sun Jan 24 22:24  Sun Jan 24 23:00
# Re: The medical facilities         Mon Mar  1 12:46  Message has not been read
# ==============================================================================

&STATUS_OF_MAIL_SENT #3478=
#
# PURPOSE:
#
#   This command may be used to see the status of any messages from 
#   you in <person>'s mailbox.  If the message has been read, it will
#   show the date and time, if it has not been read, it will simply say
#   'Message has not been read'.  The display shows you the subject
#   line of the original mail message and the time it was sent.  
#   Obviously, once the mail has been deleted from <person>'s mailbox,
#   status for that letter will no longer be shown.
#
# Command Format:
#
#   +status of mail sent to <person>
#
# Registers Used:
#
#   0 - dbref of user's mailbox
#   1 - dbref of <person>'s mailbox
#   2 - list of letters in <person>'s mailbox
#   3 - list of letters in <person>'s mailbox from invoker
#   4 - user's format option
#   5 - subject
#   6 - time_read
#   7 - internal number of letter
#

  $+status of mail sent to *: 

    @swi 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(1, get(%vm/mailbox_[num(*%0)]))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    strmatch(type(*%0), PLAYER),
    {
      @pemit %# = [capstr(%0)] is not a player.
    }, 

    strlen(r(0)), 
    {
      @pemit %# = u(no_mail_from_you, [name(*%0)])
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(2, get(r(0)/out-list))]
          [setq(3, 
            s(iter(r(2), 
              switch(
                get(r(0)/out-##-dist), 
                [num(*%0)]:*, ##
              )
            ))
          )]

        0 = strlen(r(2)),
        {
          @pemit %# = u(no_mail_from_you, [name(*%0)]); 
          @no r(0)
        },

        strlen(r(3)), 
        {
#
# No letters from invoker in <person>'s mailbox.
#

          @pemit %# = u(no_mail_from_you, [name(*%0)]); 
          @no r(0)
        },

        {
#
# Show header info
#

          @pemit %# = 

              [setq(4, u(get_format_option, get(%#/mail_config_options)))]

            [switch(r(4), standard, 
              {[u(equal_line)]
              %r%r[space(13)]Status of messages you have sent 
                to [name(*%0)]%r%r}
            )]
            Subject[space(28)]Sent on[space(11)]Read

            [switch(r(4), standard, {%r[u(dash_line)]})]; 

#
# For each letter sent by invoker, show one line of information.
#

          @dolist r(3) = 
          {
            @pemit %# = 

              [setq(5, trim(get(r(0)/out-##-subject)))]
              [setq(6, get(r(1)/in-[after(extract(get(r(0)/out-##-dist), 
                match(get(r(0)/out-##-dist), [num(*%0)]:*), 1), :)]-time_read)
              )]

#
# The subject of the letter, truncated to 33 characters
#
              [ljust(mid(r(5), 0, min(33, strlen(r(5)))), 35)]

#
# Time letter was originally received.
#

              [mid(get(r(0)/out-##-time_sent), 0, 16)]%b%b

#
# Indication if the letter has been deleted, or has not been read yet.
#

              [switch([r(6)]+[words(r(6))], *+0, Message has been deleted, 
                0+*, Message has not been read, mid(convsecs(r(6)), 0, 16))]
          }; 

          @swi 1 = 1, 
          {
#
# Done, release semaphore.
#
            @pemit %# = switch(r(4), standard, u(equal_line),,); 
            @no r(0)
          }
        }
      }
    }

-
&STATUS_OF_MAIL_SENT2 #3478=
-
&STATUS_OF_MAIL_SENT_BLANK #3478=

  $+status of mail sent: 

    @pemit %# = The syntax is +status of mail sent to <person>.

-
###############################################################################
#
#                         A D M I N I S T R A T I O N
#
###############################################################################

###############################################################################
#
#                            M A I L   S T A T U S                           
#
###############################################################################
&MAIL_ADMIN_COMMAND #3478=
#
# PURPOSE:
#
#   This Wizard-only command may be used to obtain summary information 
#   about all mailboxes.  Information shown includes:  dbref, person
#   whose mailbox it is, if mail is in progress, how many letters have
#   between received total, how many personal mail aliases are defined, 
#   how many folders are defined, how many filters are defined, 
#   and how many letters are currently stored in the mailbox.  This 
#   command is slow, but 'queue nice'.
#
#   If the semaphore is off on a mailbox, this will be flagged as an
#   error.  An attempt is made to also flag if it is an invalid mailbox
#   and/or if the person that the mailbox is for, is no longer a player.
#
# Command Format:
#
#   +mail status
#
# Registers Used:
#
#   0 - user's format option
#

  $+mail status: 

    @swi hasflag(%#, wizard) = 1,
    {
      @pemit %# = 

          [setq(0, u(get_format_option, get(%#/mail_config_options)))]

        [switch(r(0), standard, 
          {[u(equal_line)]%r[space(26)]Summary status of mailboxes%r%r}
        )]
        Mailbox%b%bOwner[space(12)]Writing? %b Filters%b 
          Aliases%b Folders%b Sent%b Received
        [switch(r(0), standard, {%r[u(dash_line)]})]; 
        
        @tr me/continue_mail_status = 
          %#, 1, r(0), get(%vm/mailboxes_num_of_attributes)
    }, 

    {
      @pemit %# = Permission denied.
    }

-
&CONTINUE_MAIL_STATUS #3478=
-
&CONTINUE_MAIL_STATUS #3482=
#
# PURPOSE:
#
#   If the current MAILBOXES_%1 is empty:
#
#     If there are no more MAILBOXES_* to try, terminate display.
#
#     Otherwise, call this function recursively to process the next list
#     of mailbox dbrefs.
#
#   Otherwise, MAILBOXES_%1 is NOT empty:
#
#     Call SHOW_ONE_MAILBOX to begin processing the list of mailbox dbrefs.
#
#   (This is a helper routine for the +mail status command)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - index of which list of mailbox dbrefs to try next
#   %2 - u(get_format_option, %0)
#   %3 - get(%vm/mailboxes_num_of_attributes)
#
# Registers Used:
#
#   0 - list of mailboxes for the current mailboxes_* being worked on
#

    @swi/first 

      [setq(0, get(%vm/mailboxes_%1))]

    [strlen(r(0))]+[gt(%3, %1)] = 

    0+0,
    {
#
# The attribute mailboxes_%1 is empty.  If there are no more
# mailboxes_*'s to check, terminate display, otherwise move
# on to the next attribute containing a list of mailboxes.
#
      @pemit %0 = switch(%2, standard, u(equal_line), )
    },

    0+*, 
    {
      @tr me/continue_mail_status = %0, add(1, %1), %2, %3
    }, 

    {
      @tr me/show_one_mailbox = 
        %0, 
        r(0), 
        1, 
        words(r(0)),
        continue_mail_status, 
        0, 
        %1, 
        %2, 
        %3
    }

-
&EVALUATE_NEXT_LIST #3478 = 
-
&EVALUATE_NEXT_LIST #3482 = 
#
# PURPOSE:
#
#   For a list of mailbox dbrefs, apply the received test function
#   to the mailbox and return a list of dbrefs which pass the test.
#
#   (This is a helper routine for all the +mail status commands)
#
# INPUT
#
#   %0 - number indicating which mailboxes_* to process
#   %1 - test function
#   %2 - parameter to test function
#
# OUTPUT
#
#   Returns a list of mailbox dbrefs which pass the test function
#

  iter(
    get(%vm/mailboxes_%0),
    switch(
      u(%1, ##, %2),
        1,
      ##,

    )
  )

-
&SHOW_ONE_MAILBOX #3478 = 
-
&SHOW_ONE_MAILBOX #3482 = 
#
# PURPOSE:
#
#   For the given input parameters, process the indicated mailbox 
#   and then 'do the appropriate thing'. I.e., move to the next
#   mailbox in the current list, or move to the next list of 
#   mailboxes.  This is tediously slow, but queue nice, which
#   is important if there are a bazillion mailboxes.
#
#   (This is a helper routine for all the +mail status commands)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - list of mailbox dbrefs to process
#   %2 - positional reference for which mailbox to show
#   %3 - count of mailbox dbrefs in list (%1)
#   %4 - attribute name of continuation processor
#   %5 - parameter to pass along to continuation processor
#   %6 - number indicating which mailboxes_* thang is being worked on
#   %7 - u(get_format_option, %0)
#   %8 - get(%vm/mailboxes_num_of_attributes)
#

     @swi/first %3+[gt(%8, %6)] = 

     0+0,
     {
#
# No mailboxes to process.
# No more mailboxes_*'s to try, terminate display.
#

       @pemit %0 = switch(%7, standard, u(equal_line), )
     },

     0+*,
     {
#
# Call continuation processor to process the mailboxes in the next
# mailboxes_* attribute.
#

       @tr me/%4 = %0, add(1, %6), %5, %7, %8
     },

     {
#
# Show information for a single mailbox.
#

       @pemit %0 = u(get_info_for_one_mailbox, extract(%1, %2, 1)); 

       @swi/first %2+[gt(%8, %6)] = 

       %3+0, 
       {
#
# This is the last mailbox in the current list to process.
# There are no more mailboxes_*'s to try, terminate display.
#

         @pemit %0 = switch(%7, standard, u(equal_line), )
       },

       %3+*, 
       {
#
# Call continuation processor to process the mailboxes in the next
# mailboxes_* attribute.
#

         @tr me/%4 = %0, add(1, %6), %7, %8
       },

       {
#
# Move to the next mailbox in the current set of mailboxes to display.
#

         @tr me/show_one_mailbox = %0, %1, add(%2, 1), %3, %4, %5, %6, %7, %8
       }
     }

-
&GET_INFO_FOR_ONE_MAILBOX #3478 = 
-
&GET_INFO_FOR_ONE_MAILBOX #3482 = 
#
# PURPOSE:
#
#   Obtain formatted information about the specified mailbox.
#
#   (This is a helper routine for all the +mail status commands)
#
# INPUT
#
#   %0 - dbref for mailbox to show one line information about
#
# OUTPUT
#
#   One formatted line containing summary information about the 
#   mailbox indicated in %0
#
# Registers Used:
#
#   0 - dbref of whose mailbox this is 
#   1 - current value of semaphore for mailbox in question
#   2 - mail-in-progress flag
#   3 - displayable value of semaphore
#
 
    [setq(0, get(%0/owner_dbref))]
    [setq(1, get(%0/semaphore))]
    [setq(2, get(%0/mail-in-progress))]
    [setq(3, [switch(r(1), -1,, {[switch(strlen(r(1)), 0,
      %bsem 0, %bsem[r(1)])]})]
    )]

  [ljust(%0, 7)]
  [switch(words(get(%0/autoforward)), 0, %b%b, a%b)]

  [switch(
    [strlen(r(2))]+[strmatch(type(r(0)), PLAYER)], 
  0+*,
  {
    %b-- WARNING -- This does not seem to be a valid mailbox.
  },
  *+0,
  {
    %b-- INFORMATIVE -- Mailbox for dest'ed player 
      (do a +destroy mailbox for [r(0)].  Caution:%b all mail sent by 
      that player will be removed from the destination mailboxes)
  },
  {
    [ljust(name(r(0)), 17)]
    [ljust([r(2)][r(3)], 11)]
    [rjust(
      add(
        words(get(%0/author_filter), ~), 
        words(get(%0/subject_filter), ~)
      ), 
      7
    )]
    [rjust(words(get(%0/alias-list)), 9)]
    [rjust(words(get(%0/folder-list)), 9)]
    [rjust(words(get(%0/out-list)), 6)]
    [rjust(words(u(get_all_in_lists, %0)), 10)]
  }
  )]

-
###############################################################################
#
#                   M A I L   S T A T U S   S P E C I F I C         
#
###############################################################################

&MAIL_ADMIN_COMMAND_SPECIFIC #3478 = 
#
# PURPOSE:
#
#   This Wizard-only command may be used to obtain detailed information
#   about a specific mailbox.  
#
#   Information shown includes:  
#     mailbox dbref, 
#     if mail is in progress
#     how many letters have been received total 
#     how many letters are currently stored in the mailbox
#     how many personal mail aliases are defined
#     how many folder are defined
#     if autoforward is set
#     value of message timeout, if set
#     value of the semaphore on the mailbox
#     value of the 'current letter'
#
# Command Format:
#
#   +mail status for <person>
#
# Registers Used:
#
#   0 - dbref of mailbox for <person>
#

  $+mail status for *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_[num(*%0)]))]

    0 = hasflag(%#, wizard),
    {
#
# Invoked by non-Wiz
#

      @pemit %# = Permission denied.
    },

    strmatch(type(*%0), PLAYER),
    {
#
# Person specified is not currently a player.
#

      @pemit %# = [capstr(%0)] is not a player.
    },

    strlen(r(0)),
    {
#
# Person specified does not have a mailbox.
#

      @pemit %# = [name(*%0)] does not currently have a mailbox.
    },
  
    {
      @tr me/display_mail_admin = %#, r(0)
    }

-
&DISPLAY_MAIL_ADMIN #3478 = 
-
&DISPLAY_MAIL_ADMIN #3482 = 
#
# PURPOSE:
#
#   Obtain detailed information about a specific mailbox.
#
#   (This is a helper routine for the +mail status for <person> command)
#
# INPUT
#
#   %0 - dbref of invoker  
#   %1 - dbref of mailbox
#
# Registers Used:
#
#   0 - user's format option
#   1 - dbref of owner whose mailbox it is
#   2 - mail-in-progress flag
#

  @pemit %0 = 

      [setq(0, u(get_format_option, get(%0/mail_config_options)))]
      [setq(1, get(%1/owner_dbref))]
      [setq(2, get(%1/mail-in-progress))]

#
# Note - registers 4, 7, 8, 9 are in use in get_autoforward_option
#        registers 5, 6 are in use in get_timeout_option
#

    [switch(r(0), standard, 
      {[u(equal_line)]
      %rDetailed status for [name(r(1))]'s mailbox:
      %r[u(dash_line)]%r}
    )]

    [rjust(Mailbox dbref:, 20)]%b%b%1
    [switch(strlen(r(2)), 0,
    {
      %r-- WARNING --  This does not seem to be a valid mailbox.
    })]
    %r[rjust(Mail-in-progress:, 20)]%b%b[r(2)]
    %r[rjust(Received:, 20)]%b%b[words(u(get_all_in_lists, %1))]
    %r[rjust(Sent:, 20)]%b%b[words(get(%1/out-list))]
    %r[rjust(Personal aliases:, 20)]%b%b[words(get(%1/alias-list))] 
      [switch(words(get(%1/alias-list)), 0,,
      ([u(list_names, trim(get(%1/alias-list)))]))]
    %r[rjust(Filters:, 20)]%b%b[u(get_filter_count, r(1))]
    %r[rjust(Folders:, 20)]%b%b[words(get(%1/folder-list))] 
      [switch(words(get(%1/folder-list)), 0,,{
      ([u(secure_names, trim(get(%1/folder-list)))])})]
    %r[rjust(Autoforward:, 20)]%b%b[u(get_autoforward_option, r(1))]
    %r[rjust(Message Timeout:, 20)]%b%b[u(get_timeout_option, r(1))]
    %r[rjust(Semaphore:, 20)]%b%b[get(%1/semaphore)]
    %r[rjust(Current Letter:, 20)]%b%b[get(%1/[u(which_current_letter, %1)])]
    %r[rjust(Current Folder:, 20)]%b%b[secure(get(%1/current_folder))]
    %r[rjust(Inbox:, 20)]%b%b[secure(u(get_inbox, r(1)))]
    %r[rjust(Vacation:, 20)]%b%b[u(%1/vacation)]
    %r[rjust(Reject:, 20)]%b%b[u(%1/reject_msg)]

    [switch(r(0), standard, {%r[u(equal_line)]})]; 

-
###############################################################################
#
#                   C H E C K   F O R   M E M O R Y   H O G S       
#
###############################################################################
&MAIL_MEMORY_HOGS #3478 = 
#
# PURPOSE:
#
#   This Wizard-only command may be used to show all mailboxes that 
#   have greater than <number> messages stored.
#
# Command Format:
#
#   +mail status > <number>
#
# Registers Used:
#
#   0 - user's format option
#

  $+mail status >*: 

    @swi hasflag(%#, wizard) = 1,
    {
      @pemit %# = 

        [setq(0, u(get_format_option, get(%#/mail_config_options)))]

        [switch(r(0), standard, 
          {[u(equal_line)]
          %r[space(8)]Summary status of mailboxes with greater than [trim(%0)] 
          messages%r%r}
        )]

        Mailbox%b%bOwner[space(12)]Writing? %b Filters%b 
          Aliases%b Folders%b Sent%b Received

        [switch(r(0), standard, {%r[u(dash_line)]})]; 

        @tr me/continue_memory_hogs = 
            %#, 1, %0, r(0), get(%vm/mailboxes_num_of_attributes)

    }, 

    {
      @pemit %# = Permission denied.
    }

-
&CONTINUE_MEMORY_HOGS #3478 = 
-
&CONTINUE_MEMORY_HOGS #3482 = 
#
# PURPOSE:
#
#   If the current MAILBOXES_%1 is empty:
#
#     If there are no more MAILBOXES_* to try, terminate display.
#
#     Otherwise, call this function recursively to process the next list
#     of mailbox dbrefs.
#
#   Otherwise, MAILBOXES_%1 is NOT empty:
#
#     Call SHOW_ONE_MAILBOX to begin processing the list of mailbox dbrefs.
#
#   (This is a helper routine for the +mail status > <number> command)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - index of which list of mailbox dbrefs to try next
#   %2 - threshold
#   %3 - u(get_format_option, %0)
#   %4 - get(%vm/mailboxes_num_of_attributes)
#
# Registers Used:
#
#   0 - list of mailboxes for the current mailboxes_* being worked on that
#       match the test criteria (letters > <number>)
#

    @swi/first [strlen(get(%vm/mailboxes_%1))]+[gt(%4, %1)] = 

    0+0,
    {
      @pemit %0 = switch(%3, standard, u(equal_line), )
    },

    0+*, 
    {
      @tr me/continue_memory_hogs = %0, add(1, %1), %2, %3, %4
    },

    {

      @tr me/show_one_mailbox =

          [setq(0, u(evaluate_next_list, %1, memory_hog_test, %2))]

        %0, 
        r(0), 
        1, 
        words(r(0)), 
        continue_memory_hogs, 
        %2, 
        %1,  
        %3, 
        %4
    }

-
&MEMORY_HOG_TEST #3478 = 
-
&MEMORY_HOG_TEST #3482 = 
#
# PURPOSE:
#
#   Given a mailbox dbref, return a boolean indicating if the mailbox
#   has greater than <number> letters stored.
#
#   (This is a helper routine for the +mail status > <number> command)
#  
#
# INPUT
#
#   %0 - mailbox dbref 
#   %1 - <number>
#

  gt(words(u(get_all_in_lists, %0)), %1)

-
###############################################################################
#
#                   C H E C K   F O R   M A I L B O X E S   
#         with less than the admin specified number of messages
#
###############################################################################
&MAIL_STATUS_LESS_THAN #3478 = 
#
# PURPOSE:
#
#   This Wizard-only command may be used to show all mailboxes that
#   have less than than <number> messages stored.
#
# Command Format:
#
#   +mail status < <number>
#
# Registers Used:
#
#   0 - user's format option
#

  $+mail status <*: 

    @swi hasflag(%#, wizard) = 1,
    {
      @pemit %# = 

          [setq(0, u(get_format_option, get(%#/mail_config_options)))]

        [switch(r(0), standard, 
          {[u(equal_line)]
          %r[space(8)]Summary status of mailboxes with less than [trim(%0)] 
          messages%r%r}
        )]

        Mailbox%b%bOwner[space(12)]Writing? %b Filters%b 
          Aliases%b Folders%b Sent%b Received

        [switch(r(0), standard, {%r[u(dash_line)]})]; 

        @tr me/continue_less_than = 
            %#, 1, %0, r(0), get(%vm/mailboxes_num_of_attributes)

    }, 

    {
      @pemit %# = Permission denied.
    }

-
&CONTINUE_LESS_THAN #3478 = 
-
&CONTINUE_LESS_THAN #3482 = 
#
# PURPOSE:
#
#   If the current MAILBOXES_%1 is empty:
#
#     If there are no more MAILBOXES_* to try, terminate display.
#
#     Otherwise, call this function recursively to process the next list
#     of mailbox dbrefs.
#
#   Otherwise, MAILBOXES_%1 is NOT empty:
#
#     Call SHOW_ONE_MAILBOX to begin processing the list of mailbox dbrefs.
#
#   (This is a helper routine for the +mail status < <number> command)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - index of which list of mailbox dbrefs to try next
#   %2 - threshold
#   %3 - u(get_format_option, %0)
#   %4 - get(%vm/mailboxes_num_of_attributes)
#
# Registers Used:
#
#   0 - list of mailboxes for the current mailboxes_* being worked on that
#       match the test criteria (letters > <number>)
#

    @swi/first [strlen(get(%vm/mailboxes_%1))]+[gt(%4, %1)] = 

    0+0, 
    {
      @pemit %0 = switch(%3, standard, u(equal_line), )
    },

    0+*, 
    {
      @tr me/continue_less_than = %0, add(1, %1), %2, %3, %4
    },

    {
      @tr me/show_one_mailbox =

          [setq(0, u(evaluate_next_list, %1, letters_less_than_test, %2))]

        %0,
        r(0), 
        1,
        words(r(0)),
        continue_less_than,
        %2, 
        %1, 
        %3, 
        %4
    }

-
&LETTERS_LESS_THAN_TEST #3478 = 
-
&LETTERS_LESS_THAN_TEST #3482 = 
#
# PURPOSE:
#
#   Given a mailbox dbref, return a boolean indicating if the mailbox
#   has less than <number> letters stored.
#
#   (This is a helper routine for the +mail status < <number> command)
#
# INPUT
#
#   %0 - mailbox dbref
#   %1 - <number>
#

  lt(words(u(get_all_in_lists, %0)), %1)

-
###############################################################################
#
#                   C H E C K   F O R   M A I L B O X E S   
#                           with bad semaphores
#
###############################################################################
&MAIL_STATUS_BAD_SEM #3478 =
#
# PURPOSE:
#
#   This Wizard-only command may be used to show all mailboxes that
#   have semaphore that are not -1.
#
# Command Format:
#
#   +mail status bad sem[aphore]
#
# Registers Used:
#
#   0 - user's format option
#

  $+mail status bad sem*:

    @swi hasflag(%#, wizard) = 1,
    {
      @pemit %# =

          [setq(0, u(get_format_option, get(%#/mail_config_options)))]

        [switch(r(0), standard, 
          {[u(equal_line)]
          %r[space(8)]Summary status of mailboxes with semaphores that 
          are off%r%r}
        )]

        Mailbox%b%bOwner[space(12)]Writing? %b Filters%b 
          Aliases%b Folders%b Sent%b Received

        [switch(r(0), standard, {%r[u(dash_line)]})];

        @tr me/continue_semaphore_off = 
          %#, 1, r(0), get(%vm/mailboxes_num_of_attributes)

    }, 

    {
      @pemit %# = Permission denied.
    }

-
&CONTINUE_SEMAPHORE_OFF #3478 =
-
&CONTINUE_SEMAPHORE_OFF #3482 =
#
# PURPOSE:
#
#   If the current MAILBOXES_%1 is empty:
#
#     If there are no more MAILBOXES_* to try, terminate display.
#
#     Otherwise, call this function recursively to process the next list
#     of mailbox dbrefs.
#
#   Otherwise, MAILBOXES_%1 is NOT empty:
#
#     Call SHOW_ONE_MAILBOX to begin processing the list of mailbox dbrefs.
#
#   (This is a helper routine for the +mail status bad sem command)
#
# INPUT
#
#   %0 - dbref of invoker
#   %1 - index of which list of mailbox dbrefs to try next
#   %2 - u(get_format_option, %0)
#   %3 - get(%vm/mailboxes_num_of_attributes)
#
# Registers Used:
#
#   0 - list of mailboxes for the current mailboxes_* being worked on that
#       match the test criteria (bad semaphore)
#

    @swi/first [strlen(get(%vm/mailboxes_%1))]+[gt(%3, %1)] = 

    0+0, 
    {
      @pemit %0 = switch(%2, standard, u(equal_line), )
    },

    0+*, 
    {
      @tr me/continue_semaphore_off = %0, add(1, %1), %2, %3
    },

    {

      @tr me/show_one_mailbox =

          [setq(0, u(evaluate_next_list, %1, semaphore_off_test))]

        %0, 
        r(0), 
        1, 
        words(r(0)), 
        continue_semaphore_off, 
        0, 
        %1,
        %2,
        %3
    }

-
&SEMAPHORE_OFF_TEST #3478 = 
-
&SEMAPHORE_OFF_TEST #3482 = 
#
# PURPOSE:
#
#   Given a mailbox dbref, return a boolean indicating if the mailbox
#   has a bad semaphore (not -1).
#
#   (This is a helper routine for the +mail status bad semaphore command)
#
# INPUT
#
#   %0 - mailbox dbref
#

  switch(get(%0/semaphore), -1, 0, 1)

-
&SANITY_CHECK #3478 = 
#
# This is mainly for my use, to help in shakedown of this release.
#

  $+sanity check: 

    @swi hasflag(%#, wizard) = 1,
    {
      @tr me/continue_sanity_check =
        %#, 1, get(%vm/mailboxes_num_of_attributes)
    },

    {
      @pemit %# = Permission denied.
    }

-
&CONTINUE_SANITY_CHECK #3482 = 
#
#   %0 - dbref of invoker
#   %1 - index of which list of mailbox dbrefs to try next
#   %2 - get(%vm/mailboxes_num_of_attributes)
#

    @swi/first [strlen(get(%vm/mailboxes_%1))]+[gt(%2, %1)] =

    0+0,
    {
      @pemit %0 = Sanity check complete.
    },

    0+*,
    {
      @tr me/continue_sanity_check = %0, add(1, %1), %2
    },

    {
      @tr #3480/sanity_check_one_mailbox =
        first(get(%vm/mailboxes_%1)), 
        %0, 
        %1,
        %2, 
        get(%vm/mailboxes_%1), 
        words(get(%vm/mailboxes_%1)), 
        1
    }

-
&SANITY_CHECK_ONE_MAILBOX #3480 = 

#
# %0 - mailbox dbref
# %1 - invoker dbref
# %2 - which mailboxes_* is being currently worked on
# %3 - get(%vm/mailboxes_num_of_attributes)
# %4 - mailboxes_*
# %5 - words(mailboxes_*)
# %6 - which mailbox in mailboxes_* is currently being worked on
#

   @pemit %1 = Checking [name(get(%0/owner_dbref))]'s mailbox.; 

   @dolist u(v(mail_system)/get_all_in_lists, %0) = 
   {
     @swi/first 
 
       [setq(0, get(%0/in-##-location))]

     1 = 

     and(
       eq(member(get(first(r(0))/out-list), rest(r(0))), 0),
       not(strmatch(rest(r(0)), a*))
     ), 
     {
       @pemit %1 = Error detected in mailbox %0.%b 
         Internal mail number ## is not present in source mailbox.
     }, 

     and(
       eq(member(get(first(r(0))/out-[rest(r(0))]-held), 
         get(%0/owner_dbref)), 0), 
       not(strmatch(rest(r(0)), a*))
     ), 
     {
       @pemit %1 = Error detected in mailbox %0.%b 
         Internal mail number ## is not in the 'held' list in source mailbox.
     }, 

     and(
       or(
         eq(words(get(%0/in-##-time_read)), 0), 
         eq(words(get(%0/in-##-location)), 0)
       ), 
       strmatch(rest(r(0)), a*)
     ), 
     {
       @pemit %1 = Error detected in mailbox %0.%b 
         Internal mail number ## for 'old' mail does not have matching in-* 
         attributes.
     }, 

     and(
       eq(words(get(%0/out-a##-time_sent)), 0), 
       strmatch(rest(r(0)), a*)
     ), 
     {
       @pemit %1 = Error detected in mailbox %0.%b 
         Internal mail number ## for 'old' mail does not have matching out-a* 
         attributes.
     }
   }; 

   @dolist get(%0/out-list) = 
   {
     @trigger me/sanity_check_outgoing_mail = %0, %1, ##
   };

   @swi 1 = 1, {@swi 1 = 1, {@swi 1 = 1, 
   {
     @swi %6 = %5,
     {
       @tr #3478/continue_sanity_check = %1, add(1, %2), %3
     },
     {
       @tr #3480/sanity_check_one_mailbox =
          extract(%4, add(1, %6), 1), 
          %1, 
          %2, 
          %3, 
          %4, 
          %5, 
          add(1, %6)
     }
   }}}

-
&SANITY_CHECK_OUTGOING_MAIL #3480 = 

#
# %0 - mailbox dbref
# %1 - invoker dbref
# %2 - internal number of outgoing mail
#

  @dolist 

      [setq(0, get(%0/out-%2-dist))]

  get(%0/out-%2-held) = 
  {
    @swi/first 

      [setq(1, match(r(0), ##:*))]
      [setq(2, extract(r(0), r(1), 1))]
      [setq(3, v(mailbox_[before(r(2), :)]))]
      [setq(4, after(r(2), :))]
      [setq(5, get(r(3)/in-[r(4)]-location))]
      [setq(6, u(v(mail_system)/get_all_in_lists, r(3)))]
      [setq(7, name(get(r(3)/owner_dbref)))]

    0 = r(1),
    {
       @pemit %1 = Error detected in mailbox %0.%b 
         Outgoing mail number %2 has a 'held' member (##) which isn't in 
         the 'dist' list.
    },

    words(r(5)),
    {
       @pemit %1 = Error detected in mailbox %0.%b 
         Outgoing mail number %2 does not exist in destination mailbox 
         [r(3)] \([r(7)]\).
    },

    strmatch(first(r(5)), %0),
    {
       @pemit %1 = Error detected in mailbox %0.%b 
         Outgoing mail number %2 'dist' does not match in-[r(4)]-location 
         in mailbox [r(3)] \([r(7)]\).
    }, 

    strmatch(rest(r(5)), %2), 
    {
       @pemit %1 = Error detected in mailbox %0.%b 
         Outgoing mail number %2 'dist' does not match in-[r(4)]-location 
         in mailbox [r(3)] \([r(7)]\).
    }, 

    member(r(6), r(4)), 
    {
       @pemit %1 = Error detected in mailbox %0.%b 
         Outgoing mail number %2 exists in destination mailbox 
         [r(3)] \([r(7)]\), but is not in any of its IN lists.
    }
  }

-
###############################################################################
#
#                        M A K E   M A I L B O X                               
#
###############################################################################
&WIZ_MAKE_MAILBOX #3478 = 
#
# PURPOSE:
#
#   This Wizard-only command may be used to make a mailbox for the
#   specified player (if one does not exist already).
#
# Command Format:
#
#   +make mailbox for <person>
#
# Note:
#
#   Mailboxes are automatically created when needed, therefore, this
#   command should not be needed.
#

  $+make mailbox for *: 

    @swi hasflag(%#, wizard) = 1,
    {
      @tr %vm/make_mailbox = %0, %#
    }, 
 
    {
      @pemit %# = Permission denied.
    }

-
###############################################################################
#
#                        D E S T R O Y   M A I L B O X                     
#
###############################################################################
&WIZ_DESTROY_MAILBOX #3478=
#
# PURPOSE:
#
#   This Wizard-only command may be used to destroy a mailbox for the
#   specified player.
#
# Command Format:
#
#   +destroy mailbox for <person>   
#            - or - 
#   +destroy mailbox for <player dbref>
#

  $+destroy mailbox for *: 

    @swi hasflag(%#, wizard) = 1,
    {
      @tr %vm/destroy_mailbox = %0, %#, 0
    }, 

    {
      @pemit %# = Permission denied.
    }

-
###############################################################################
#
#                   + M A I L   C O N F I G U R A T I O N             
#
###############################################################################
&MAIL_CONFIGURATION #3478=
#
# PURPOSE:
#
#   This Wizard-only command may be used to see how the mail system
#   is configured on the system.
#
#   Information shown:
#
#     destroy when empty (true or false)
#     default delete option (hard or soft)
#     default mode option (terse or verbose)
#     default format option (standard or compact)
#     default timeout option (0-disabled, or number of days)
#     the configured text for:  delivery, pickup, forward and text_added
#       notifications
#     current number of mailboxes
#     number of global mail aliases defined
#     the number of attributes used to hold the list of mailboxes
#
# Command Format:
#
#   +mail configuration
#
# Registers Used:
#
#   0 - user's format option
#   1 - default timeout option
#

  $+mail config*: 

    @swi hasflag(%#, wizard) = 1,
    {
      &mail_config_options me=this is a test; 

      @pemit %# = 

          [setq(0, u(get_format_option, get(%#/mail_config_options)))]
          [setq(1, get(%vm/default_timeout_option))]

        [switch(r(0), standard, 
          {[u(equal_line)]
          %rCurrent mail configuration:
          %r[u(dash_line)]%r}
        )]

        Defaults:%r%r
        %b%bdestroy:%b%b[ljust(switch(get(%vm/delete_when_empty), 
          0, no, yes), 16)]
        [rjust(\(+set mail option destroy = yes or no\), 50)]

        %r%b%b%bdelete:%b%b[ljust(get(%vm/default_delete_option), 16)]
        [rjust(\(+set mail default delete = hard or soft\), 50)]

        %r%b%b%b%b%bmode:%b%b[ljust(get(%vm/default_mode_option), 16)]
        [rjust(\(+set mail default mode = terse or verbose\), 50)]

        %r%b%b%bformat:%b%b[ljust(get(%vm/default_format_option), 16)]
        [rjust(\(+set mail default format = standard or compact\), 50)]

        %r%b%b%b%b%bsave:%b%b[ljust(get(%vm/default_save_option), 16)]
        [rjust(\(+set mail default save = enabled or disabled\), 50)]

        %rseparator:%b%b[ljust(get(%vm/default_separator_option), 16)]
        [rjust(\(+set mail default separator = space or return\), 50)]

        %r%b%btimeout:%b%b[ljust(
          switch(r(1), 0, <disabled>,
          {[div(r(1), v(seconds_in_day))] days})
        , 16)]
        [rjust(\(+set mail default timeout = <number of days>\), 50)]

        %r%b%b%b%bpurge:%b%b[ljust(get(%vm/default_purge_time), 16)]
        [rjust(\(+set mail default purge = <day> <hour>:<minute>\), 50)]

        %r%rNotifications:  \(set on Parent Mail Object/#3482\)
 
        %r%r%b%bDELIVERY_NOTIFICATION:
          %b%b[get(#3482/delivery_notification)]

        %r%r%b%bPICKUP_NOTIFICATION:
          %b%b[get(#3482/pickup_notification)]

        %r%r%b%bFORWARD_NOTIFICATION:
          %b%b[get(#3482/forward_notification)]

        %r%r%b%bTEXT_ADDED_NOTIFICATION:
          %b%b[get(#3482/text_added_notification)]

        %r%rCurrent Status:
        %r%r%b%bThere are [words(get(%vm/global-mail-aliases))] 
        global mail aliases.

        %r%b%bThere are 
        [words(
          iter(
            lnum(get(%vm/mailboxes_num_of_attributes)),
            get(%vm/mailboxes_[add(1, ##)])
          )
        )] mailboxes.

        %r%b%b[switch(get(#3480/mailboxes_num_of_attributes), 1, 
          One attribute is, [get(#3480/mailboxes_num_of_attributes)] are)] 
          used to hold the list of mailboxes. 

        [switch(
          words(v(mail_config_options)), 0,,%r%rWARNING:%b%b
          have [name(#1)]\(#1\) do a 
          @attribute/access mail_config_options=wizard
        )]
        [switch(
          flags(#3478), *I*, %r%rWARNING:%b%b
          The [name(#3478)] object \(#3478\) should not be inherit.
        )]
        [switch(
          [flags(#3479)]+[flags(owner(#3479))], 
          *I*+*W*,, *W*+*W*,, %r%rWARNING:%b%b
          The [name(#3479)] object \(#3479\) 
          should be inherit and owned by a Wizard.
        )]
        [switch(
          parent(me), #3482,, %r%rWARNING:%b%b
          The [name(me)] object \([num(me)]\) should be parented to 
            the [name(#3482)] \(#3482\). 
        )]

        [switch(r(0), standard, {%r[u(equal_line)]})]; 

      &mail_config_options me =
    }

-
###############################################################################
#
#          W i z a r d   C o n f i g u r a t i o n   C o m m a n d s
#
###############################################################################

###############################################################################
#
#           + S E T   M A I L   O P T I O N   D E S T R O Y   
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_OPTION_DESTROY #3478=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system option
#   for if mailboxes are automatically deleted when empty.
#
# Command Format:
#
#   +set mail option destroy=yes | on | true | t | 1 | no | off | false | f | 0
#

  $+set mail option destroy*=*: 

    @swi hasflag(%#, wizard) = 1,
    {

      @swi/first 1 = 

        or(
          strmatch(%1, *yes), 
          strmatch(%1, *on), 
          strmatch(%1, *true), 
          strmatch(%1, *t), 
          strmatch(%1, *1), 
        ),
        {
          &delete_when_empty %vm = 1; 
          @pemit %# = Mailboxes will 
             be automatically destroyed when they are empty.
        },

        or(
          strmatch(%1, *no), 
          strmatch(%1, *off), 
          strmatch(%1, *false), 
          strmatch(%1, *f), 
          strmatch(%1, *0), 
        ),
        {
          &delete_when_empty %vm = 0; 
          @pemit %# = Mailboxes will 
            not be automatically destroyed when they are empty.
        }, 

        {
          @pemit %# = The value for this option must be specified as a 
            boolean. For example: %bon, off, yes, no, true, false are all 
            acceptable values.
        } 
    }, 

    {
      @pemit %# = Permission denied.
    }

-
&SET_MAIL_OPTION_BLANK #3478=

  $+set mail option: 

    @swi hasflag(%#, wizard) = 1,
    {
      @pemit %# = You must specify which option you wish to set and the 
      desired value. The current options are:

      %r%r%b%bdelete=hard | soft
      %r%r%b%bdestroy=on | off
      %r%r%b%bmode=verbose | terse
      %r%r%b%bformat=compact | standard
      %r%r%b%bseparator=space | return
      %r%r%b%binbox=<folder name>
      %r%r%b%bvacation=<text>
      %r%r%b%breject=<text>
      %r%r%b%bautoforward=<list of people and/or mail aliases>
      %r%r%b%btimeout=<number of days> for <player>
    },
    {
      @pemit %# = You must specify which option you wish to set and the 
      desired value. The current options are:

      %r%r%b%bdelete=hard | soft
      %r%r%b%bmode=verbose | terse
      %r%r%b%bformat=compact | standard
      %r%r%b%bseparator=space | return
      %r%r%b%binbox=<folder name>
      %r%r%b%bvacation=<text>
      %r%r%b%breject=<text>
      %r%r%b%bautoforward=<list of people and/or mail aliases>
    }

-
###############################################################################
#
#           + S E T   M A I L   O P T I O N   T I M E O U T         
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_OPTION_TIMEOUT #3479=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the timeout option for
#   a specific player.  This value will override the mail system
#   default timeout value.
#
# Command Format:
#
#   +set mail option timeout = <days> for <person>
#
# Registers Used:
#
#   0 - dbref of <person>'s mailbox
#

  $+set mail option timeout*=* for *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_[num(*%2)]))]

    0 = hasflag(%#, wizard), 
    {
#
# Non-wiz invoked
#

      @pemit %# = Permission denied.
    },

    strmatch(type(*%2), PLAYER),
    {
#
# Name specified is not that for a valid Player.
#

      @pemit %# = [capstr(%2)] is not a player.
    },

    strlen(r(0)),
    {
#
# Player does not have a mailbox.
#

      @pemit %# = [name(*%2)] does not currently have a mailbox.
    },

    %1,
    {
#
# Timeout value of '0' specified.  This means that letters will not
# expire for this player.
#

      &message_timeout [r(0)] = 0; 

      @pemit %# = The message timeout has been set to 0 days 
        (indicating that the timeout option has been turned 
        off for [name(*%2)]).
    },

    lt(%1, 7),
    {
#
# Timeout greater than or equal to 7 days specified, store 
# value in mailbox.
#

      &message_timeout [r(0)] = mul(%1, v(seconds_in_day));

      @pemit %# = The message timeout value for [name(*%2)] has been set to 
          [add(%1, 0)] days.
    },

    {
#
# Timeout value of less than 7 specified. Value must be greater than or
# equal to 7 days.
#

      @pemit %# = The value specified for the message timeout 
        must be either a '0' (indicating the timeout option 
        has been turned off) or a value greater than or equal to 7 days.
    }

-
###############################################################################
#
#           + S E T   M A I L   D E F A U L T  D E L E T E     
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_DEFAULT_DELETE #3479=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system default
#   for the delete option.
#
# Command Format:
#
#   +set mail default delete = hard | soft
#

  $+set mail default delete*=*: 

    @swi/first 1 = 

    eq(hasflag(%#, wizard), 0),
    {
#
# Non-Wiz invoked
#

      @pemit %# = Permission denied.
    },

    strmatch(%1, *s*),
    {
#
# Soft specified
#
      @pemit %# = switch(get(%vm/default_delete_option), 
          hard, The mail system default for 'delete' is now 'soft'., 
          The mail system default for 'delete' is already 'soft'.); 
      &default_delete_option %vm = soft; 
    },

    strmatch(%1, *h*),
    {
#
# Hard specified
#
      @pemit %# = switch(get(%vm/default_delete_option), 
          soft, The mail system default for 'delete' is now 'hard'., 
          The mail system default for 'delete' is already 'hard'.); 
      &default_delete_option %vm = hard; 
    },

    {
#
# Invalid value for delete default specified
#

      @pemit %# = The value specified for the mail system default for 'delete', 
        must be either 'soft' or 'hard'.
    }

-
###############################################################################
#
#           + S E T   M A I L   D E F A U L T   M O D E        
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_DEFAULT_MODE #3479=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system default
#   for the mode option.
#
# Command Format:
#
#   +set mail default mode = terse | verbose
#

  $+set mail default mode*=*: 

    @swi/first 1 = 

    eq(hasflag(%#, wizard), 0),
    {
#
# Non-Wiz invoked
#

      @pemit %# = Permission denied.
    },

    strmatch(%1, *t*),
    {
#
# Terse specified
#

      @pemit %# = switch(get(%vm/default_mode_option), 
        verbose, The mail system default for 'mode' is now 'terse'., 
        The mail system default for 'mode' is already 'terse'.); 
      &default_mode_option %vm = terse
    },

    strmatch(%1, *v*),
    {
#
# Verbose specified
#

      @pemit %# = switch(get(%vm/default_mode_option), 
        terse, The mail system default for 'mode' is now 'verbose'., 
        The mail system default for 'mode' is already 'verbose'.); 
      &default_mode_option %vm = verbose
    },

    {
#
# Invalid value for mode specified
#

      @pemit %# = The value specified for the mail system default for 'mode', 
        must be either 'terse' or 'verbose'.
    }

-
###############################################################################
#
#           + S E T   M A I L   D E F A U L T  F O R M A T     
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_DEFAULT_FORMAT #3479=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system default
#   for the format option.
#
# Command Format:
#
#   +set mail default format = standard | compact
#

  $+set mail default format*=*: 

    @swi/first 1 = 

    eq(hasflag(%#, wizard), 0),
    {
#
# Non-Wiz invoked
#

      @pemit %# = Permission denied.
    },

    strmatch(%1, *s*),
    {
#
# 'standard' specified
#

      @pemit %# = switch(get(%vm/default_format_option), 
        compact, The mail system default for 'format' is now 'standard'., 
        The mail system default for 'format' is already 'standard'.); 
      &default_format_option %vm = standard
    },

    strmatch(%1, *c*),
    {
#
# 'compact' specified
#

      @pemit %# = switch(get(%vm/default_format_option), 
        standard, The mail system default for 'format' is now 'compact'., 
        The mail system default for 'format' is already 'compact'.); 
      &default_format_option %vm = compact
    },

    {
#
# Invalid value for 'format' default specified
#

      @pemit %# = The value specified for the mail system default for 'format', 
        must be either 'standard' or 'compact'.
    }

-
###############################################################################
#
#           + S E T   M A I L   D E F A U L T   S A V E         
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_DEFAULT_SAVE #3479=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system default
#   for the save option (enable or disable the +save command).
#
# Command Format:
#
#   +set mail default save = enabled | disabled
#

  $+set mail default save*=*: 

    @swi/first 

      [setq(0, trim(%1))]

    1 = eq(hasflag(%#, wizard), 0),
    {
#
# Non-Wiz invoked
#

      @pemit %# = Permission denied.
    },

    strmatch(r(0), e*),
    {
#
# 'enabled' specified
#

      @pemit %# = switch(get(%vm/default_save_option), 
        disabled, The mail system default for 'save' is now 'enabled'., 
        The mail system default for 'save' is already 'enabled'.); 
      &default_save_option %vm = enabled
    },

    strmatch(r(0), d*),
    {
#
# 'disabled' specified
#

      @pemit %# = switch(get(%vm/default_save_option), 
        enabled, The mail system default for 'save' is now 'disabled'., 
        The mail system default for 'save' is already 'disabled'.); 
      &default_save_option %vm = disabled
    },

    {
#
# Invalid value for 'save' default specified
#

      @pemit %# = The value specified for the mail system default for 'save', 
        must be either 'enabled' or 'disabled'.
    }

-
###############################################################################
#
#           + S E T   M A I L   D E F A U L T   S E P A R A T O R
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_DEFAULT_SEPARATOR #3479=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system default
#   for the separator option (used when appending text during '-<text>' 
#   commands.
#
# Command Format:
#
#   +set mail default separator = space | return
#

  $+set mail default separator*=*: 

    @swi/first 

      [setq(0, trim(%1))]

    1 = eq(hasflag(%#, wizard), 0),
    {
#
# Non-Wiz invoked
#

      @pemit %# = Permission denied.
    },

    strmatch(r(0), s*),
    {
#
# 'space' specified
#

      @pemit %# = switch(get(%vm/default_separator_option), 
        return, The mail system default for 'separator' is now 'space'., 
        The mail system default for 'separator' is already 'space'.); 
      &default_separator_option %vm = space
    },

    strmatch(r(0), r*),
    {
#
# 'return' specified
#

      @pemit %# = switch(get(%vm/default_separator_option), 
        space, The mail system default for 'separator' is now 'return'., 
        The mail system default for 'separator' is already 'return'.); 
      &default_separator_option %vm = return
    },

    {
#
# Invalid value for 'separator' default specified
#

      @pemit %# = The value specified for the mail system default 
        for 'separator', must be either 'space' or 'return'.
    }

-
###############################################################################
#
#           + S E T   M A I L   D E F A U L T   T I M E O U T
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_DEFAULT_TIMEOUT #3479=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system default
#   for the timeout option.
#
# Command Format:
#
#   +set mail default timeout = days
#
#
# If zero is specified, then no the timeout code is disabled. 
# Otherwise, must be 7 or greater.  'timeout' is specified in 
# number of days and stored in number of seconds.
#

  $+set mail default timeout*=*:

    @swi/first 0 = 

    hasflag(%#, wizard), 
    {
#
# Non-wiz invoked
#

      @pemit %# = Permission denied.
    },

    %1,
    {
#
# Timeout value of '0' specified.  This means that letters will not
# expire.
#

      &default_timeout_option %vm = 0;

      @pemit %# = The mail system default for 'timeout' has been set to 0 
        days (indicating that the timeout option has been turned off).
    },

    lt(%1, 7), 
    {
#
# Timeout greater than or equal to 7 days specified, store mail system-wide
# default value.
#

      &default_timeout_option %vm = mul(%1, v(seconds_in_day));

      @pemit %# = 
        The mail system default for 'timeout' is now [add(%1, 0)] days 
        and will run on [get(%vm/default_purge_time)].
    },

    {
#
# Timeout value of less than 7 specified. Value must be greater than or
# equal to 7 days.
#

      @pemit %# = The value specified for the mail system default for 
        'timeout', must be either a '0' (indicating the timeout option 
        has been turned off) or a value greater than or equal to 7 days.
    }

-
###############################################################################
#
#           + S E T   M A I L   D E F A U L T   P U R G E      
#                         (wiz-only command)
#
###############################################################################
&SET_MAIL_DEFAULT_PURGE #3479=
#
# PURPOSE:
#
#   This Wizard-only command may be used to set the mail system default
#   for when the mail/mailbox purge code should run.
#
# Command Format:
#
#   +set mail default purge = <day of week> <hour>:<minute>
#
#   Example:  +set mail default purge = Wednesday 04:15
#
# Registers used:
#
#   0 - hour
#   1 - minute
#

  $+set mail default purge*=* *:

    @swi/first 0 = 

    hasflag(%#, wizard), 
    {
#
# Non-wiz invoked
#

      @pemit %# = Permission denied.
    },

    match(Monday Tuesday Wednesday Thursday Friday Saturday Sunday 
      Mon Tue Tues Wed Thu Thur Thurs Fri Sat Sun, %1),
    {
      @pemit %# = Please specify day of week.  (example:%b Monday)
    },

    strmatch(%2, *:*),
    {
      @pemit %# = Please specify the time in the format of <hour>:<minute>.
    },

    not(strmatch(%2, *:*:*)),
    {
      @pemit %# = Please specify the time in the format of <hour>:<minute>.
    },

      [setq(0, before(%2, :))]

    not(or(lt(r(0), 0), gt(r(0), 24))), 
    {
      @pemit %# = Hour must be between 0 and 24.
    },

      [setq(1, after(%2, :))]

    not(or(lt(r(1), 0), gt(r(1), 59))), 
    {
      @pemit %# = Minute must be between 0 and 59.
    },

    {
      &default_purge_time %vm =    
        %1 
        [mid(00, 0, sub(2, strlen(r(0))))][r(0)]:
        [mid(00, 0, sub(2, strlen(r(1))))][r(1)]; 

      @pemit %# = 
        The mail system letter and mailbox purge code 
          will run on [get(%vm/default_purge_time)].
    }

-
###############################################################################
#
#            U s e r   C o n f i g u r a t i o n   C o m m a n d s
#
###############################################################################

###############################################################################
#
#           + S E T   M A I L   O P T I O N   D E L E T E     
#
###############################################################################
&SET_MAIL_OPTION_DELETE #3479=
#
# PURPOSE:
#
#   This command may be used to set your delete option.  This value
#   will override the mail system default value.  
#
# Command Format:
#
#   +set mail option delete = hard | soft 
#
# Registers Used:
#
#   0 - user's MAIL_CONFIG_OPTIONS attribute
#

  $+set mail option delete*=*: 

    @swi/first 

      [setq(0, get(%#/mail_config_options))]

    trim(%1) = 

    s*,
    {
      @pemit %# = switch(member(r(0), soft), 
        0, Your 'delete' mail option is now set to 'soft'., 
        Your 'delete' mail option is already set to 'soft'.); 
      &mail_config_options %# = setunion(s(remove(r(0), hard) soft), )
    },

    h*,
    {
      @pemit %# = switch(member(r(0), hard), 
        0, Your 'delete' mail option is now set to 'hard'., 
        Your 'delete' mail option is already set to 'hard'.); 
      &mail_config_options %# = setunion(s(remove(r(0), soft) hard), )
    },

    {
      @pemit %# = The value specified for the mail option 'delete', 
        must be either 'soft' or 'hard'.
    }

-
###############################################################################
#
#               + S E T   M A I L   O P T I O N   M O D E         
#
###############################################################################
&SET_MAIL_OPTION_MODE #3479=
#
# PURPOSE:
#
#   This command may be used to set your mode option.  This value
#   will override the mail system default value.
#
# Command Format:
#
#   +set mail option mode = verbose | terse
#
# Registers Used:
#
#   0 - user's MAIL_CONFIG_OPTIONS attribute
#

  $+set mail option mode*=*: 

    @swi/first 

      [setq(0, get(%#/mail_config_options))]

    trim(%1) = 

    v*,
    {
      @pemit %# = switch(member(r(0), verbose), 
        0, Your 'mode' mail option is now set to 'verbose'., 
        Your 'mode' mail option is already set to 'verbose'.); 
      &mail_config_options %# = setunion(s(remove(r(0), terse) verbose), )
    },

    t*,
    {
      @pemit %# = switch(member(r(0), terse), 
        0, Your 'mode' mail option is now set to 'terse'., 
        Your 'mode' mail option is already set to 'terse'.); 
      &mail_config_options %# = setunion(s(remove(r(0), verbose) terse), )
    },

    {
      @pemit %# = The value specified for the mail option 'mode', 
        must be either 'verbose' or 'terse'.
    }

-
###############################################################################
#
#           + S E T   M A I L   O P T I O N   A U T O F O R W A R D
#
###############################################################################
&SET_MAIL_OPTION_AUTOFORWARD #3479 = 
#
# PURPOSE:
#
#   This command may be used to set an automatic autoforward for mail
#   destined for your mailbox.
#
# Command Format:
#
#   +set mail option autoforward = <list of player names and/or mail aliases>
#
# Registers Used:
#
#   0 - dbref of mailbox
#   1 - dbref of who to autoforward to
#   2 - global mail aliases
#   3 - personal mail aliases
#

  $+set mail option autoforward*=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(2, get(%vm/global-mail-aliases))]
      [setq(3, get(r(0)/alias-list))]

    1 = 

    and(eq(strlen(r(0)), 0), eq(strlen(%1), 0)), 
    {
#
# User does not have a mailbox and did not specify an autoforward value.
#

      @pemit %# = Mail will not be autoforwarded.
    },

    eq(strlen(%1), 0), 
    {
#
# User did not specify an autoforward value and has a mailbox.  Clear
# the autoforward for that mailbox.
#

      &autoforward [r(0)] ; 

      @pemit %# = Mail will not be autoforwarded.
    },

    eq(strlen(r(0)), 0), 
    {
#
# User has no mailbox and specified a player that mail should be 
# autoforwarded to.  Create a mailbox.
#

      @swi 
    
        [setq(1,
          [u(v(mail_system)/identify_to_list, {%1}, %vm)] 
          [u(v(mail_system)/get_aliases, {%1}, #0, r(2), )]
        )]

      r(1) = *ABORT*, 
      {
#
# Error detected in input parameter.
#
        @pemit %# = secure(after(before(r(1), ENDABORT), ABORT));
        @no r(0)
      },

      {
        @create %N's Mailbox; 
        @set [setq(0, con(me))]r(0) = quiet; 
        @drain [r(0)]; 
        @chown [r(0)] = owner(%vm); 
        @set [r(0)] = !halt; 
        @tel r(0) = %vm; 
        &mailbox_%# %vm = r(0); 
        @trigger %vm/add_mailbox = r(0); 
        &owner_dbref [r(0)] = %#; 
        @startup [r(0)] = {@drain me; @no me}; 
        @set r(0) = safe; 
        &mail-in-progress [r(0)] = false; 
        &current_folder [r(0)] = u(v(mail_system)/get_inbox, %#); 
        &folder-list [r(0)] = get(r(0)/current_folder); 
        &autoforward [r(0)] = r(1); 

        @pemit %# = All mail destined for this mailbox will now 
          be autoforwarded to [u(v(mail_system)/pretty_dist, 
          u(v(mail_system)/get_aliases, r(1), 
          r(0), r(2), ), r(0), , r(2), 
          u(v(mail_system)/snag_dbrefs, r(1)))].; 

        @no r(0)
      }
    },

    {
#
# User has a mailbox and specified a value that mail should be 
# autoforwarded to.  Save value in mailbox.
#
      @swi 

        [setq(1,
#
# Convert list of names specified by the user into dbrefs
#
          [u(v(mail_system)/identify_to_list, {%1}, r(0))] 
          [u(v(mail_system)/get_aliases, {%1}, r(0), r(2), r(3))]
        )]

      r(1) = *ABORT*, 
      {
#
# Error detected in input parameter.
#
        @pemit %# = secure(after(before(r(1), ENDABORT), ABORT));
        @no r(0)
      },

      {
        &autoforward [r(0)] = r(1); 

        @pemit %# = All mail destined for this mailbox will now 
          be autoforwarded to [u(v(mail_system)/pretty_dist, 
          u(v(mail_system)/get_aliases, r(1), 
          r(0), r(2), r(3)), r(0), r(3), r(2), 
          u(v(mail_system)/snag_dbrefs, r(1)))].
      }
    }

-
###############################################################################
#
#           + S E T   M A I L   O P T I O N   F O R M A T     
#
###############################################################################
&SET_MAIL_OPTION_FORMAT #3479=
#
# PURPOSE:
#
#   This command may be used to set your format option.  This value
#   will override the mail system default value.
#
# Command Format:
#
#   +set mail option format = standard | compact
#
# Registers Used:
#
#   0 - user's MAIL_CONFIG_OPTIONS attribute
#

  $+set mail option format*=*: 

    @swi/first 

      [setq(0, get(%#/mail_config_options))]

    trim(%1) = 

    s*,
    {
      @pemit %# = switch(member(r(0), standard), 
        0, Your 'format' mail option is now set to 'standard'., 
        Your 'standard' mail option is already set to 'standard'.); 
      &mail_config_options %# = 
        setunion(s(remove(r(0), compact) standard), )
    },

    c*,
    {
      @pemit %# = switch(member(r(0), compact), 
        0, Your 'format' mail option is now set to 'compact'., 
        Your 'standard' mail option is already set to 'compact'.); 
      &mail_config_options %# = 
        setunion(s(remove(r(0), standard) compact), )
    },

    {
      @pemit %# = The value specified for the mail option 'format', 
        must be either 'standard' or 'compact'.
    }

-
###############################################################################
#
#           + S E T   M A I L   O P T I O N   S E P A R A T O R
#
###############################################################################
&SET_MAIL_OPTION_SEPARATOR #3479=
#
# PURPOSE:
#
#   This command may be used to set your separator option.  This value
#   will override the mail system default value.
#
# Command Format:
#
#   +set mail option separator = space | return
#
# Registers Used:
#
#   0 - user's MAIL_CONFIG_OPTIONS attribute
#

  $+set mail option separator*=*: 

    @swi/first 

      [setq(0, get(%#/mail_config_options))]

    trim(%1) = 

    s*,
    {
      @pemit %# = switch(member(r(0), space), 
        0, Your 'separator' mail option is now set to 'space'., 
        Your 'separator' mail option is already set to 'space'.); 
      &mail_config_options %# = 
        setunion(s(remove(r(0), return) space), )
    },

    r*,
    {
      @pemit %# = switch(member(r(0), return), 
        0, Your 'separator' mail option is now set to 'return'., 
        Your 'separator' mail option is already set to 'return'.); 
      &mail_config_options %# = 
        setunion(s(remove(r(0), space) return), )
    },

    {
      @pemit %# = The value specified for the mail option 'separator', 
        must be either 'space' or 'return'.
    }

-
###############################################################################
#
#               +S E T   M A I L   O P T I O N   I N B O X
#
###############################################################################
&SET_MAIL_OPTION_INBOX #3479=
#
# PURPOSE:
#
#   This command may be used to specify the name of the folder that 
#   incoming mail should be stored in.
#
# Command Format:
#
#   +set mail option inbox = <folder name>
#
#   The folder name may be multiple words, but is limited to 16 characters
#   and should not contain any characters (besides blanks) which are not
#   allowed in attribute names (i.e., no '`!*()=\[\]{}\%|,<>/?:; " well,
#   you get the idea).
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - folder name, with blanks converted to $
#   2 - list of folders
#

  $+set mail option inbox*=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(1, edit(lcstr(trim(%1)), %b, $))]

    1 = strmatch(escape(%1), *\[*),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(v(mail_system)/nofunc)
    },

    not(strmatch(type(%#), PLAYER)),
    {
#
# User is not a player.
#

      @pemit %# = u(v(mail_system)/not_player)
    },

    eq(strlen(%1), 0),
    {
#
# Nothing was specified as the name of the folder.
#

      @pemit %# = You must specify a name for the folder to be the 
        designated inbox.
    },

    gt(strlen([setq(2, [setq(3, %1)]
      filter(v(mail_system)/check_for_bad_chars, 
      get(v(mail_system)/bad_chars)))]r(2)), 0),
    {
#
# Invalid character detected in folder name.
#

      @pemit %# = Invalid character(s) [r(2)] detected in folder name.
    },

    gt(strlen(%1), 16),
    {
#
# Folder name too long.
#

      @pemit %# = Folder name specified is too long (maximum of 
            16 characters).
    },

    eq(strlen(r(0)), 0),
    {
#
# User has no mailbox.  Simply store inbox value in MAIL_CONFIG_OPTIONS.
#

      &MAIL_CONFIG_OPTIONS %# = 
        [before(get(%#/mail_config_options), INBOX:)] 
        [after(get(%#/mail_config_options), :INBOXEND)] 
        INBOX:[r(1)]:INBOXEND; 
      @pemit %# = '[secure(r(1))]' is now the designated inbox.
    },

    {
#
# User HAS a mailbox.   Store inbox value in MAIL_CONFIG_OPTIONS,
# and make sure inbox is in list of folders.
#

      &MAIL_CONFIG_OPTIONS %# = 
        [before(get(%#/mail_config_options), INBOX:)] 
        [after(get(%#/mail_config_options), :INBOXEND)] 
        INBOX:[r(1)]:INBOXEND; 
      &folder-list [r(0)] = setunion([get(r(0)/folder-list)] [r(1)], ); 
      @pemit %# = '[secure(r(1))]' is now the designated inbox.
    }

-
###############################################################################
#
#           + S E T   M A I L   O P T I O N   V A C A T I O N   
#
###############################################################################
&SET_MAIL_OPTION_VACATION #3479=
#
# PURPOSE:
#
#   This command may be used to set your vacation option.  
#   If you have 'vacation' text associated with your mailbox,
#   any +mail received will result in the vacation text being
#   sent back to the originator.
#
# Command Format:
#
#   +set mail option vacation = <text>
#
# Registers Used:
#
#   0 - mailbox dbref
#

  $+set mail option vacation*=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = 

    and(eq(strlen(r(0)), 0), eq(words(%1), 0)), 
    {
#
# User does not have a mailbox and did not specify vacation text.
#

      @pemit %# = No vacation text registered.
    },

    eq(words(%1), 0), 
    {
#
# User did not specify vacation text and has a mailbox.  Clear
# the vacation text for that mailbox.
#

      &vacation [r(0)] ; 
      @pemit %# = Vacation text cleared.
    },

    eq(strlen(r(0)), 0), 
    {
#
# User has no mailbox and specified vacation text.  Create a mailbox.
#

      @create %N's Mailbox; 
      @set [setq(0, con(me))]r(0) = quiet; 
      @drain [r(0)]; 
      @chown [r(0)] = owner(%vm); 
      @set [r(0)] = !halt; 
      @tel r(0) = %vm; 
      &mailbox_%# %vm = r(0); 
      @trigger %vm/add_mailbox = r(0); 
      &owner_dbref [r(0)] = %#; 
      @startup [r(0)] = {@drain me; @no me}; 
      @set r(0) = safe; 
      &mail-in-progress [r(0)] = false; 
      &current_folder [r(0)] = u(v(mail_system)/get_inbox, %#); 
      &folder-list [r(0)] = get(r(0)/current_folder); 
      &vacation [r(0)] = escape(trim(%1)); 

      @pemit %# = Vacation text set.; 

      @no r(0)
    },

    {
#
# User has a mailbox and specified vacation text.  Save value in mailbox.
#
      &vacation [r(0)] = escape(trim(%1)); 

      @pemit %# = Vacation text set.; 
    }

-
###############################################################################
#
#           + S E T   M A I L   O P T I O N   R E J E C T 
#
###############################################################################
&SET_MAIL_OPTION_REJECT #3479=
#
# PURPOSE:
#
#   This command may be used to set your reject option.  
#   If you have 'reject' text associated with your mailbox,
#   any +mail received will be rejected, and result in the reject 
#   text being sent back to the originator.
#
# Command Format:
#
#   +set mail option reject = <text>
#
# Registers Used:
#
#   0 - mailbox dbref
#

  $+set mail option reject*=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = 

    and(eq(strlen(r(0)), 0), eq(words(%1), 0)), 
    {
#
# User does not have a mailbox and did not specify reject text.
#

      @pemit %# = No reject text registered.
    },

    eq(words(%1), 0), 
    {
#
# User did not specify reject text and has a mailbox.  Clear
# the reject text for that mailbox.
#

      &reject_msg [r(0)] ; 
      @pemit %# = Reject text cleared.
    },

    eq(strlen(r(0)), 0), 
    {
#
# User has no mailbox and specified reject text.  Create a mailbox.
#

      @create %N's Mailbox; 
      @set [setq(0, con(me))]r(0) = quiet; 
      @drain [r(0)]; 
      @chown [r(0)] = owner(%vm); 
      @set [r(0)] = !halt; 
      @tel r(0) = %vm; 
      &mailbox_%# %vm = r(0); 
      @trigger %vm/add_mailbox = r(0); 
      &owner_dbref [r(0)] = %#; 
      @startup [r(0)] = {@drain me; @no me}; 
      @set r(0) = safe; 
      &mail-in-progress [r(0)] = false; 
      &current_folder [r(0)] = u(v(mail_system)/get_inbox, %#); 
      &folder-list [r(0)] = get(r(0)/current_folder); 
      &reject_msg [r(0)] = escape(trim(%1)); 

      @pemit %# = Reject text set.; 

      @no r(0)
    },

    {
#
# User has a mailbox and specified reject text.  Save value in mailbox.
#
      &reject_msg [r(0)] = escape(trim(%1)); 

      @pemit %# = Reject text set.; 
    }

-
###############################################################################
#
#                  + S H O W   M A I L   O P T I O N S               
#
###############################################################################
&SHOW_MAIL_OPTIONS #3479=
#
# PURPOSE:
#
#   This command may be used to see the mail options for a specific
#   mailbox.  If the user has not specified a specific option, the
#   mail system default is used.
#
#   Information shown:
#
#     delete option (hard or soft)
#     mode option (terse or verbose)
#     format option (standard or compact)
#     autoforward (none or player name)
#     timeout option (disabled, or number of days)
#     separator option (space or return)
#     list of personal mail aliases defined
#     number of filters defined
#     list of folders defined
#     designated inbox
#     current folder
#     vacation text registered (if any)
#     reject text registered (if any)
#
# Command Format:
#
#   +show mail option[s]
#
# Registers Used:
#
#   0 - mail system dbref
#   1 - user's format option
#   2 - user's mailbox
#

 $+show mail option*: 

   @pemit %# = 

       [setq(0, v(mail_system))]
       [setq(1, u(r(0)/get_format_option, get(%#/mail_config_options)))]
       [setq(2, get(%vm/mailbox_%#))]

     [switch(r(1), standard,
       {[u(r(0)/equal_line)]

       %rUser mail configuration options:

       %r[u(r(0)/dash_line)]%r}
     )]

     [rjust(Delete:, 15)]%b%b[u(r(0)/get_delete_option, %#)]
     %r[rjust(Mode:, 15)]%b%b[u(r(0)/get_mode_option, %#)]
     %r[rjust(Format:, 15)]%b%b[r(1)]
     %r[rjust(Autoforward:, 15)]%b%b[u(r(0)/get_autoforward_option, %#)]
     %r[rjust(Timeout:, 15)]%b%b[u(r(0)/get_timeout_option, %#)]
     %r[rjust(Separator:, 15)]%b%b[switch(u(r(0)/get_separator_option, %#), %b, 
       space, return)]
     %r[rjust(Aliases:, 15)]%b%b[u(r(0)/get_personal_aliases, %#)]
     %r[rjust(Filters:, 15)]%b%b[u(r(0)/get_filter_count, %#)]
     %r[rjust(Folders:, 15)]%b%b[u(r(0)/get_folders, %#)]
     %r[rjust(Inbox:, 15)]%b%b[secure(u(r(0)/get_inbox, %#))]
     %r[rjust(Current Folder:, 15)]%b%b
       [switch(
         words(r(2)), 
         0, secure(u(r(0)/get_inbox, %#)), 
         secure(get(r(2)/current_folder))
       )]
     %r[rjust(Vacation:, 15)]%b%b
       [switch(
         words(r(2)), 
         0, <none>, 
         switch(get(r(2)/vacation),, <none>, u(r(2)/vacation))
       )]
     %r[rjust(Reject:, 15)]%b%b
       [switch(
         words(r(2)), 
         0, <none>, 
         switch(get(r(2)/reject_msg),, <none>, u(r(2)/reject_msg))
       )]

     [switch(r(1), standard, {%r[u(v(mail_system)/equal_line)]})]
 
-
###############################################################################
#
#                M I S C E L L A N E O U S   C O M M A N D S 
#
###############################################################################

###############################################################################
#
#                        + M A I L   C R E D I T S               
#
###############################################################################
&MAIL_CREDITS #3478=
#
# PURPOSE:
#
#   This command may be used to show the credits for the mail system.
#   Basically, it's a thanks to those who have provided assistance
#   or inspiration in the past.
#
# Command Format:
#
#   +mail credits
#

  $+mail credits: 

    @pemit %# = 
      Credits:

      %r%r%b%bTesting help, moral support[space(9)]- Kelson of CrystalMUSH
      %r%b%bIdea for +unread, .signature 
      %r%b%b%b%b+mark, +unmark [space(19)]- Anastasia of TooMUSH
      %r%b%bBug fixes, additional help text[space(5)]- Zalcor of Singlenesia
      %r%b%bSuggested improvements and patience - AMBAR      
      %r%b%bSpace option, author:<name>, subject:<text> keywords, +note and 
        performance ideas%b - Amberyl      
   
      %r%r%b%b+mail, -, --, +proof, +toss, +send, +skim, +read, 
        +delete (clear), +edit
      %r%b%bwere written from scratch, without seeing his code, but based on the
      %r%b%buser interface of the mailer written by F'jon of PernMUSH, with
      %r%b%bnumerous enhancements.

      %r%r%b%bThe credit/blame for the rest of the commands, goes to Brandy of 
      %r%b%bCrystalMUSH. Send questions/problems/requests to cag@empros.com.

      %r%r%b%bThis +mail code is available via anonymous FTP from 
      %r%b%bcaisr2.caisr.cwru.edu (129.22.24.22) in file:
      %r%b%b/pub/mush/mushcode/brandy_mailer.13

      %r%r%b%b(source code last updated [v(mail_version)])%r

-
###############################################################################
#
#                        + M A I L   C H A N G E S               
#
###############################################################################
&MAIL_CHANGES #3478=
#
# PURPOSE:
#
#   This command documents what the changes are since the last release.
#
# Command Format:
#
#   +mail changes
#

  $+mail changes: 

    @pemit %# = 

      Version 13 updates:

%r%rNew command:%b +add folder <folder name>
%rNew command:%b +remove folder <folder name>
%rNew command:%b +list folders
%rNew command:%b +move <letter> to <folder>
%rNew command:%b +select folder <folder name>
%rNew command:%b +add filter author|subject=<name or text> folder=<folder name>
%rNew command:%b +remove filter <number>
%rNew command:%b +list filters
%rNew command:%b +set mail option separator = space or return 
%rNew command:%b +set mail option inbox = <folder name>
%rNew command:%b +set mail option vacation = <text>
%rNew command:%b +set mail option reject = <text>
%rNew command:%b +note <text> 
%rNew command:%b +forward <destination>=<letter> (additional variation 
%r%ton existing +forward command, see +help forward for details).
%rModified command:%b Replaced '+review letter to <person>' with
  %r%t'+review [<list of numbers or keyword>]'. '+review' w/no parameter
  %r%tshows one summary line per sent letter.  keywords allowed:  all,
  %r%tcurrent, first, last, next, previous, to:<player>, subject:<text>,
  %r%ttext:<text fragment>
%rModifed command:%b Replaced '+retract letter to <person>' with
  %r%t'+retract <letter number or keyword>' keywords allowed:  first,
  %r%tnext, previous, last, current

%r%rPerformance:%b expanded usage of setq()/r() including removal 
  %r%tof ALL temp variable usage
%rPerformance:%b changed code to only store a single copy of all letters

%r%rMisc:%b Allow autoforward to be a list of people and/or aliases
%rMisc:%b allow author:<name>, subject:<text> and text:<text fragment> to 
  be used as keywords
%rMisc:%b +skim now shows a 'n' next to messages that have 
  %r%ta note registered
%rMisc:%b +show mail options now shows value for 'separator' option
%rMisc:%b +show mail options now shows value for 'inbox' option
%rMisc:%b +show mail options now shows value for 'vacation' option
%rMisc:%b +show mail options now shows value for 'reject' option
%rMisc:%b +show mail options now shows list of personal aliases
%rMisc:%b +show mail options now shows list of folders
%rMisc:%b +show mail options now shows number of filters

%rAdmin:%b created command to allow admin to specify when periodic 
  %r%tletter purge should run, default is Wednesdays at 4 AM
  %r%t( format:  +set mail default purge=<day of week> <hour>:<minute> )
%rAdmin:%b created command to allow admin to enable or disable the +save
  %r%tcommand for all users. 
  %r%t( format:  +set mail default save = enabled | disabled )
%rAdmin:%b +set mail default separator = space | return (idea from Amberyl)
%rAdmin:%b +mail configuration shows the default for the 'separator' option
%rAdmin:%b +mail configuration shows when the next letter/mailbox 
  %r%tpurge is scheduled
%rAdmin:%b +mail configuration shows how many attributes are being 
  %r%tused to hold the list of mailboxes
%rAdmin:%b +mail configuration shows the configured text for: 
  %r%tdelivery_notification, pickup_notification, forward_notification, 
  %r%ttext_added_notification does some verification that things were set 
  %r%tup right and warns if not.
%rAdmin:%b +mail status shows number of defined folders and filters
%rAdmin:%b +mail status for <player> shows the new information too
%rAdmin:%b automatically do a +mail configuration at the end 
  %r%tof installation

%r%rBug fixes: +replyall now replies to the sender as well
%rBug fixes: made the code more accurate about overflowing letter size
%rBug fixes: fixed semaphore not being notified in +add global alias and 
  %r%t+edit global alias end cases.
%rBug fixes: fixed bug in the purge old letters code that resulted in an 
  %r%tinfinite loop

-
###############################################################################
#
#       P E R S O N A L   A N D   G L O B A L   M A I L   A L I A S E S
#       in other words, mail distribution lists
#
###############################################################################

###############################################################################
#
#                  + A D D   P E R S O N A L   A L I A S 
#
###############################################################################
&ADD_PERSONAL_ALIAS #3478=
#
# PURPOSE:
#
#   This command may be used to associate an alias with a list of people
#   that you wish to commonly send +mail to.  This way, you can 
#   '+mail my_group=status update' rather than having to always specify 
#   the list of people. The alias must be a single word only, and should 
#   not contain any characters which are not allowed in attribute names 
#   (ie, no '`!*()=[]{}%|,<>/?:; " well, you get the idea).  Personal mail 
#   aliases may only be used by the person who added the alias. If you 
#   wish to add a mail alias that may be used by anyone, the command 
#   '+add global alias <alias>=<list of people>' should be used instead. 
#
# NOTE:  
# 
#   If the player's names contain spaces, each name should be separated by
#   a comma. Example: +add personal alias my_family=Joe Jones, Mary Jones,
#   Baby Jones
#
#   Personal aliases may refer to other personal aliases defined previously 
#   by the user and also any global aliases.
#
# Command Format:
#
#   +add personal alias <alias name> = <list of people or other aliases>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of dbrefs and alias names to match user input
#   2 - dbref of new mailbox created (if needed)
#   3 - new alias name
#   5 - personal mail aliases defined before new one is added
#

  $+add personal alias *=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(5, get(r(0)/alias-list))]

    1 = 

    or(strmatch(escape(%0), *\[*), strmatch(escape(%1), *\[*)),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strmatch(type(*[trim(%0)]), PLAYER),
    {
#
# Alias name specified is the name of a player.  This is not allowed.
#

      @pemit %# = I'm sorry, but the alias you specified is the name of%b
        a player.
    },

    not(strmatch(type(%#), PLAYER)), 
    {
#
# User is not a player.
#

      @pemit %# = u(not_player)
    }, 

    eq(strlen(%0), 0),
    {
#
# Nothing was specified as the name of the personal alias.
#

      @pemit %# = You must specify a name for the alias.
    },

    gt(words(%0), 1),
    {
#
# The alias name specified was more than one word in length.
#

      @pemit %# = The alias must be a single word.
    },

    gt(strlen([setq(2,
      [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]r(2)), 0),
    {
#
# Invalid character detected in alias name.
#

      @pemit %# = Invalid character(s) [r(2)] detected in alias name.
    },

    eq(strlen(%1), 0),
    {
#
# User did not specify a list of people to associate with the new 
# personal alias.
#

      @pemit %# = You need to specify a list of people to associate 
        with the alias.
    },

    eq(strlen(r(0)), 0),
    {
#
# User has no mailbox.
#

      @swi 

        [setq(1, 
          [u(identify_to_list, {%1}, %vm)] 
          [u(get_aliases, {%1}, #0, get(%vm/global-mail-aliases), )]
        )]

      r(1) = *ABORT*,
      {
#
# Error detected in input parameter.
#
        @pemit %# = secure(after(before(r(1), ENDABORT), ABORT))
      },

      {
#
# Create a new mailbox to store the personal alias in to.
#

        @create %N's Mailbox; 
        @set [setq(2, con(me))]r(2) = quiet; 
        @drain [r(2)]; 
        @tel r(2) = %vm; 
        &mailbox_%# %vm = r(2); 
        @trigger %vm/add_mailbox = r(2); 
        &owner_dbref [r(2)] = %#; 
        @startup [r(2)] = {@drain me; @no me}; 
        @set r(2) = safe; 
        &mail-in-progress [r(2)] = false; 
        &current_folder [r(2)] = u(get_inbox, %#); 
        &folder-list [r(2)] = get(r(2)/current_folder); 

        &alias-list [r(2)] = [setq(3, lcstr(trim(%0)))]r(3); 
        &alias-[r(3)] [r(2)] = r(1); 

        @pemit %# = '[r(3)]' has been added as a personal mail alias.;

        @no r(2)
      }
    },

    {
#
# User HAS a mailbox.
#

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

            [setq(1,
#
# Convert list of names specified by the user into dbrefs
#
              [u(identify_to_list, {%1}, r(0))] 
              [u(get_aliases, 
                {%1}, 
                r(0), 
                get(%vm/global-mail-aliases), 
                r(5)
              )]
            )]
            [setq(3, lcstr(trim(%0)))]

        1 = 

        gt(match(r(5), r(3)), 0),
        {
#
# Personal alias already exists by that name.
#

          @pemit %# = You already have a personal alias with this name. 
            If you really mean to totally overwrite it, you should do a 
            +remove personal alias [r(3)], followed by a +add personal alias%b
            [r(3)]=<list of people>.; 
          @no r(0)
        },

        strmatch(r(1), *ABORT*),
        {
#
# Error detected in input parameter.
#
          @pemit %# = secure(after(before(r(1), ENDABORT), ABORT)); 
          @no r(0)
        },

        {
#
# Life is good.  Notify user.
#

          &alias-list [r(0)] = r(5) [r(3)]; 
          &alias-[r(3)] [r(0)] = r(1); 
          @pemit %# = '[r(3)]' has been added as a personal mail alias.; 
          @no r(0)
        }
      }
    }

-
&ADD_PERSONAL_ALIAS_BLANK #3478=

  $+add personal alias: 

    @pemit %# = The syntax is +add personal alias <alias>=<list of people>.

&ADD_ALIAS_BLANK #3478=

  $+add alias: 

    @pemit %# = There are two varieties of mail distribution lists (aliases): 
      personal and global. Personal aliases may be used only by you. Global 
      aliases may be used by all. The syntax is:%r%r

      +add personal alias <alias>=<list of people> -or-%r
      +add global alias <alias>=<list of people>

-
###############################################################################
#
#                + L I S T   P E R S O N A L   A L I A S E S  
#
###############################################################################
&LIST_PERSONAL_ALIASES #3478=
#
# PURPOSE:
#
#   This command may be used to show the names of personal mail aliases 
#   that were previously defined via the '+add personal alias <alias> = 
#   <list of people and/or aliases>' command.
#
# Command Format:
#
#   +list personal aliases
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - personal aliases defined
#   2 - user's format option
#

  $+list personal a*: 

    @swi 

      [setq(0, get(%vm/mailbox_%#))]

    strlen(r(0)) = 0, 
    {
#
# User does not have a mailbox, and therefore, has no personal mail
# aliases.
#

      @pemit %# = You have no personal mail aliases defined.
    },
    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {
        @pemit %# = 

            [setq(1, get(r(0)/alias-list))]
            [setq(2, u(get_format_option, get(%#/mail_config_options)))]

          switch(strlen(r(1)), 
            0, You have no personal mail aliases defined.,
            {
              [switch(r(2), standard, 
                {[u(equal_line)]
                %rList of [name(%#)]'s personal mail aliases:
                %r[u(dash_line)]%r}
              )]

              [iter(r(1), 
                [lcstr(##)]
                [switch(type(*##), PLAYER, {%b-%b( Warning: there is a player%b
                with this name, therefore using this alias will send to%b
                that player instead%b)%b})]
              )]

              [switch(r(2), standard, {%r[u(equal_line)]})]
            }
          ); 

        @no r(0)
      }
    }

-
&LIST_ALIASES_BLANK #3478=

  $+list alias*: 

    @pemit %# = There are two varieties of mail distribution lists (aliases): 
      personal and global. Personal aliases may be used only by you. Global 
      aliases may be used by all. The syntax is:%r%r

      +list personal aliases -or-%r
      +list global aliases

-
###############################################################################
#
#                + E X P A N D   P E R S O N A L   A L I A S   
#
###############################################################################
&EXPAND_PERSONAL_ALIAS #3478=
#
# PURPOSE:
#
#   This command may be used to show the list of people and/or aliases 
#   on the specified personal distribution list which was previously defined
#   via the +'add personal alias <alias> = <list of people and/or aliases>' 
#   command.  You may only expand lists that you own.
#
# Command Format:
#
#   +expand personal alias <alias name>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of personal mail aliases
#   2 - user's format option
#   3 - list of global mail aliases
#   4 - list of people and/or aliases associated with %0
#

  $+expand personal alias *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = 

    strlen(r(0)),
    {
#
# No mailbox for user.
#

      @pemit %# = You do not have a personal mail alias defined with that 
        name.
    },

    eq(strlen([setq(2,
      [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]r(2)), 0),
    {
#
# Invalid character detected in alias name.
#

      @pemit %# = Invalid character(s) [r(2)] detected in alias name.
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @pemit %# = 

            [setq(1, get(r(0)/alias-list))]
            [setq(2, u(get_format_option, get(%#/mail_config_options)))]
            [setq(3, get(%vm/global-mail-aliases))]
            [setq(4, get(r(0)/alias-%0))]

          switch(or(eq(strlen(r(1)), 0), eq(match(r(1), %0), 0)), 
            1, 
              You do not have a personal mail alias defined with that name.,
            {
              [switch(r(2), standard, 
                {[u(equal_line)]
                %rExpansion of %N's personal mail alias 
                '[lcstr(%0)]':
                [switch(type(*##), PLAYER, {%rWARNING: there is a player%b
                with this name, therefore using this alias will send to%b
                that player instead%b)%b})]
                %r[u(dash_line)]%r}
              )]

              [u(pretty_dist, 
                u(get_aliases, {[r(4)]}, r(0), r(3), r(1)), 
                r(0), 
                r(1), 
                r(3), 
                u(snag_dbrefs, r(4))
              )]

              [switch(r(2), standard, {%r[u(equal_line)]})]
            }
          ); 

        @no r(0)
      }
    }

-
&EXPAND_PERSONAL_ALIAS_BLANK #3478=

  $+expand personal alias: 

    @pemit %# = The syntax is +expand personal alias <alias>.

-
&EXPAND_ALIAS_BLANK #3478=

  $+expand alias: 

    @pemit %# = There are two varieties of mail distribution lists (aliases): 
      personal and global. Personal aliases may be used only by you. Global 
      aliases may be used by all. The syntax is:%r%r

      +expand personal alias <alias> -or-%r
      +expand global alias <alias>

-
###############################################################################
#
#                + R E M O V E   P E R S O N A L   A L I A S   
#
###############################################################################
&REMOVE_PERSONAL_ALIAS #3478=
#
# PURPOSE:
#
#   This command may be used to remove a personal distribution list which
#   was previously defined via the +'add personal alias <alias> = 
#   <list of people and/or aliases>' command.  
#
# Command Format:
#
#   +remove personal alias <alias name>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of personal mail aliases
#   2 - alias to remove 
#

  $+remove personal alias *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = 

    or(eq(strlen(%0), 0), eq(strlen(r(0)), 0)),
    {
#
# Personal alias not specified or the user has no mailbox.
#

      @pemit %# = You do not have a personal mail alias defined with that 
        name.
    },

    gt(strlen([setq(2,
      [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]r(2)), 0),
    {
#
# Invalid character detected in alias name.
#

      @pemit %# = Invalid character(s) [r(2)] detected in alias name.
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi 

          [setq(1, get(r(0)/alias-list))]
          [setq(2, lcstr(%0))]

        or(eq(strlen(r(1)), 0), eq(match(r(1), %0), 0)) = 1,
        {
#
# Personal alias specified is not defined in user's mailbox.
#

          @pemit %# = You do not have a personal mail alias defined with that 
            name.; 
          @no r(0)
        },
        {
          &alias-list [r(0)] = s(remove(r(1), r(2))); 
          &alias-%0 [r(0)] ;  

          @pemit %# = '[r(2)]' has been removed from your list 
            of personal mail aliases.; 

          @no r(0); 
        }
      }
    }

-
&REMOVE_PERSONAL_ALIAS_BLANK #3478=

  $+remove personal alias: 

    @pemit %# = The syntax is +remove personal alias <alias>.

-
&REMOVE_ALIAS_BLANK #3478=

  $+remove alias: 

    @pemit %# = There are two varieties of mail distribution lists (aliases):  
      personal and global. Personal aliases may be used only by you. Global 
      aliases may be used by all. The syntax is:%r%r

      +remove personal alias <alias> -or-%r
      +remove global alias <alias>

-
&EDIT_PERSONAL_ALIAS #3478=
#
# PURPOSE:
#
#   This command may be used to edit a personal distribution list which
#   was previously defined via the +'add personal alias <alias> =
#   <list of people and/or aliases>' command.  The standard '^' and '$'
#   may be used for <old text> to prepend and append <next text> respectively.
#
#   Note:  The resultant list of people is checked to verify that all
#   members of the distribution list are valid players or mail aliases.
#
# Command Format:
#
#   +edit personal alias <alias name> = <old text>/<new text>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - alias name
#   2 - old text
#   3 - new text
#   4 - list of dbrefs and aliases associated with alias before edit
#   5 - personal mail aliases defined
#   6 - global mail aliases defined
#   7 - 'prettified' version of personal alias list before edit
#

  $+edit personal alias *=*/*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    0 = 

    strlen(r(0)), 
    {

#
# User has no mailbox and therefore no personal aliases.
#

      @pemit %# = You do not have a personal mail alias defined with that 
        name.
    },

    eq(strlen([setq(2,
      [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]r(2)), 0),
    {
#
# Invalid character detected in alias name.
#

      @pemit %# = Invalid character(s) [r(2)] detected in alias name.
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(1, lcstr(trim(%0)))]
          [setq(2, lcstr(trim(%1)))]
          [setq(3, trim(%2))]
          [setq(4, get(r(0)/alias-[r(1)]))]
          [setq(5, get(r(0)/alias-list))]
          [setq(6, get(%vm/global-mail-aliases))]
          [setq(7, lcstr(u(pretty_dist, u(get_aliases, r(4), r(0), r(6), r(5)), 
            r(0), r(5), r(6), u(snag_dbrefs, r(4)))))]

        1 = eq(strlen(r(1)), 0),
        {
#
# Personal alias not specified.
#

          @pemit %# = You must specify a name for the alias you wish to edit.; 
          @no r(0)
        },

        gt(words(r(1)), 1), 
        {
#
# Multi-word personal alias specified.
#

          @pemit %# = The alias must be a single word.; 
          @no r(0)
        },

        eq(match(r(5), r(1)), 0), 
        {
#
# You do not have a personal alias by that name defined.
#

          @pemit %# = You do not have a personal mail alias defined with that%b
            name.; 
          @no r(0)
        },

        eq(strlen(r(4)), 0),
        {
#
# Found match on personal alias, alias has no members. Set members of
# alias to substitute text.
#

          @tr me/cleanup_edit_mail_palias = %#, r(3), r(0), r(1)
        },

        strmatch(r(2), $), 
        {
#
# Found match on personal alias, alias has at least one member. Insert
# substitute text at end.
#

          @tr me/cleanup_edit_mail_palias = 
            %#,
            u(clean_dist, {[r(4)], [r(3)]}), 
            r(0),
            r(1)
        },

        strmatch(r(2), ^), 
        {
#
# Found match on personal alias, alias has at least one member. Insert
# substitute text at beginning.
#

          @tr me/cleanup_edit_mail_palias = 
            %#,
            u(clean_dist, {[r(3)], [r(4)]}), 
            r(0),
            r(1)
        },

        strmatch(r(7), *[r(2)]*), 
        {
#
# Replace <old text> with <new text>
#

          @tr me/cleanup_edit_mail_palias = 
            %#,
            u(clean_dist, edit(r(7), r(2), r(3))), 
            r(0), 
            r(1)
        }, 
   
        {
          @pemit %# = Unable to find '[r(2)]' in current value for personal 
          alias '[r(1)]'.%b Please check the exact format by doing a 
          '+expand personal alias [r(1)]'.; 
          @no r(0)
        }
      }
    }

-
&CLEANUP_EDIT_MAIL_PALIAS #3482=
#
# PURPOSE:
#
#   This is a helper routine for '+edit personal alias <alias>=<old>/<new>'.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - list of names after edit
#   %2 - dbref of mailbox
#   %3 - name of personal alias
#
# Registers Used:
#
#   1 - list of dbrefs       
#   2 - global mail aliases
#   3 - personal mail aliases
#   4 - list of aliases
#

  @swi 

    [setq(1, u(identify_to_list, {%1}, %2))]
    [setq(2, get(%vm/global-mail-aliases))]
    [setq(3, get(%2/alias-list))]
    [setq(4, u(get_aliases, {%1}, %2, r(2), r(3)))]

  r(1) = *ABORT*, 
  {
#
# Error detected in input parameter.
#
    @pemit %0 = secure(after(before(r(1), ENDABORT), ABORT)); 
    @no %2
  },
  {
#
# Weed out duplicates.
#

    &alias-%3 %2 = [r(1)] [r(4)]; 

    @pemit %0 = 

      switch(words([r(1)] [r(4)]), 
        0, {No names are associated with the specified alias.}, 
        {Your '%3' personal alias has been updated and is now set to:
        %b [u(pretty_dist, r(4), %2, r(3), r(2), r(1))]}
      ); 

    @no %2
  }

-
###############################################################################
#
#                 + L I S T   G L O B A L   A L I A S E S
#
###############################################################################
-
&LIST_GLOBAL_ALIASES #3478=
#
# PURPOSE:
#
#   This command may be used to show the names of global mail aliases
#   that were previously defined via the '+add global alias <alias> =
#   <list of people and/or aliases>' command.  These aliases may be
#   used by anyone while writing +mail.
#
# Command Format:
#
#   +list global aliases
#
# Registers Used:
#
#   0 - list of global mail aliases defined
#   1 - user's format option
#

  $+list global a*: 

    @swi 

      [setq(0, get(%vm/global-mail-aliases))]

    strlen(r(0)) = 0, 
    {
      @pemit %# = There are no global mail aliases defined.
    },
    {
      @pemit %# = 

          [setq(1, u(get_format_option, get(%#/mail_config_options)))]

        [switch(r(1), standard, 
          {[u(equal_line)]
          %rList of global mail aliases:
          %r[u(dash_line)]%r}
        )]

        [iter(r(0), 
          [lcstr(##)]
          [switch(type(*##), PLAYER, {%b-%b( Warning:%b there is a player%b
          with this name, therefore using this alias will send to%b
          that player instead%b)%b})])]

        [switch(r(1), standard, {%r[u(equal_line)]})]; 
    }

-
###############################################################################
#
#                    + A D D   G L O B A L   A L I A S
#
###############################################################################
&ADD_GLOBAL_ALIAS #3478=
#
# PURPOSE:
#
#   This command may be used to associate an alias with a list of people
#   that it is felt many people would wish to send +mail to as a group. 
#   This way, you can '+mail wizards=question' rather than having to 
#   always specify the list of people. The alias must be a single word 
#   only, and should not contain any characters which are not allowed 
#   in attribute names (ie, no '`!*()=[]{}%|,<>/?:; " well, you get the 
#   idea).  Global mail aliases may be used by anyone using the +mail
#   system.  If you wish to add a personal mail alias that is for your
#   use alone, the command '+add personal alias <alias>=<list of people>
#   should be used instead.
#
# NOTE:
#
#   If the player's names contain spaces, each name should be separated by
#   a comma. Example: +add global alias my_family=Joe Jones, Mary Jones,
#   Baby Jones
#
#   Global aliases may refer to other global aliases.
#
# Command Format:
#
#   +add global alias <alias name> = <list of people or other aliases>
#
# Registers Used:
#
#   0 - new alias name
#   1 - list of names and alias names to match user input
#   2 - list of global mail aliases defined
#   3 - list of player dbrefs and aliases associated with new alias
#

  $+add global alias *=*: 

#
# Snag the semaphore on the Master Mailbox.
#

   @wait %vm = 
   {

     @swi/first 

       [setq(0, lcstr(trim(%0)))]
       [setq(1, trim(%1))]
       [setq(2, get(%vm/global-mail-aliases))]

     1 = or(strmatch(escape(%0), *\[*), strmatch(escape(%1), *\[*)),
     {
#
# Cannot have a '[' as part of an input parameter.
#

       @pemit %# = u(nofunc); 
       @no %vm
     },

     strmatch(type(*[r(0)]), PLAYER),
     {
#
# Player's names are not allowed to be used as global aliases.
#

       @pemit %# = I'm sorry, the alias you specified is the name of a%b
         player.; 
       @no %vm
     },

     not(strmatch(type(%#), PLAYER)),
     {
       @pemit %# = u(not_player); 
       @no %vm
     },

     eq(strlen(r(0)), 0),
     {
#
# Did not specify name for the global alias to add.
#

       @pemit %# = You must specify a name for the global alias.; 
       @no %vm
     },

     gt(strlen([setq(4,
       [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]r(4)), 0),
     {
#
# Invalid character detected in alias name.
#

       @pemit %# = Invalid character(s) [r(4)] detected in alias name.; 
       @no %vm
     },

     gt(words(r(0)), 1), 
     {
#
# Multi-word value specified for the global alias to add. Aliases must
# be one word only.
#

       @pemit %# = The global alias must be a single word.; 
       @no %vm
     },

     eq(strlen(r(1)), 0),
     {
#
# No members specified for the global alias to add.
#

       @pemit %# = You need to specify a list of people to associate%b
         with the global alias.; 
       @no %vm
     },

     gt(match(r(2), r(0)), 0),
     {
#
# A global alias already exists with this name.  
#

       @pemit %# = A global already exists with this name.; 
       @no %vm
     },

     {
#
# Attempt to parse the member list (which may include other global aliases)
#

       @swi 
       
         [setq(3, 
           [u(identify_to_list, {[r(1)]}, %vm)] 
           [u(get_aliases, 
             {[r(1)]}, 
             %0, 
             r(2), 
           )]
         )]

       r(3) = *ABORT*,
       {
#
# Error detected in member list for alias to add.
#

         @pemit %# = secure(after(before(r(3), ENDABORT), ABORT)); 
         @no %vm
       },

       {
#
# Everything is fine, add the global alias and notify the invoker.
#

         &global-mail-aliases %vm = r(2) [r(0)]; 
         &alias-[r(0)] %vm = r(3); 
         @pemit %# = '[r(0)]' has been added as a global mail alias.; 
         &alias-[r(0)]-created-by %vm = %# %N on [time()]; 
         @no %vm
       }
     }
   }

-
&ADD_GLOBAL_ALIAS_BLANK #3478=

  $+add global alias: 

    @pemit %# = The syntax is +add global alias <alias>=<list of people>.

-
###############################################################################
#
#                + E X P A N D   G L O B A L   A L I A S
#
###############################################################################
&EXPAND_GLOBAL_ALIAS #3478=
#
# PURPOSE:
#
#   This command may be used to show the list of people and/or aliases
#   on the specified global distribution list which was previously defined
#   via the +'add global alias <alias> = <list of people and/or aliases>'
#   command.  You may expand any distribution list.
#
# Command Format:
#
#   +expand global alias <alias name>
#
# Registers Used:
#
#   0 - list of global mail aliases
#   1 - user's format option
#   2 - list of people and/or aliases associated with %0
#

  $+expand global alias *: 

    @swi/first 

      [setq(0, get(%vm/global-mail-aliases))]

    1 = 

    gt(strlen([setq(1,
      [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]r(1)), 0),
    {
#
# Invalid character detected in alias name.
#

      @pemit %# = Invalid character(s) [r(1)] detected in alias name.
    },

    or(eq(strlen(%0), 0), eq(strlen(r(0)), 0), eq(match(r(0), %0), 0)),
    {
      @pemit %# = There is no global mail alias defined with that name.
    },

    {
      @pemit %# = 

        [setq(1, u(get_format_option, get(%#/mail_config_options)))]
        [setq(2, get(%vm/alias-%0))]

        [switch(r(1), standard, 
          {[u(equal_line)]
          %rExpansion of global mail alias 
          '[lcstr(%0)]'%r( Last modified by 
          [rest(get(%vm/alias-%0-created-by))] )
          [switch(type(*%0), PLAYER, {%rWARNING: there is a player%b
          with this name, therefore using this alias will send to%b
          that player instead%b)%b})]
          %r[u(dash_line)]%r}
        )]

        [u(pretty_dist, 
          u(get_aliases, {[r(2)]}, %vm, r(0), , ), %vm, , r(0), 
            u(snag_dbrefs, r(2))
        )]

        [switch(r(1), standard, {%r[u(equal_line)]})]; 
    }

-
&EXPAND_GLOBAL_ALIAS_BLANK #3478=

  $+expand global alias: 

    @pemit %# = The syntax is +expand global alias <alias>.

-
&EDIT_GLOBAL_ALIAS #3478=
#
# PURPOSE:
#
#   This command may be used to edit a global distribution list which
#   was previously defined via the +'add global alias <alias> =
#   <list of people and/or aliases>' command.  The standard '^' and '$'
#   may be used for <old text> to prepend and append <next text> respectively.
#
#   Note:  The resultant list of people is checked to verify that all
#   members of the distribution list are valid players or mail aliases.
#
# Command Format:
#
#   +edit global alias <alias name> = <old text>/<new text>
#
# Registers Used:
#
#   0 - alias name
#   1 - old text
#   2 - new text
#   3 - needed by filter() call
#   4 - list of dbrefs and aliases associated with alias before edit
#   5 - bad characters detected in alias name
#   6 - list of global mail aliases
#   7 - prettified version of r(4)
#

  $+edit global alias *=*/*: 

#
# Snag the semaphore
#

    @wait %vm = 
    {

      @swi/first 

        [setq(0, trim(lcstr(%0)))]
        [setq(1, lcstr(trim(%1)))]
        [setq(2, trim(%2))]
        [setq(4, get(%vm/alias-[r(0)]))]
        [setq(6, get(%vm/global-mail-aliases))]
        [setq(7, lcstr(u(pretty_dist, u(get_aliases, r(4), #0, r(6), ), #0, , 
          r(6), u(snag_dbrefs, r(4)))))]

      1 = 
      gt(strlen([setq(5,
        [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]r(5)), 0),
      {
#
# Invalid character detected in alias name.
#

        @pemit %# = Invalid character(s) [r(5)] detected in alias name.; 
        @no %vm
      },

      [or(
        eq(strlen(r(0)), 0),
        eq(strlen(r(6)), 0),
        eq(match(r(6), lcstr(r(0))), 0)
      )],
      {
#
# There is no global mail alias by that name.
#

        @pemit %# = There is no global mail alias defined with that name.; 
        @no %vm
      },

      not(or(
        hasflag(%#, wizard),
        strmatch(
          %#,
          first(get(%vm/alias-[r(0)]-created-by))
        )
      )),
      {
#
# Permission denied.  In order to edit a global alias, you must either
# be the person who last modified (added) the alias, or be a wizard.
#

        @pemit %# = I'm sorry, you may only edit global mail aliases%b
          that you added. If you still desire to have the alias modified,%b
          please contact the person who added the alias, or a wizard.; 
        @no %vm
      },

      eq(strlen(r(4)), 0),
      {
#
# Found match on global alias, alias has no members. Set members of
# alias to substitute text.
#

        @tr me/cleanup_edit_mail_galias = %#, r(2), r(0)
      },

      strmatch(r(1), $),
      {
#
# Found match on global alias, alias has at least one member. Insert
# substitute text at end.
#

        @tr me/cleanup_edit_mail_galias = 
          %#, 
          u(clean_dist, {[r(4)], [r(2)]}), 
          r(0)
      },

      strmatch(r(1), ^),
      {
#
# Found match on global alias, alias has at least one member. Insert
# substitute text at beginning.
#

        @tr me/cleanup_edit_mail_galias = 
          %#, 
          u(clean_dist, {[r(4)], [r(2)]}), 
          r(0)
      },

      strmatch(r(7), *[r(1)]*), 
      {
#
# Replace <old text> with <new text>
#

        @tr me/cleanup_edit_mail_galias =
          %#,
          u(clean_dist, edit(r(7), r(1), r(2))), 
          r(0)
      },

      {
        @pemit %# = Unable to find '[r(1)]' in current value for global 
          alias '[r(0)]'.%b Please check the exact format by doing a 
          '+expand global alias [r(0)]'.; 
        @no %vm
      }
    }

-
&CLEANUP_EDIT_MAIL_GALIAS #3482=
#
# PURPOSE:
#
#   This is a helper routine for '+edit global alias <alias>=<old>/<new>'.
#
# INPUT:
#
#   %0 - dbref of invoker
#   %1 - list of names after edit
#   %2 - name of global alias
#
# Registers Used:
#
#   1 - dbrefs alone
#   2 - global mail aliases
#   3 - aliases alone
#

  @swi 

    [setq(1, u(identify_to_list, {%1}, %vm))]
    [setq(2, get(%vm/global-mail-aliases))]
    [setq(3, u(get_aliases, {%1}, #0, r(2), ))]

  r(1) = *ABORT*, 
  {
#
# Error detected in input parameter.
#
    @pemit %0 = secure(after(before(r(1), ENDABORT), ABORT)); 
    @no %vm
  }, 
  {
    &alias-%2 %vm = [r(1)] [r(3)]; 
    &alias-%2-created-by %vm = %0 [name(%0)] on [time()]; 

    @pemit %0 = 

      switch(
        words([r(1)] [r(3)]), 
        0, {No names are associated with the specified alias.}, 
        {The '%2' global alias has been updated and is now set to:
        %b [u(pretty_dist, r(3), #0, , r(2), r(1))]}
      ); 

    @no %vm
  }

-
&SNAG_DBREFS #3482 = 

  iter(%0, switch(##, #*, ##, ))

-
###############################################################################
#
#                + R E M O V E   G L O B A L   A L I A S
#
###############################################################################
&REMOVE_GLOBAL_ALIAS #3478=
#
# PURPOSE:
#
#   This command may be used to remove a global distribution list which
#   was previously defined via the +'add global alias <alias> =
#   <list of people and/or aliases>' command.  You may only remove
#   global distribution lists that you added (unless you are a wizard).
#
# Command Format:
#
#   +remove global alias <alias name>
#
# Registers Used:
#
#   0 - list of global mail aliases
#   1 - alias to remove
#

  $+remove global alias *: 

#
# Snag the semaphore
#

    @wait %vm = 
    {

      @swi/first 1 = 

        [setq(0, get(%vm/global-mail-aliases))]
        [setq(1, lcstr(trim(%0)))]

      gt(strlen([setq(2,
        [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]r(2)), 0),
      {
#
# Invalid character detected in alias name.
#

        @pemit %# = Invalid character(s) [r(2)] detected in alias name.; 
        @no %vm
      },

      or(
        eq(strlen(%0), 0),
        eq(strlen(r(0)), 0),
        eq(match(r(0), %0), 0)
      ),
      {
        @pemit %# = There is no global mail alias defined with that name.; 
        @no %vm
      },

      or(
        hasflag(%#, wizard),
        strmatch(%#, first(get(%vm/alias-[r(1)]-created-by))
        )
      ),
      {
        &global-mail-aliases %vm = s(remove(r(0), r(1))); 

        &alias-%0 %vm ; 
        &alias-[r(1)]-created-by %vm ; 

        @pemit %# = '[r(1)]' has been removed from the list 
          of global mail aliases.; 

        @no %vm
      },

      {
        @pemit %# = I'm sorry, you may only remove global mail aliases%b
          that you added. If you still desire to have the alias removed,%b
          please contact the person who added the alias, or a wizard.; 

        @no %vm
      }
    }

-
&REMOVE_GLOBAL_ALIAS_BLANK #3478=

  $+remove global alias: 

    @pemit %# = The syntax is +remove global alias <alias>.

-
###############################################################################
#
#               F O L D E R   R E L A T E D   C O M M A N D S
#
###############################################################################

###############################################################################
#
#                        + L I S T   F O L D E R S
#
###############################################################################
&LIST_FOLDERS #3478=
#
# PURPOSE:
#
#   This command may be used to show one line of information per folder 
#   in the user's mailbox.  Information shown includes:  folder name, a 
#   count of how many letters are in the folder, how many are marked for 
#   deletion, how many are marked, how many are 'save'ed, how many
#   are close to being timed out and how many are unread.
#
# Command Format:
#
#   +list folders
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   2 - list of letters in a folder
#   3 - user's format option
#

  $+list folders: 

    @swi 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(3, u(get_format_option, get(%#/mail_config_options)))]

    strlen(r(0)) = 0,
    {
#
# User does not have a mailbox, and therefore, has no folders.
#

      @pemit %# = 

        [switch(r(3), standard,
          {[u(equal_line)]
          %rList of %N's folders:%r%r}
        )]

        Folder Name[space(5)]D-flag[space(5)]Marked[space(6)]
          Saved[space(2)]Timed Out[space(5)]Unread[space(6)]Total
        %r[u(dash_line)]%r

        [ljust(secure(u(get_inbox, %#)), 21)]
        0[space(10)]0[space(10)]0[space(10)]0[space(10)]0[space(10)]0

        [switch(r(3), standard, {%r[u(equal_line)]})]
    },
    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {
        @pemit %# = 

          [switch(r(3), standard, 
            {[u(equal_line)]
            %rList of %N's folders:%r}
          )]

          Folder Name[space(5)]D-flag[space(5)]Marked[space(6)]
            Saved[space(2)]Timed Out[space(5)]Unread[space(6)]Total
          %r[u(dash_line)]

          [iter(get(r(0)/folder-list),

              [setq(2, get(r(0)/in-list-##))]

            %r[ljust(secure(lcstr(##)), 17)]

            [switch(
              strlen(r(2)), 
              0, 
                [space(4)]0[space(10)]0[space(10)]0[space(10)]0
                  [space(10)]0[space(10)]0, 
              {
                [rjust(u(count_deleted_letters, r(0), r(2)), 5)]
                [rjust(u(count_marked_letters, r(0), r(2)), 11)]
                [rjust(u(count_saved_letters, r(0), r(2)), 11)]
                [rjust(u(count_timed_out_letters, r(0), r(2)), 11)]
                [rjust(u(count_unread_letters, r(0), r(2)), 11)]
                [rjust(words(r(2)), 11)]
              }
            )]
          )]

          %r%rSelected folder:%b [u(get_active_folder, r(0))]

          [switch(r(3), standard, {%r[u(equal_line)]})]; 

        @no r(0)
      }
    }

-
###############################################################################
#
#                                 + M O V E
#
###############################################################################
&MOVE_LETTER_TO_FOLDER #3478=
#
# PURPOSE:
#
#   This command may be used to move one or more letters to a specified
#   folder.
#
# Command Format:
#
#   +move <letter(s) or keyword> to <folder name>
#
#   The following keywords are available to specify the scope of +move:
#
#     all, current (default), deleted, first, marked, last, next, 
#     previous, saved, unread
#
#   Only the first character of the keyword needs to be specified.
#
#   This command also accepts a list of numbers, including ranges.  For
#   example:  +move 1 3-5 8.  Either a '-' or a '..' may be used to
#   indicate a range specification.
#
#   The folder name may be multiple words, but is limited to 16 characters
#   and should not contain any characters (besides blanks) which are not
#   allowed in attribute names (i.e., no '`!*()=\[\]{}\%|,<>/?:; " well,
#   you get the idea).
#
#   If the folder does not exist, it will be created automatically.
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of internal mail numbers to move
#   2 - new value for current letter in active folder
#   3 - list of external mail numbers to move
#   5 - folder to move to, with internal blanks changed to $s.
#   6 - list of internal mail numbers for the current folder
#

  $+move* to *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(5, lcstr(edit(trim(%1), %b, $)))]

    0 = strmatch(type(%#), PLAYER),
    {
      @pemit %# = u(not_player)
    },

    not(or(
      strmatch(escape(%0), *\[*), 
      strmatch(escape(%1), *\[*)
    )),
    {
#
# Function calls are not allowed within an input parameter.
#

      @pemit %# = u(nofunc)
    },

    strlen(r(0)), 
    {
#
# User has no mailbox.
#

      @pemit %# = u(nomail, u(get_inbox, %#))
    },

    eq(strlen([setq(2,
      [setq(3, %1)]filter(check_for_bad_chars, v(bad_chars)))]r(2)), 0),
    {
#
# Invalid character detected in folder name.
#

      @pemit %# = Invalid character(s) [r(2)] detected in folder name.
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 

          [setq(6, u(get_folder_in_list, r(0)))]

          [setq(1, 
#
# Interpret user input and convert into a list of internal mail numbers
#
            u(expand_letter_range,
              %0,
              r(6), 
              u(get_folder_current_letter, r(0)),
              r(0)
            )
          )]

          [setq(1, 
#
# Reorder the list of letters to mark into the same order as is in
# the in-list-<folder> attribute.  This is needed due to setunion's distressing
# habit of returning sorted lists.
#
            u(filter_list, setunion(r(1), ), r(6))
          )]

          [setq(2, 
#
# Determine the internal mail number of the last letter to delete
#
            match(r(6), first(revwords(r(1))))
          )]

          [setq(2, 
#
# Determine what the 'current letter' will be after all requested
# moves have occurred.  If the last letter in the in-list-<folder> is
# moved, set 'current letter' to the first letter in the in-list-<folder>.
# Otherwise, set 'current letter' to the letter after the last
# one moved.
#
            switch(

              first(revwords(r(1))), 
              first(revwords(r(6))), 

                first(r(6)), 

              extract(r(6), add(r(2), 1), 1)
            )
          )]

          [setq(3, 
#
# Convert the list of internal mail numbers to external mail numbers
# for use in later display to the user.
#

            u(convert_nums, r(1), r(6))
          )]

        0 = strlen(%1),
        {
#
# No destination specified for where to move the letter to.  Notify user
# and release the semaphore.
#

          @pemit %# = You must specify a destination folder to move the 
            mail to.; 
          @no r(0)
        },

        lte(strlen(%1), 16),
        {
#
# Folder name too long.  Notify user and release the semaphore.
#

          @pemit %# = Folder name specified is too long (maximum of 
            16 characters).; 
          @no r(0)
        },

        strlen(r(6)),
        {
#
# There is no mail in the user's mailbox.  Notify user and release 
# the semaphore.
#

          @pemit %# = u(nomail, u(get_active_folder, r(0))); 
          @no r(0)
        },

        not(strmatch(r(1), *ABORT*)),
        {
#
# Error detected in input parameter.  Notify the user, clear global
# variables and release the semaphore.
#

          @pemit %# = after(before(r(1), ENDABORT), ABORT); 
          @no r(0)
        },

        strlen(r(1)), 
        {
#
# Could not find any letters to match the specified input parameter.
# Notify the user, clear global variables and release the semaphore.
#

          @pemit %# = u(no_match, +move, u(format_request, trim(%0)), 
            u(get_active_folder, r(0))); 
          @no r(0)
        },

        not(strmatch(r(5), get(r(0)/current_folder))), 
        {
#
# Folder to move to is the current folder.  No action needed.
#

          @pemit %# = The folder specified to move the letter(s) to 
            is the current folder ([u(get_active_folder, r(0))]), 
            no action needed.; 
          @no r(0)
        },

        match(get(r(0)/folder-list), r(5)), 
        {
#
# Folder does not exist, create one.
#

          &folder-list [r(0)] = get(r(0)/folder-list) [r(5)]; 
          &in-list-[r(5)] [r(0)] = r(1); 
          &current_letter-[r(5)] [r(0)] = first(r(1)); 

          &[u(which_in_list, r(0))] [r(0)] = 
            u(filter_list, setdiff(r(6), r(1)), r(6)); 

          &[u(which_current_letter, r(0))] [r(0)] = r(2); 

          @pemit %# = Message(s) [r(3)]
            [u(format_request, trim(%0))] moved 
            from folder '[u(get_active_folder, r(0))]' 
            to newly created folder '[lcstr(%1)]'.; 

          @no r(0)
        }, 

        {
#
# Folder exists, just move letters over.
#

          &in-list-[r(5)] [r(0)] = s([get(r(0)/in-list-[r(5)])] [r(1)]);

          &current_letter-[r(5)] [r(0)] = first(get(r(0)/in-list-[r(5)])); 

          &[u(which_in_list, r(0))] [r(0)] = 
            u(filter_list, setdiff(r(6), r(1)), r(6)); 

          &[u(which_current_letter, r(0))] [r(0)] = r(2); 

          @pemit %# = Message(s) [r(3)]
            [u(format_request, trim(%0))] moved 
            from folder '[u(get_active_folder, r(0))]' 
            to folder '[lcstr(%1)]'.; 

          @no r(0)
        }
      }
    }


-
&MOVE_NO_PARAM #3478=

  $+move:

    @pemit %# = There are two ways to +move one or more letters to 
      another folder.

      %r%r1) +move to <folder name> - will move the current 
      letter to the specified folder (example:%b +move to things to do)

      %r%r2) +move <keyword or list of letters> 
      to <folder name> - will move the specified letters to the named 
      folder.%r%rThe folder will be created if it doesn't already exist.%b 
      See '+help move' for more details.

-
###############################################################################
#
#                      + A D D   F O L D E R
#
###############################################################################
&ADD_FOLDER #3478=
#
# PURPOSE:
#
#   This command may be used to create a folder that mail may be moved to.
#   folder.
#
# Command Format:
#
#   +add folder <folder name>
#
#   The folder name may be multiple words, but is limited to 16 characters
#   and should not contain any characters (besides blanks) which are not
#   allowed in attribute names (i.e., no '`!*()=\[\]{}\%|,<>/?:; " well,
#   you get the idea).
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - folder name, with blanks converted to $
#   2 - newly created mailbox (if necessary)
#   4 - list of folders
#

  $+add folder *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(1, edit(lcstr(%0), %b, $))]

    1 = strmatch(escape(%0), *\[*),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    not(strmatch(type(%#), PLAYER)),
    {
#
# User is not a player.
#

      @pemit %# = u(not_player)
    },

    eq(strlen(%0), 0),
    {
#
# Nothing was specified as the name of the folder.
#

      @pemit %# = You must specify a name for the folder.
    },

    gt(strlen([setq(2, 
      [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]r(2)), 0),
    {
#
# Invalid character detected in folder name.
#

      @pemit %# = Invalid character(s) [r(2)] detected in folder name.
    },

    gt(strlen(%0), 16),
    {
#
# Folder name too long.
#

      @pemit %# = Folder name specified is too long (maximum of 
            16 characters).
    },

    eq(strlen(r(0)), 0),
    {
#
# User has no mailbox.
#

#
# Create a new mailbox and store the folder name in it.
#

      @create %N's Mailbox; 
      @set [setq(2, con(me))]r(2) = quiet; 
      @drain [r(2)]; 
      @tel r(2) = %vm; 
      &mailbox_%# %vm = r(2); 
      @trigger %vm/add_mailbox = r(2); 
      &owner_dbref [r(2)] = %#; 
      @startup [r(2)] = {@drain me; @no me}; 
      @set r(2) = safe; 
      &mail-in-progress [r(2)] = false; 
      &folder-list [r(2)] = setunion(r(1), u(get_inbox, %#)); 
      &current_folder [r(2)] = u(get_inbox, %#); 

      @pemit %# = '[secure(r(1))]' has been added as a folder.;

      @no r(2)
    },

    {
#
# User HAS a mailbox.
#

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @pemit %# = 

            [setq(4, get(r(0)/folder-list))]

          switch(
            gt(match(r(4), r(1)), 0), 
            1, You already have a folder with this name., 
            '[secure(r(1))]' has been added as a folder.
          ); 

        &folder-list [r(0)] = setunion(r(4) [r(1)], ); 
        @no r(0)
      }
    }

-
###############################################################################
#
#                      + R E M O V E   F O L D E R
#
###############################################################################
&REMOVE_FOLDER #3478=
#
# PURPOSE:
#
#   This command may be used to remove a folder that was previously defined
#   either by an explicit '+add folder <folder name>' command, or 
#   indirectly by a '+move <letter(s) or keyword> to <folder name>' command.
#
# Command Format:
#
#   +remove folder <folder name>
#
#   The folder name may be multiple words, but is limited to 16 characters
#   and should not contain any characters (besides blanks) which are not
#   allowed in attribute names (i.e., no '`!*()=\[\]{}\%|,<>/?:; " well,
#   you get the idea).
#
# NOTE:
#
#   You may only remove empty folders.
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of folders
#   2 - folder name with blanks converted to $
#   3 - current folder
#

  $+remove folder*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(2, lcstr(edit(trim(%0), %b, $)))]

    1 = 

    strmatch(escape(%0), *\[*),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    strmatch(r(2), u(get_inbox, %#)),
    {
      @pemit %# = You are not allowed to remove the designated 'inbox' folder.
    },

    eq(words(%0), 0), 
    {
#
# Folder not specified.
#

      @pemit %# = You must specify a name for the folder.
    },
  
    eq(strlen(r(0)), 0), 
    {
#
# The user has no mailbox.
#

      @pemit %# = You do not have a folder defined with that name.
    },

    not(strmatch(type(%#), PLAYER)),
    {
#
# User is not a player.
#

      @pemit %# = u(not_player)
    },

    gt(strlen(r(0)), 16),
    {
#
# Folder name too long.
#

      @pemit %# = Folder name specified is too long (maximum of 
            16 characters).
    },

    gt(strlen([setq(1,
      [setq(3, trim(%0))]filter(check_for_bad_chars, v(bad_chars)))]r(1)), 0),
    {
#
# Invalid character detected in folder name.
#

      @pemit %# = Invalid character(s) [r(1)] detected in folder name.
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 1 = 

          [setq(1, get(r(0)/folder-list))]

        or(
          eq(strlen(r(1)), 0), 
          eq(match(r(1), r(2)), 0)
        ),
        {
#
# Folder specified is not defined in user's mailbox.
#

          @pemit %# = You do not have a folder defined with that name.; 
          @no r(0)
        },

        sign(strlen(get(r(0)/in-list-[r(2)]))),
        {
#
# Folder is not empty.
#

          @pemit %# = The folder specified is not empty and therefore 
            cannot be removed.; 
          @no r(0)
        },

        {
          &folder-list [r(0)] = s(remove(r(1), r(2))); 

          &in-list-[r(2)] [r(0)] ; 
          &current_letter-[r(2)] [r(0)] ; 

          &current_folder [r(0)] = 

              [setq(3, get(r(0)/current_folder))]

            switch(r(2), r(3), u(get_inbox, %#), r(3)); 

          @pemit %# = '[lcstr(trim(%0))]' has been removed from your list 
            of folders.[switch(r(2), r(3),%b '[get(r(0)/current_folder)]' 
            is now the active folder)]; 

          @no r(0)
        }
      }
    }

-
###############################################################################
#
#                      + S E L E C T   F O L D E R
#
###############################################################################
&SELECT_FOLDER #3478=
#
# PURPOSE:
#
#   This command may be used to choose a 'working' folder.  All +mail
#   commands work off the currently selected folder.
#
# Command Format:
#
#   +select folder <folder name>
#
#   The folder name may be multiple words, but is limited to 16 characters
#   and should not contain any characters (besides blanks) which are not
#   allowed in attribute names (i.e., no '`!*()=\[\]{}\%|,<>/?:; " well,
#   you get the idea).
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of folders
#   2 - folder to select with blanks converted to $
#

  $+select folder *: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(2, lcstr(edit(%0, %b, $)))]

    1 = 

    strmatch(escape(%0), *\[*),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    eq(strlen(%0), 0), 
    {
#
# Folder not specified 
#

      @pemit %# = You must specify a name for the folder.
    },

    and(
      eq(strlen(r(0)), 0), 
      strmatch(%0, secure(u(get_inbox, %#)))
    ),
    {
#
# User specified the designated 'inbox' and does not have a mailbox.  
# The designated 'inbox' always exists.
#

      @pemit %# = '[lcstr(%0)]' is already the selected folder.
    },

    eq(strlen(r(0)), 0), 
    {
#
# User specified something other than the designated 'inbox' and 
# does not have a mailbox.  
#
      @pemit %# = You do not have a folder defined with that name.
    },

    not(strmatch(type(%#), PLAYER)),
    {
#
# User is not a player.
#

      @pemit %# = u(not_player)
    },

    gt(strlen(%0), 16),
    {
#
# Folder name too long.
#

      @pemit %# = Folder name specified is too long (maximum of 
            16 characters).
    },

    gt(strlen([setq(1,
      [setq(3, %0)]filter(check_for_bad_chars, v(bad_chars)))]r(1)), 0),
    {
#
# Invalid character detected in folder name.
#

      @pemit %# = Invalid character(s) [r(1)] detected in folder name.
    },

    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi 

            [setq(1, get(r(0)/folder-list))]

        eq(match(r(1), r(2)), 0) = 1, 
        {
#
# Folder specified is not defined in user's mailbox.
#

          @pemit %# = You do not have a folder defined with that name.; 

          @no r(0)
        },

        {
          @pemit %# = 
            switch(
              get(r(0)/current_folder), 
              r(2), '[lcstr(%0)]' is already the selected folder., 
              '[lcstr(%0)]' is now the selected folder.
            ); 

          &current_folder [r(0)] = r(2); 

          @no r(0)
        }
      }
    }

-
###############################################################################
#
#                      + A D D   F I L T E R
#
###############################################################################
&ADD_FILTER #3478=
#
# PURPOSE:
#
#   This command may be used to add a mail filter.
#
#   Incoming mail can be automatically filtered into different folders
#   based on author or partial match on subject line.  
#
#   For example:  
#
#     +add filter author=Brandy folder=ignore
#
#       All incoming mail from Brandy will be stored in folder 'ignore'. ;)
#
#     +add filter subject=interview folder=interviews
#  
#       All incoming mail that has the word 'interview' in it will be
#       stored in folder 'interviews'.
#
# Command Format:
#
#   +add filter author|subject=<name or text> folder=<folder name>
#
#   The folder name may be multiple words, but is limited to 16 characters
#   and should not contain any characters (besides blanks) which are not
#   allowed in attribute names (i.e., no '`!*()=\[\]{}\%|,<>/?:; " etc).
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - folder name, with blanks converted to $
#   2 - newly created mailbox (if necessary)
#   4 - interpreted %0
#

  $+add filter *=* folder*=*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]
      [setq(1, edit(lcstr(trim(%3)), %b, $))]
      [setq(4, switch(trim(%0), s*, subject, a*, author, error))]

    1 = 

    or(
      strmatch(escape(%0), *\[*), 
      strmatch(escape(%1), *\[*), 
      strmatch(escape(%3), *\[*)
    ), 
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    not(strmatch(type(%#), PLAYER)),
    {
#
# User is not a player.
#

      @pemit %# = u(not_player)
    },

    strmatch(r(4), error),
    {
      @pemit %# = You must specify the type of filter, author or 
        subject.%b (syntax:%b +add filter author|subject=<name or text> 
        folder=<folder name>)
    },

    eq(words(%1), 0),
    {
      @pemit %# = You must specify [switch(r(4), author, A player 
        name to filter on, Some text to filter based on subject line)].
        %b (syntax:%b +add filter author|subject=<name or text> 
        folder=<folder name>)
    }, 

    and(
      strmatch(r(4), author), 
      not(strmatch(type(*%1), PLAYER))
    ),
    {
      @pemit %# = Name specified to filter based on author 
        is not an existing player.
    },

    eq(words(%3), 0),
    {
#
# Nothing was specified as the name of the folder.
#

      @pemit %# = You must specify a name for the folder.
    },

    gt(strlen([setq(2, 
      [setq(3, %3)]filter(check_for_bad_chars, v(bad_chars)))]r(2)), 0),
    {
#
# Invalid character detected in folder name.
#

      @pemit %# = Invalid character(s) [r(2)] detected in folder name.
    },

    gt(strlen(%3), 16),
    {
#
# Folder name too long.
#

      @pemit %# = Folder name specified is too long (maximum of 
            16 characters).
    },

    eq(strlen(r(0)), 0),
    {
#
# User has no mailbox.
#

#
# Create a new mailbox and store the filter in it.
#

      @create %N's Mailbox; 
      @set [setq(2, con(me))]r(2) = quiet; 
      @drain [r(2)]; 
      @tel r(2) = %vm; 
      &mailbox_%# %vm = r(2); 
      @trigger %vm/add_mailbox = r(2); 
      &owner_dbref [r(2)] = %#; 
      @startup [r(2)] = {@drain me; @no me}; 
      @set r(2) = safe; 
      &mail-in-progress [r(2)] = false; 
      &[r(4)]_filter [r(2)] = [switch(r(4), author, [num(*%1)], %1)]|[r(1)]; 
      &current_folder [r(2)] = u(get_inbox, %#); 

      @pemit %# = Filter added.; 

      @no r(2)
    },

    {
#
# User HAS a mailbox.
#

#
# Snag the semaphore
#

      @wait r(0) = 
      {
        &[r(4)]_filter [r(0)] = 
           trim(
             [get(r(0)/[r(4)]_filter)]~
             [switch(r(4), author, [num(*%1)], %1)]|[r(1)]
             ,,~
           ); 
        @pemit %# = Filter added.; 
        @no r(0)
      }
    }

-
###############################################################################
#
#                      + R E M O V E   F I L T E R 
#
###############################################################################
&REMOVE_FILTER #3478=
#
# PURPOSE:
#
#   This command may be used to remove a filter that was previously defined
#   by a '+add filter' command.
#
# Command Format:
#
#   +remove filter <number>
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of author filters
#   2 - list of subject filters
#

  $+remove filter*: 

    @swi/first 

      [setq(0, get(%vm/mailbox_%#))]

    1 = 

    strmatch(escape(%0), *\[*),
    {
#
# Function calls are not allowed within an input parameter.
#
      @pemit %# = u(nofunc)
    },

    eq(words(%0), 0), 
    {
#
# Filter not specified.
#

      @pemit %# = You must specify which filter to remove.
    },
  
    eq(strlen(r(0)), 0), 
    {
#
# The user has no mailbox.
#

      @pemit %# = You have no filters defined.
    },

    or(
      not(strmatch(trunc(%0), trim(%0))),
      lt(%0, 1),
      not(isnum(%0))
    ),
    {
#
# Non-natural number specified.
#

      @pemit %# = You must enter a non-zero integer.%b See +list filters 
        for a list of valid numbers.
    }, 
      
    {

#
# Snag the semaphore
#

      @wait r(0) = 
      {

        @swi/first 1 = 

          [setq(1, get(r(0)/author_filter))]
          [setq(2, get(r(0)/subject_filter))]

        gt(%0, add(words(r(1), ~), words(r(2), ~))), 
        {
          @pemit %# = Filter specified does not exist.; 
          @no r(0)
        },

        gt(%0, words(r(1), ~)), 
        {
#
# Subject filter
#

          &subject_filter [r(0)] = ldelete(r(2), sub(%0, words(r(1), ~)), ~); 
          @pemit %# = Subject filter removed.; 
          @no r(0)
        }, 

        {
#
# Author filter
#

          &author_filter [r(0)] = ldelete(r(1), %0, ~);
          @pemit %# = Author filter removed.;
          @no r(0)
        } 
      }
    }

-
###############################################################################
#
#                        + L I S T   F I L T E R S
#
###############################################################################
&LIST_FILTERS #3478=
#
# PURPOSE:
#
#   This command may be used to show one line of information per filter 
#   defined.
#
# Command Format:
#
#   +list filters
#
# Registers Used:
#
#   0 - user's mailbox dbref
#   1 - list of author filters
#   2 - list of author filters
#   3 - user's format option
#

  $+list filters: 

    @swi 

      [setq(0, get(%vm/mailbox_%#))]

    strlen(r(0)) = 0,
    {
      @pemit %# = You have no filters defined.
    },
    {

#
# Snag the semaphore
#

      @wait 

        [setq(1, get(r(0)/author_filter))]
        [setq(2, get(r(0)/subject_filter))]
        [setq(3, u(get_format_option, get(%#/mail_config_options)))]

      r(0) = 
      {
        @pemit %# = 

          switch(add(words(r(1), ~), words(r(2), ~)), 
          0, You have no filters defined.,
          {
          [switch(r(3), standard, 
            {[u(equal_line)]
            %r[center(List of Mail Filters, 78)]%r}
          )]

          [space(6)]Type[space(5)]Value[space(41)]Folder
          %r[u(dash_line)]

          [iter(r(1), 
            %r[rjust(member(r(1), ##, ~), 3)]\\)
            %b%bauthor%b%b%b
            [ljust(
              switch(type(before(##, |)), PLAYER, 
              name(before(##, |)), destroyed player)
            , 46)]
            [ljust(secure(after(##, |)), 16)]
            ,
            ~
          )]

          [iter(r(2), 
            %r[rjust(add(words(r(1), ~), member(r(2), ##, ~)), 3)]\\)
            %b%bsubject%b%b
            [ljust(before(##, |), 46)]
            [ljust(secure(after(##, |)), 16)]
            ,
            ~
          )]

          [switch(r(3), standard, {%r[u(equal_line)]})]}); 

        @no r(0)
      }
    }

-
###############################################################################
#
# #3480 is the Master Mailbox 
#
# Attributes:
#
#   add_mailbox
#   make_mailbox 
#   destroy_mailbox
#
#   @startup
#
#   Data attributes:
#     day_mon
#     day_tue
#     day_wed
#     day_thu
#     day_fri
#     day_sat
#     day_sun
#
#   Mail timeout related code:
#     how_long_til_purge
#     full_days
#     periodic_letter_purge
#     purge_old_letters
#     move_to_next_mailbox 
#     grab_letters
#
###############################################################################

# Nuke attributes no longer needed

&GENERIC_INFO_RECORD #3480=
-
&GENERIC_MAILBOX #3480=
-
&PROCESS_INFO_RECORD #3480=
-



&ADD_MAILBOX #3480 = 
#
# Stuff the mailbox on the mailboxes_* attribute.  This is not
# time critical since it is only used for the +mail status
# commands.
#

  @swi 

    [setq(0, v(mailboxes_num_of_attributes))]
    [setq(1, add(1, v(mailboxes_num_of_attributes)))]

  gt(strlen(v(mailboxes_[r(0)])), v(overflow_point)) = 1, 
  {
    &mailboxes_num_of_attributes me = r(1); 
    &mailboxes_[r(1)] me = [v(mailboxes_[r(1)])] %0
  }, 
  {
    &mailboxes_[r(0)] me = sort([v(mailboxes_[r(0)])] %0, d)
  }

-
&MAKE_MAILBOX #3480=
#
# PURPOSE:
#
#   Make a mailbox.  This is a helper routine for '+make mailbox for <person>'.
#
# INPUT:
#
#   %0 - name of player to create mailbox for
#   %1 - dbref of invoker
#
# Registers Used:
#
#   0 - dbref of player to make mailbox for
#   1 - 'official' name of player to make mailbox for
#   2 - dbref of newly created mailbox
#

  @swi/first 

    [setq(0, num(*%0))]
    [setq(1, name(r(0)))]

  0 = 

  strmatch(type(r(0)), PLAYER),
  {
    @pemit %1 = [capstr(%0)] is not a player.
  },

  strlen(v(mailbox_[r(0)])),
  {
    @create [r(1)]'s Mailbox; 
    @set [setq(2, con(me))]r(2) = quiet; 
    @drain [r(2)]; 
    @tel r(2) = me; 
    &mailbox_[r(0)] me = r(2); 
    @trigger %vm/add_mailbox = r(2); 
    &owner_dbref [r(2)] = r(0); 
    @startup [r(2)] = {@drain me; @no me}; 
    @set r(2) = safe; 
    &mail-in-progress [r(2)] = false; 
    &current_folder [r(2)] = u(v(mail_system)/get_inbox, r(0)); 
    &folder-list [r(2)] = get(r(2)/current_folder); 
    @no r(2); 

    @pemit %1 = Mailbox created for [r(1)].
  },

  {
    @pemit %1 = [r(1)] already has a mailbox.
  }

-
&MAKE_MAILBOX2 #3480=
-
&DESTROY_MAILBOX #3480=
#
# PURPOSE:
#
#   Destroy a mailbox.  
#   This is a helper routine for '+destroy mailbox for <person>'.
#
# INPUT:
#
#   %0 - name OR dbref of player to destroy mailbox for
#   %1 - dbref of who/what caused this attribute to be invoked
#   %2 - the dbref of the mailbox to destroy, OR a '0' if unknown
#
# Registers Used:
#
#   0 - dbref of player to destroy mailbox for
#   1 - dbref of mailbox to destroy   
#
# CAUTION:
#
#   This routine is extremely anal retentive about removing mailboxes
#   that don't 'look right'.  This is necessary to avoid problems with
#   infinite loops in the timeout code.
#

  @wait me = 
  {

    &mailbox_
      [setq(0, switch(isdbref(%0), 1, %0, num(*%0)))]
      [setq(1, v(mailbox_[r(0)]))]
        [r(0)] me; 

    @swi 

    strlen(r(1)) = 0, 
    {
#
# No mailbox.
#

      @swi %2 = 0,
      {
#
# Invoked by +destroy mailbox for <name>
#
        @pemit %1 = [name(r(0))] does not have a mailbox.; 
        @no me
      },
      {
#
# Called internally.  Bug.  Remove mailbox passed in from list, 
# and flag as an error.
#
        @dolist lnum(v(mailboxes_num_of_attributes)) = 
        {
          &mailboxes_[add(1, ##)] me = 
            s(remove(v(mailboxes_[add(1, ##)]), %2))
        }; 

        @swi 1 = 1, 
        {
          &weird_mailboxes me = [v(weird_mailboxes)] [r(1)]/%2; 
          @no me
        }
      }
    },
    {
 
      @swi 
        and(
          strmatch(get(r(1)/owner_dbref), r(0)),
          or(
            strmatch(%2, 0),
            strmatch(%2, r(1))
          )
        ) = 1,
      {
#
# A mailbox exists for the player name specified and it seems
# to be valid.
#

#
# Go through all received mail and remove it from the source mailboxes.
#

        @dolist u(v(mail_system)/get_all_in_lists, r(1)) = 
        {
          @tr v(mail_system)/remove_letter = 
            u(v(mail_system)/get_src_dbref, r(1), ##), 
            u(v(mail_system)/get_src_num, r(1), ##), 
            get(r(1)/owner_dbref), 
            r(1), 
            ##, 
            %b
        }; 

#
# Go through all outstanding mail and remove it from the destination
# mailboxes.
#

        @dolist get(r(1)/out-list) = 
        {
          @tr v(mail_system)/retract_main = 
            num(me), 
            r(1), 
            ##, 
            %b
        }; 

        @dolist lnum(v(mailboxes_num_of_attributes)) = 
        {
#
# Since we don't know which mailboxes_* attribute the dbref of the
# mailbox resides in, need to try to remove it from all.
#

          &mailboxes_[add(1, ##)] me = 
            s(remove(v(mailboxes_[add(1, ##)]), r(1)))
        }; 

        @swi 1 = 1, 
        {
          @swi 1 = 1, 
          {
            @swi 1 = 1, 
            {
#
# Destroy the mailbox and notify invoker.  Stupid nested @swi's are
# needed to keep the queue correct and allow the above dolists to
# complete before nuking the mailbox.
#

              @destroy/override [r(1)]; 
 
              @pemit %1 = Mailbox for [name(r(0))] has been destroyed.; 

              @no me
            }
          }
        }
      },
      {
#
# Mailbox does not appear valid.  Warn invoker.
#

        @pemit %1 = WARNING: mailbox_[r(0)] on the master mailbox does%b
          not appear to contain the dbref of a mailbox object for the%b
          specified player. Therefore, the 'mailbox' was NOT%b
          destroyed. Someone should look into this. The mailbox has been 
          moved to attribute 'weird_mailboxes' on the Master Mailbox.; 

        @dolist lnum(v(mailboxes_num_of_attributes)) = 
        {
          &mailboxes_[add(1, ##)] me = 
            s(remove(remove(v(mailboxes_[add(1, ##)]), r(1)), %2))
        }; 

        @swi 1 = 1, 
        {
          &weird_mailboxes me = [v(weird_mailboxes)] [r(1)]/%2; 
          @no me
        }
      }
    }
  }

-
@startup #3480 = 
#
# PURPOSE:
#
#   This is the STARTUP for the Master Mailbox.
#
#   It simply resets the semaphore to 'not in use' (-1) and
#   then determines how long until the next periodic letter
#   purge.
#

  @drain me; 
  @no me; 

  @wait u(how_long_til_purge) = @trigger me/periodic_letter_purge

-
&HOW_LONG_TIL_PURGE #3480 =
#
# PURPOSE:
#
#   This is a helper routine for the @startup on the Master Mailbox.
#   It calculates a value in seconds between the current time and
#   the time the next periodic letter purge is scheduled to occur.
#
# Registers Used:
# 
#   0 - current day
#   1 - timeout day
#   2 - current hour converted to minutes
#   3 - timeout hour converted to minutes
#   4 - current minute
#   5 - timeout minute
#   6 - current hour plus minute converted to minutes
#   7 - timeout hour plus minute converted to minute
#

  [setq(0, v(day_[first(time())]))]

  [setq(1, v(day_[mid(v(default_purge_time), 0, 3)]))]

  [setq(2, mul(mid(extract(time(), 4, 1), 0, 2), 60))]

  [setq(3, mul(mid(first(rest(v(default_purge_time))), 0, 2), 60))]

  [setq(4, mid(extract(time(), 4, 1), 3, 2))]

  [setq(5, mid(first(rest(v(default_purge_time))), 3, 2))]

  [setq(6, add(r(2), r(4)))]

  [setq(7, add(r(3), r(5)))]

  switch(

    [eq(r(0), r(1))]+[gt(r(7), r(6))],
    1+1,
      mul(sub(r(7), r(6)), 60),
    1+0,
      sub(604800, mul(sub(r(6), r(7)), 60)),
    add(
      mul(u(full_days, r(0), r(1)), 86400),
      mul(r(7), 60),
      mul(sub(1440, r(6)), 60)
    )
  )

-
#
# These data attributes are used in HOW_LONG_TIL_PURGE and convert
# the names of days of the week into a numeric representation.
#
&DAY_MON #3480=1
-
&DAY_TUE #3480=2
-
&DAY_WED #3480=3
-
&DAY_THU #3480=4
-
&DAY_FRI #3480=5
-
&DAY_SAT #3480=6
-
&DAY_SUN #3480=7
-
&FULL_DAYS #3480 =
#
# PURPOSE:
#
#   This is a helper function for HOW_LONG_TIL_PURGE.
#
#   Get the number of full days between the current day and the desired day.
#   Do not count the current day or the desired day.  For example, there
#   are 5 full days between Tuesday and the following Monday.  There are
#   no full days between Wednesday and Thursday.
#
# INPUT:
#
#   %0 - current day
#   %1 - desired day
#
# OUTPUT:
#
#   The number of full days between the current day and the desired day.
#

  switch(
    gt(%0, %1),
    1,
    add(sub(6, %0), %1),
    sub(sub(%1, %0), 1)
  )

-
&PERIODIC_LETTER_PURGE #3480 = 
#
# PURPOSE:
#
#   Scan through all mailboxes and delete timed out messages.
#   Also, destroy empty mailboxes and mailboxes that no longer
#   belong to a valid player.
#

  @swi v(default_timeout_option) = 0,
  {
#
# Timeout code currently disabled.  Requeue the request just in case they
# turn it on for next time (one week later).
#
    @wait 604800 = @trigger me/periodic_letter_purge
  },
  {
    @trigger me/purge_old_letters = 
      first(v(mailboxes_1)), #3480, 1, 1, v(mailboxes_1)
  }

-
&PURGE_OLD_LETTERS #3480 = 
#
# %0 - dbref of mailbox to purge old letters from
# %1 - dbref of invoker (for testing purposes mainly)
# %2 - which mailboxes_* line is currently being scanned
# %3 - index of which list element in mailboxes_* being worked on
# %4 - actual mailboxes_* line
#
# use @va as temp variable to hold value of TIMEOUT to use as judging criteria
#     @vb as temp variable to hold secs()
#     @vc as temp variable to hold number of letters destroyed
#

#
# Snag the semaphore
#

  @wait me = 
  {

    @swi strmatch(type(get(%0/owner_dbref)), PLAYER) = 0, 
    {
      @tr me/destroy_mailbox = get(%0/owner_dbref), num(me), %0;
      @pemit %1 = Mailbox belongs to dest'ed player.%b Mailbox destroyed.;
      @trigger me/move_to_next_mailbox = %1, %2, %3, %4;
      @va me ; 
      @no me
    }, 

    {
      @pemit %1 = Scanning [name(get(%0/owner_dbref))]'s mailbox for messages 
        which have timed out.; 

      @va me = u(v(mail_system)/grab_timeout_value, get(%0/message_timeout), 
        v(default_timeout_option)); 

      @swi %va = 200000000,
      {
        @pemit %1 = %tTimeout capability disabled.; 
        @trigger me/move_to_next_mailbox = %1, %2, %3, %4; 
        @va me ; 
        @no me
      },
      {
        @vb me = secs(); 
        @vc me = 0; 

        @dolist [iter(get(%0/folder-list), u(grab_letters, %0, ##))] ZZ = 
        {

          @swi/first 1 = 

# Internal letter number

            [setq(0, before(##, ~))]

# Folder name

            [setq(1, after(##, ~))]

# Time Read

            [setq(2, get(%0/in-[r(0)]-time_read))]

# Mail is unread?  1-yes, 0-no

            [setq(3, strmatch(r(2), 0))]

# 'saved' flag set?  1-yes, 0-no

            [setq(4, eq(match(get(%0/in-[r(0)]-flags), S), 0))]

# Mail received longer than 'timeout' ago?  1-yes, 0-no
            [setq(5, 
              gte(
                sub(
                  %vb, 
                  convtime(get(u(get_src_dbref, %0, r(0))/
                    out-[u(get_src_num, %0, r(0))]-time_sent))
                ), 
                %va)
            )]

# Mail read longer than 'timeout' ago?  1-yes, 0-no
            [setq(6, gte(sub(%vb, convtime(r(2))), %va))]

          strmatch(##, ZZ),
          {
            @swi 1 = 1,
            {
# to get things queued right
              @pemit %1 = %t%vc message(s) deleted.; 
              @trigger me/move_to_next_mailbox = %1, %2, %3, %4; 
              @va me ; @vb me ; @vc me ; 
              @no me
            }
          },

          and(r(3), r(4), r(5)),
          {
#
# Letter has not been read, the 'saved' flag is not set, and the letter 
# was received at least 'timeout' time ago.  Delete it.
#

# Increment count of letters deleted.

            @vc me = add(%vc, 1);

            @tr v(mail_system)/remove_letter = 
              u(get_src_dbref, %0, r(0)), 
              u(get_src_num, %0, r(0)), 
              get(%0/owner_dbref), 
              %0, 
              r(0), 
              r(1)
          },

          and(not(r(3)), r(4), r(6)),
          {
#
# Letter has been read but not within 'timeout' time ago.  Delete it.
# (And the 'saved' flag is not set)
#

# Increment count of letters deleted.

            @vc me = add(%vc, 1); 

            @tr v(mail_system)/remove_letter = 
              u(get_src_dbref, %0, r(0)), 
              u(get_src_num, %0, r(0)), 
              get(%0/owner_dbref), 
              %0, 
              r(0), 
              r(1)
          }
        }
      }
    }
  }

-
&GRAB_LETTERS #3480 = 

  iter(get(%0/in-list-%1), ##~%1)

-
&MOVE_TO_NEXT_MAILBOX #3480 = 
#
# %0 - dbref of invoker (needed for debug purposes, debug messages are 
#        only seen if the purge is triggered manually)
# %1 - which mailboxes_* is being dealt with
# %2 - which list element in mailboxes_* was last dealt with
# %3 - actual mailboxes_* list to work on
#

  @wait me = 
  {

    @swi/first 1 = 

    gte(%2, words(%3)), 
    {
      @swi lt(%1, v(mailboxes_num_of_attributes)) = 1,
      {
        @trigger me/move_to_next_mailbox = 
          %0, add(1, %1), 0, v(mailboxes_[add(1, %1)]); 
        @no me 
      },
      {
        @pemit %0 = Purge complete.; 
        @no me; 
        @wait u(how_long_til_purge) = @trigger me/periodic_letter_purge
      }
    },

    {
      @trigger me/purge_old_letters = 
        extract(%3, add(1, %2), 1), 
        %0, 
        %1, 
        add(1, %2), 
        %3; 
      @no me 
    }
  }

-
###############################################################################
#
#                        H e l p e r   R o u t i n e s            
#
###############################################################################
&CHECK_FOR_BAD_CHARS #3482 = 

  comp(pos(%0, r(3)), #-1)

-
&BAD_CHARS #3482 = 

  ' ` * ( ) = [ ] { } % | , < > / ? : ; "

-
&COUNT_UNREAD_LETTERS #3482 =

#
# %0 - mailbox dbref
# %1 - list of letters
#

 words(
   iter(
     %1,
     switch(get(%0/in-##-time_read), 0, ##,)
   )
 )

-
&COUNT_MARKED_LETTERS #3482 = 

#
# %0 - mailbox dbref
# %1 - list of letters
#

 words(
   iter(
     %1,
     switch(match(get(%0/in-##-flags), m), 0, , ##)
   )
 )

-
&COUNT_DELETED_LETTERS #3482 = 

#
# %0 - mailbox dbref
# %1 - list of letters
#

 words(
   iter(
     %1,
     switch(match(get(%0/in-##-flags), d), 0, , ##)
   )
 )

-
&COUNT_SAVED_LETTERS #3482 = 

#
# %0 - mailbox dbref
# %1 - list of letters
#

 words(
   iter(
     %1,
     switch(match(get(%0/in-##-flags), s), 0, , ##)
   )
 )

-
&COUNT_TIMED_OUT_LETTERS #3482 = 

#
# %0 - mailbox dbref
# %1 - list of letters
#

   [setq(4, get(%0/message_timeout))]
   [setq(5, get(%vm/default_timeout_option))]
   [setq(5, div(u(grab_timeout_value, r(4), r(5)), 2))]

 words(
   iter(
     %1,
     switch(
       and(
         eq(match(get(%0/in-##-flags), s), 0), 
         not(strmatch(get(%0/in-##-time_read), 0)), 
         gte(
           sub(secs(), convtime(get(%0/in-##-time_read))), 
           r(5)
         )
       ), 1, ##, )
   )
 )

-
&OK_TO_DEST_MAILBOX #3482 =
#
# %0 - dbref of mailbox
#
# OUTPUT:
#
#   Returns a 1 if it is OK to destroy the mailbox and a zero otherwise.
#

  and(
      eq(words(u(get_all_in_lists, %0)), 0),
      eq(words(get(%0/out-list)), 0),
      strmatch(get(%0/mail-in-progress), false),
      get(%vm/delete_when_empty),
      lte(get(%0/semaphore), 0),
      eq(strlen(get(%0/alias-list)), 0),
      eq(strlen(get(%0/author_filter)), 0),
      eq(strlen(get(%0/subject_filter)), 0),
      eq(strlen(get(%0/vacation)), 0),
      eq(strlen(get(%0/reject_msg)), 0),
      eq(strlen(get(%0/autoforward)), 0)
  )

-
&GET_ALIASES #3478=
-
&GET_ALIASES #3482=
#
# %0 - user input string
# %1 - user's mailbox dbref
# %2 - global mail aliases
# %3 - personal mail aliases for this user
#
# OUTPUT:
#
#   returns a list of aliases in the input string (both personal and global)
#   no commas
#

 setunion(
  iter(
    edit({%0},\\,,%b),
    switch(
      or(
        neq(match(%3, ##), 0),
        neq(match(%2, ##), 0)
      ),
      1, ##
      ,
    )
  ), 
 )

-
&TEST_IF_ALIAS #3478=
-
&TEST_IF_ALIAS #3482=

#
# %0 - item to test to see if it is an alias
# %1 - user's mailbox dbref
#
# OUTPUT:
#
#   returns 'yes' if %0 is an alias in %1's mailbox and 
#   'no' otherwise.
#

  switch(
    or(
      neq(match(get(%1/alias-list), %0), 0),
      neq(match(get(%vm/global-mail-aliases), %0), 0)
    ),
    1, yes
    , no
  )

-
&EXPAND_ALIASES #3478=
-
&EXPAND_ALIASES #3482=
#
# %0 - list of personal and/or global mail aliases
# %1 - dbref of mailbox
# %2 - %b
# %3 - global mail aliases
# %4 - personal mail aliases
#
# OUTPUT:
#
#   Expand a list of personal and/or global mail aliases.  Weed out
#   anything that isn't a dbref.  Also, weed out dbrefs that do not
#   belong to valid players anymore.
#

  iter(
    u(expand_aliases2, %0, %1, %2, %3, %4),
    switch(
      and(isdbref(##), strmatch(type(##), PLAYER)), 
      1, 
      ##, 
    )
  )

-
&EXPAND_ALIASES2 #3478=
-
&EXPAND_ALIASES2 #3482=
#
# Expand a list of personal and/or global aliases into player dbrefs
#
# %0 - list of personal and global mail aliases
# %1 - dbref of user's mailbox
# %2 - list of aliases already expanded (new parameter)
# %3 - list of global mail aliases
# %4 - personal mail aliases
#
# OUTPUT:
#
#   List of dbrefs and possibly also alias names.
#
# Note:  Registers are not used due to the complications of coordinating
# with all the functions/commands that use this function.
#

  iter(
    escape(%0),
      switch(
        [match(%2, ##)]+
        [neq(match(%4, ##), 0)]+
        [neq(match(%3, ##), 0)]
      ,0+1+*,
      {
        [get(%1/alias-##)] 
        [u(expand_aliases,
          u(get_aliases, get(%1/alias-##), %1, 
            get(%vm/global-mail-aliases), %4), 
          %1, 
          %2 ##,
          %3,
          %4
        )]
      }
      ,0+*+1,
      {
        [get(%vm/alias-##)] 
        [u(expand_aliases,
          u(get_aliases, get(%vm/alias-##), %1, 
            get(%vm/global-mail-aliases), %4),
          %1,
          %2 ##, 
          %3, 
          %4
        )]
      }
    ,
    )
  )

-
&PRETTY_ALIASES #3478=
-
&PRETTY_DIST #3482=

#
# %0 - list of aliases, personal and global
# %1 - dbref of mailbox
# %2 - get(%1/alias-list)
# %3 - global aliases
# %4 - player dbrefs
#
# OUTPUT:
#
#   Create a user displayable line identifying which aliases are
#   personal and which are global and a list of player names, all
#   separated by commas.
#

  u(list_names, 
    iter(
      %0 %4,
      switch(
        1,
        sign(match(%2, ##)),
          ##&(personal&mail&alias),
        sign(match(%3, ##)),
          ##&(global&mail&alias),
        strmatch(type(##), PLAYER), 
          edit(name(##), %b, &),
      )
    )
  )

-
&IDENTIFY_TO_LIST #3478=
-
&IDENTIFY_TO_LIST #3482=
#
# Expected input:
#
#   %0 is a list of names input by the user.
#      Names possibly include personal and global aliases and may be
#      separated with commas
#   %1 is the users' mailbox dbref.
#
# Simply extract out the valid player names and convert them into a list
# of dbrefs. Anything that is not a player name or a mail alias is flagged
# as an error.

  trim(
    setunion(
      iter(
        u(identify_to_list2, %0), 
 
        switch(
          1, 
          strmatch(type(*[edit(##, &, %b)]), PLAYER), 
            num(*[edit(##, &, %b)]), 
          strmatch(u(test_if_alias, ##, %1), yes), 
            ,
          ABORTOne$or$more$of$the$destinations$specified$is$not$a$player$or$mail$alias.ENDABORT.
        )
      ),
    ),, %b
  )

-
&IDENTIFY_TO_LIST2 #3482=

  iter({%0}, switch(type(*##), player, edit(##, %b, &), ##), \,)

-
&FORMAT_NAMES #3478=
-
&FORMAT_NAMES #3482=

  u(format_names2, iter(%0, switch(##, #*, ##,)))

-
&FORMAT_NAMES2 #3482=

  switch(
    strlen(%0), 
    0,,
    u(name[gt(words(%0), 1)][gt(words(%0), 0)], %0)
  )

-
&LIST_NAMES #3482=

  switch(
    strlen(%0),
    0,,
    u(list[gt(words(%0), 1)][gt(words(%0), 0)], %0)
  )

-
&SECURE_NAMES #3482=

  switch(
    words(%0), 
    0,, 
    u(secure[gt(words(%0), 1)][gt(words(%0), 0)], %0)
  )

-
&NAME10 #3478=
-
&NAME10 #3482=

  name(%0)

-
&LIST10 #3482=

  and [edit(%0, &, %b)]

-
&SECURE10 #3482=

  and [secure(%0)]

-
&NAME01 #3478=
-
&NAME01 #3482=

  name(%0)

-
&LIST01 #3482=

  edit(%0, &, %b)

-
&SECURE01 #3482=

  secure(%0)

-
&NAME11 #3478=
-
&NAME11 #3482=

  [name(first(%0))], [u(name1[gt(words(%0), 2)], rest(%0))]

-
&LIST11 #3482=

  [edit(first(%0), &, %b)], [u(list1[gt(words(%0), 2)], rest(%0))]

-
&SECURE11 #3482=

  [secure(first(%0))], [u(secure1[gt(words(%0), 2)], rest(%0))]

-
&FREE_NUM #3478=
-
&FREE_NUM #3482=

#
# Find the first (lowest) available free number to use 
#
# %0 - list of numbers
#
# OUTPUT:
#
#   Returns the lowest number that is not currently being used in the
#   input list.  May potentially return a zero.
#

  first(sort(setdiff(lnum(add(words(%0), 1)), %0), N))

-
&EXPAND_LETTER_RANGE #3478=
-
&EXPAND_LETTER_RANGE #3482=

#
# Input parameter parsing for:
#
# +skim, +mark, +unmark, +delete, +undelete, +read, +unread, 
#   +save, +unsave, and +move
#
# %0 is the user specified list of ranges
# %1 is the in-list-<folder> from the user's mailbox
# %2 is the current letter in the user's mailbox
#
# Returned is a list of valid mail messages
#
# Registers used:
#
#   0 - dbref of mailbox
#
# Some games played due to the nasty 30 parameter function call limit.
#

  trim(
   switch(
    [trim(%0)]+[strlen(%1)]+[strlen(%0)]+[gt(%0, 0)], 

#
# Empty folder
#
    *+0+*+*,,

#
# No parameter specified. Default is to use current message.
# If the current letter no longer exists, select a new one.
#
    *+*+0+*,
      switch(match(%1, %2), 0, u(first_unread, r(0)), %2),

# 
# List of numeric characters/ranges assumed
#
    *+*+*+1,
      iter(%0,
        switch(
          1, 

          strmatch(##, *-*), 
            switch(
              or(
                lte(before(##, -), 0),
                gt(after(##, -), words(%1)),
                lt(after(##, -), before(##, -)),
                not(strmatch(sub(before(##, -), 0), before(##, -))),
                not(strmatch(sub(after(##, -), 0), after(##, -)))
              ),
              1,
                ABORTInvalid message range specified.ENDABORT,
              extract(
                %1,
                before(##, -),
                add(sub(after(##, -), before(##, -)), 1)
              )
            ),

          strmatch(##, *..*), 
            switch(
              or(
                lte(before(##, ..), 0),
                gt(after(##, ..), words(%1)),
                lt(after(##, ..), before(##, ..)),
                not(strmatch(sub(before(##, ..), 0), before(##, ..))),
                not(strmatch(sub(after(##, ..), 0), after(##, ..)))
              ),
              1,
                ABORTInvalid message range specified.ENDABORT,
              extract(
                %1,
                before(##, ..),
                add(sub(after(##, ..), before(##, ..)), 1)
              )
            ),

          switch(
            or(
              lte(##, 0),
              gt(##, words(%1)),
              not(strmatch(sub(##, 0), ##))
            ),
            1,
              ABORTInvalid message number specified.ENDABORT,
            extract(%1, ##, 1)
          )
        )
      ),

#
# Author:<name>
#
# (nasty games played here since I normally don't save 'sender', but 
# do for old mail that was converted, so 'old' mail author is obtained
# from -sender field, 'new' mail author is obtained from who stores
# the outgoing letter.
#
    a*:*,
      switch(
        type(*[after(%0, :)]), PLAYER, 
        s(iter(
           %1, 
           switch(
             switch(words(get(u(get_src_dbref, r(0), ##)/
             out-[u(get_src_num, r(0), ##)]-sender)), 0, 
             get(u(get_src_dbref, r(0), ##)/owner_dbref), 
             get(u(get_src_dbref, r(0), ##)/
             out-[u(get_src_num, r(0), ##)]-sender)), 
             num(*[trim(after(%0, :))]), ##)
        )), 
        ABORTAuthor specified is not a player.ENDABORT
     ), 

# 
# S - could be either saved, or subject:<text>
#
    s*, 
      switch(trim(%0), *:*, 

#
# Subject:<text>
#
        s(iter(
           %1, 
           switch(get(u(get_src_dbref, r(0), ##)/out-
             [u(get_src_num, r(0), ##)]-subject), *[trim(after(%0, :))]*, ##)
        )),

#
# Saved
#
        s(iter(%1, switch(match(get(r(0)/in-##-flags), S), 0,,##)))
      ), 


#
# Text:<text>
#
    t*:*,
      s(iter(
         %1, 
         switch(get(u(get_src_dbref, r(0), ##)/
           out-[u(get_src_num, r(0), ##)]-text), *[trim(after(%0, :))]*, ##)
      )),

#
# All
#
    a*, 
      %1,

# 
# First
#
    f*, 
      first(%1),

#
# Previous
#
    p*, 
      switch(
        %2, 
        first(%1),
          ABORTYou have reached the beginning of your mail messages.ENDABORT,
        extract(%1, sub(match(%1, %2), 1), 1)
      ),

# 
# Marked
#
    m*, 
      s(iter(%1, switch(match(get(r(0)/in-##-flags), M), 0,,##))), 

#
# Current
#
# Verify the value for current letter is still valid. If not, determine 
# a new value to use.
#
    c*, 
      switch(match(%1, %2), 0, u(first_unread, r(0)), %2), 

# 
# Unread
#
    u*, 
      s(iter(%1, switch(get(r(0)/in-##-time_read), 0, ##, %b))), 

# 
# Deleted
#
    d*, 
      s(iter(%1, switch(match(get(r(0)/in-##-flags), D), 0,,##))),

#
# Next
#
    n*, 
      switch(
        %2,
        first(revwords(%1)),
          ABORTYou have reached the end of your mail messages.ENDABORT,
        extract(%1, add(match(%1, %2), 1), 1)
      ),

    switch(
      trim(%0), l*, 
#
# Last
#
        first(revwords(%1)), 

# 
# Otherwise, unable to parse input
#
      ABORTInvalid keyword specified.ENDABORT
    )
  ),,%b)

# Note, %b specified as separator character on trim due to bug in trim()
# trim() returns a ( if done on an empty list with blanks

-
&GET_SRC_DBREF #3482 = 
#
# %0 - mailbox dbref
# %1 - internal received message number
#

  first(get(%0/in-%1-location))

-
# The following 2 attributes are for ease of timeout code
&GET_SRC_DBREF #3480 = first(get(%0/in-%1-location))
-
&GET_SRC_NUM #3480 = rest(get(%0/in-%1-location))
-
&GET_SRC_NUM #3482 = 
#
# %0 - mailbox dbref
# %1 - internal received message number
#

  rest(get(%0/in-%1-location))

-
&FORMAT_REQUEST #3478=
-
&FORMAT_REQUEST #3482=

#
# Conversion of user specified input into readable value.
# This is for use in text sent to the user.
#
# Some games played here due to the bloody 30 parameter limit on
# function calls.
#

  switch(
    %0+[strlen(%0)], 
#
# No parameter specified. Default is to use current message.
#
    *+0,
      {%b( current )},

    a*:*,
      {%b( author: [after(%0, :)] )},
 
    s*, 
      {[switch(%0,*:*, {%b( subject: [after(%0, :)] )}, {%b( saved )})]},

    t*:*,
      {[switch(%0,
        te*, {%b( text: [after(%0, :)] )}, 
        {%b( to: [after(%0, :)] )}, )]
      },

    a*, 
      {%b( all )},

    f*, 
      {%b( first )},

    p*, 
      {%b( previous )},

    m*, 
      {%b( marked )},

    c*, 
      {%b( current )},

    u*, 
      {%b( unread )},

    d*, 
      {%b( deleted )},

    l*, 
      {%b( last )},

    n*, 
      {%b( next )},

  )

-
&CONVERT_NUMS #3478=
-
&CONVERT_NUMS #3482=
#
# %0 - list of internal mail numbers to convert
# %1 - list of all letters in current folder (internal numbers)
#
# output - list of external mail numbers
#

  iter(%0, match(%1, ##))

-
&EXPAND_SINGLE_LETTER_RANGE #3478=
-
&EXPAND_SINGLE_LETTER_RANGE #3482=

#
# Input parameter parsing for +reply, +forward and +add note
#
# %0 - user input
# %1 - in-list-<folder> of mailbox
# %2 - current letter for mailbox
#
# Register 0 - dbref of mailbox 
# 

  trim(
    switch(
      %0+1, 

#
# Empty folder
#
      *+[eq(strlen(%1), 0)], 
      ,

#
# No parameter specified. Default is to use current message.
#
      *+[eq(strlen(%0), 0)], 
        switch(match(%1, %2), 0, u(first_unread, r(0)), %2),

#
# User input is multi-word
#
      *+[gt(words(%0), 1)],
        ABORTInput parameter may only be a single word.ENDABORT, 

#
# Range specified (a-b)
#
      *+[strmatch(%0, *-*)], 
        ABORTRange specifier (-) not allowed for this command.ENDABORT, 

#
# Range specified (a..b)
#
      *+[strmatch(%0, *..*)], 
        ABORTRange specifier (..) not allowed for this command.ENDABORT, 

# 
# Numeric character
#
      *+[gt(%0, 0)], 
        switch(
          or(
            gt(%0, words(%1)), 
            not(strmatch(%0, sub(%0, 0)))
          ),
          1,
            ABORTInvalid message number specified.ENDABORT,
          {
            [extract(%1, %0, 1)]
          }
        ),

#
# First
#
      f*, 
        first(%1),

#
# Last
#
      l*, 
        first(revwords(%1)),

#
# Previous
#
      p*, 
        switch(
          %2, 
          first(%1),
            ABORTYou have reached the beginning of your mail messages.ENDABORT,
          extract(%1, sub(match(%1, %2), 1), 1)
        ),

#
# Current
#
      c*, 
        switch(match(%1, %2), 0, u(first_unread, r(0)), %2),

#
# Next
#
      n*, 
        switch(
          %2,
          first(revwords(%1)),
            ABORTYou have reached the end of your mail messages.ENDABORT,
          extract(%1, add(match(%1, %2), 1), 1)
        ),

#
# 
# Otherwise, unable to parse input
#
    ABORTUnrecognized keyword specified.ENDABORT
  ),,%b)

-
&EXPAND_OUTGOING_LETTER_RANGE #3482=

#
# Input parameter parsing for:
#
# +review
#
# %0 is the user specified list of ranges
# %1 is the out-list from the user's mailbox
# %2 is the current 'out' letter in the user's mailbox
# %3 is the dbref of the mailbox
#
# Returned is a list of valid mail messages
#

  trim(
   switch(
    [trim(%0)]+[strlen(%1)]+[strlen(%0)]+[gt(%0, 0)], 

#
# No saved outgoing mail
#
    *+0+*+*,,

#
# No parameter specified. Default is to use current 'out' message.
# If the out_list_current no longer exists, select the most recently
# sent letter.
#
    *+*+0+*,
      switch(match(%1, %2), 0, first(revwords(%1)), %2),

# 
# List of numeric characters/ranges assumed
#
    *+*+*+1,
      iter(%0,
        switch(
          1, 

          gt(strmatch(##, *-*), 0), 
            switch(
              or(
                lte(before(##, -), 0),
                gt(after(##, -), words(%1)),
                lt(after(##, -), before(##, -)),
                not(strmatch(sub(before(##, -), 0), before(##, -))),
                not(strmatch(sub(after(##, -), 0), after(##, -)))
              ),
              1,
                ABORTInvalid message range specified.ENDABORT,
              extract(
                %1,
                before(##, -),
                add(sub(after(##, -), before(##, -)), 1)
              )
            ),

          gt(strmatch(##, *..*), 0), 
            switch(
              or(
                lte(before(##, ..), 0),
                gt(after(##, ..), words(%1)),
                not(strmatch(sub(before(##, ..), 0), before(##, ..))),
                not(strmatch(sub(after(##, ..), 0), after(##, ..)))
              ),
              1,
                ABORTInvalid message range specified.ENDABORT,
              extract(
                %1,
                before(##, ..),
                add(sub(after(##, ..), before(##, ..)), 1)
              )
            ),

          switch(
            or(
              lte(##, 0),
              gt(##, words(%1)),
              not(strmatch(sub(##, 0), ##))
            ),
            1,
              ABORTInvalid message number specified.ENDABORT,
            extract(%1, ##, 1)
          )
        )
      ),

#
# Text:<text>
#
    te*:*,
      s(iter(
         %1, 
         switch(get(%3/out-##-text), *[trim(after(%0, :))]*, ##)
      )),

#
# To:<name>
#
    t*:*,
      switch(
        type(*[after(%0, :)]), PLAYER, 
        s(iter(
           %1, 
           switch(
             match(get(%3/out-##-dist), [num(*[trim(after(%0, :))])]:*), 
             0,, ##))
           ), 
        ABORTName specified is not a player.ENDABORT
     ), 

#
# Subject:<text>
#
    s*:*,
      s(iter(
         %1, 
         switch(get(%3/out-##-subject), *[trim(after(%0, :))]*, ##)
      )),

#
# All
#
    a*, 
      %1,

# 
# First
#
    f*, 
      first(%1),

#
# Previous
#
    p*, 
      switch(
        %2, 
        first(%1),
          ABORTYou have reached the beginning of your mail messages.ENDABORT,
        extract(%1, sub(match(%1, %2), 1), 1)
      ),

#
# Current
#
# Verify the value for current letter is still valid. If not, determine 
# a new value to use.
#
    c*, 
      switch(match(%1, %2), 0, first(revwords(%1)), %2), 

#
# Last
#
    l*, 
      first(revwords(%1)), 

#
# Next
#
    n*, 
      switch(
        %2,
        first(revwords(%1)),
          ABORTYou have reached the end of your mail messages.ENDABORT,
        extract(%1, add(match(%1, %2), 1), 1)
      ), 

# 
# Otherwise, unable to parse input
#
    ABORTInvalid keyword specified.ENDABORT
  ),,%b)

# Note, %b specified as separator character on trim due to bug in trim()
# trim() returns a ( if done on an empty list with blanks

-
&FILTER_MAIL_LIST #3478=
-
&FILTER_LIST #3482=
#
# %0 - list of letters to perform action on - out of order
# %1 - list of letters in mailbox
#
# This is needed due to setunion's irritating habit of sorting lists.
#
# This function will take a list of internal mail numbers and put them
# back in chronological order again.
#

 s(switch(%0, *ABORT*, %0, iter(%1, switch(member(%0, ##), 0, , ##))))

-
&FIRST_UNREAD #3482=
#
# Assumptions - this won't be called when in-list-<folder> is empty.
# Obtain the first unread letter, or if they've all been read,
# return the most current letter.
#
# %0 - dbref of mailbox
#
# Note:  registers not used due to muckiness of figuring out the 
# interdependent usage of registers amongst function calls.
#

 first(
   [iter(u(get_folder_in_list, %0)),
     switch(get(%0/in-##-time_read), 0, %b##%b, %b)
   )]%b
   [first(revwords(u(get_folder_in_list, %0))))]
 )
   
-
&GET_DELETE_OPTION #3478=
-
&GET_DELETE_OPTION #3482=

#
# %0 - user's dbref
#
# If the user has specified a value for this option, use it, otherwise
# use the mail system-wide value
#

    [setq(9, get(%0/mail_config_options))]

  switch(
    1, 

    strmatch(r(9), *soft*), 
      soft, 

    strmatch(r(9), *hard*), 
      hard, 

    get(%vm/default_delete_option)
  )
    
-
&GET_FORMAT_OPTION #3478=
-
&GET_FORMAT_OPTION #3482=

#
# %0 - user's mail_config_options
#
# If the user has specified a value for this option, use it, otherwise
# use the mail system-wide value
#

  switch(
    1, 

    strmatch(%0, *standard*), 
      standard, 

    strmatch(%0, *compact*), 
      compact, 

    get(%vm/default_format_option)
  )

-
&GET_SEPARATOR_OPTION #3482=

#
# %0 - user's dbref
#
# If the user has specified a value for this option, use it, otherwise
# use the mail system-wide value.  
#

    [setq(3, get(%0/mail_config_options))]

  switch(
    1,

    strmatch(r(3), *space*),
      %b,

    strmatch(r(3), *return*),
      %r,

    switch(get(%vm/default_separator_option), space, %b, %r)
  )

-
&GET_INBOX #3482=

#
# %0 - user's dbref
#
# If the user has specified a value for this option, use it, otherwise
# return 'main'.
#

  switch(
    get(%0/mail_config_options), 
    *INBOX*, 
      before(after(get(%0/mail_config_options), INBOX:), :INBOXEND), 
    main
  )

-
&FOLDER_TO_STORE_INTO #3482=

#
# %0 - user's mailbox
# %1 - author
# %2 - subject
# %3 - user's dbref
#
# &author_filter mailbox=dbref|folder~dbref|folder~dbref|folder
# &subject_filter mailbox=text|folder~text|folder~text|folder
#

  first(
    [iter(
      get(%0/subject_filter), 
      switch(strmatch(%2, *[before(##, |)]*), 1, after(##, |)), 
      ~
    )] 
    [iter(
      get(%0/author_filter), 
      switch(strmatch(%1, [before(##, |)]), 1, after(##, |)), 
      ~
    )] 
    [u(get_inbox, %3)]
  )

-
&AUTOFORWARD_TEST #3478=
-
&AUTOFORWARD_TEST #3482=
#
# %0 - dbref of person to determine if an autoforward is set for
#
# Registers used:
#
#   6 - mailbox dbref for %0
#   7 - autoforward
#

    [setq(6, get(%vm/mailbox_%0))]
    [setq(7, get(r(6)/autoforward))]

  switch(
    0, 

    strlen(r(6)), 
#
# destination player has no mailbox, no autoforward
#
    %0,

    strlen(r(7)), 
#
# destination player has a mailbox, but does not have an autoforward specified
#
    %0,

# 
# destination player has a mailbox, and has an autoforward specified
#
    trim(
      setunion(
        [u(snag_dbrefs, r(7))] 
        [u(expand_aliases, r(7), r(6), %b, get(%vm/global-mail-aliases), 
          get(r(6)/alias-list))], 
      )
    )
  )

-
&GET_AUTOFORWARD_OPTION #3478=
-
&GET_AUTOFORWARD_OPTION #3482=

#
# %0 - user's dbref
#

    [setq(7, get(%vm/mailbox_%0))]
    [setq(4, get(r(7)/autoforward))]
    [setq(8, get(%vm/global-mail-aliases))]
    [setq(9, get(r(7)/alias-list))]
    
  switch(
    0, 

    strlen(get(%vm/mailbox_%0)), 
      {Mail will not be autoforwarded},

    strlen(r(4)), 
      {Mail will not be autoforwarded},

    {Mail will be autoforwarded to [u(pretty_dist, u(get_aliases, r(4), 
      r(7), r(8), r(9)), r(7), r(9), r(8), u(snag_dbrefs, r(4)))]
    }
  )

-
&GET_MODE_OPTION #3478=
-
&GET_MODE_OPTION #3482=

#
# %0 - user's dbref
#
# If the user has specified a value for this option, use it, otherwise
# use the mail system-wide value
#

  [setq(9, get(%0/mail_config_options))]

  switch(
    1, 

    strmatch(r(9), *verbose*), 
      verbose, 

    strmatch(r(9), *terse*), 
      terse, 

    get(%vm/default_mode_option)
  )

-
&GET_PERSONAL_ALIASES #3482=

#
# %0 - user's dbref
#

  switch(
    0, 

    strlen(get(%vm/mailbox_%0)), 
      No personal mail aliases defined, 

    strlen(get(get(%vm/mailbox_%0)/alias-list)), 
      No personal mail aliases defined, 

    u(list_names, trim(get(get(%vm/mailbox_%0)/alias-list)))
  )

-
&GET_ACTIVE_FOLDER #3482 =

#
# %0 - mailbox dbref
#

  secure(get(%0/current_folder))

-
&GET_FOLDERS #3482=

#
# %0 - user's dbref
#

  switch(
    0, 

    strlen(get(%vm/mailbox_%0)), 
      secure(u(get_inbox, %0)), 

    u(secure_names, trim(get(get(%vm/mailbox_%0)/folder-list)))
  )

-
&GET_FILTER_COUNT #3482 = 

#
# %0 - user's dbref
#

  switch(
    0, 

    strlen(get(%vm/mailbox_%0)), 
      0, 

    add(
      words(get(get(%vm/mailbox_%0)/author_filter), ~), 
      words(get(get(%vm/mailbox_%0)/subject_filter), ~)
    )
  )

-
&WHICH_IN_LIST #3482 =
#
# %0 - mailbox dbref
#

  in-list-[get(%0/current_folder)]

-
&WHICH_CURRENT_LETTER #3482 =
#
# %0 - mailbox dbref
#

  current_letter-[get(%0/current_folder)]

-
&GET_ALL_IN_LISTS #3482 =
#
# %0 - dbref of mailbox
#

  iter(get(%0/folder-list), get(%0/in-list-##))

-
&GET_FOLDER_IN_LIST #3482 =
#
# %0 - mailbox dbref
#

  get(%0/in-list-[get(%0/current_folder)])

-
&GET_FOLDER_CURRENT_LETTER #3482 =
#
# %0 - mailbox dbref
#

  get(%0/current_letter-[get(%0/current_folder)])

-
&GET_TIMEOUT_OPTION #3478=
-
&GET_TIMEOUT_OPTION #3482=

#
# %0 - user's dbref
#
# If the user has specified a value for this option, use it, otherwise
# use the mail system-wide value
#
# (not too worried about performance on this one, only done on a 
# +show mail options and +mail status for <person>
#

  [setq(5, get(get(%vm/mailbox_%0)/message_timeout))]
  [setq(6, get(%vm/default_timeout_option))]

  switch(
    [strlen(get(%vm/mailbox_%0))]+[strlen(r(5))]+[r(5)],

    0+*+*,
#
# destination player has no mailbox, use system-wide default
#
    switch(
      [strlen(r(6))]+[r(6)], 

      0+*,
      {0 (timeout capability disabled system-wide)},

      *+0,
      {0 (timeout capability disabled system-wide)},

      {[div(r(6), v(seconds_in_day))] days}
    ),

    *+0+*,
#
# destination player has a mailbox, but does not have a timeout specified
# use system-wide default
#
    switch(
      [strlen(r(6))]+[r(6)], 

      0+*,
      {0 (timeout capability disabled system-wide)},

      *+0,
      {0 (timeout capability disabled system-wide)},

      {[div(r(6), v(seconds_in_day))] days}
    ),

    *+*+0,
#
# destination player has a mailbox, has a timeout specified that is 
# set to zero
#
    0 (timeout capability disabled for this mailbox),

#
# destination player has a mailbox, has a timeout specified that is NOT
# zero
#
    {[div(r(5), v(seconds_in_day))] days}
  )

-
@startup #3478 = @wipe me/mail_temp*; @startup me=
-
&GRAB_TIMEOUT_VALUE #3478 =
-
&GRAB_TIMEOUT_VALUE #3482 =
#
# Get the value in seconds for the 'message timeout' for the specified
# mailbox. If there is no timeout for the mailbox, grab the system default.
#
# %0 - message_timeout in mailbox
# %1 - default timeout option for entire mail system
#

  switch(
    0, 

    strlen(%0), 
      switch(
        0, 

        strlen(%1), 
          200000000, 

        %1, 
          200000000, 

        %1
      ),

    %0, 
      200000000,

    %0
  )
    
-
###############################################################################
#
#
#                               HELP TEXT
#
#
###############################################################################
#
#                           C H E C K   M A I L
#
###############################################################################

&CHECK_MAIL_HELP #3481=

  The '+check mail' command may be used to find out if you have unread mail 
  or not.%b This command may be used in a player's @aconnect attribute.

-
###############################################################################
#
#                              S K I M
#
###############################################################################

&SKIM_HELP #3481=

  The '+skim' command, with no parameters, may be used to show a summary 
  display of the mail that is currently in your mailbox. 

  %r%rThe following keywords may be used to limit the output of +skim:

  %r%r%b%ball (default), current, deleted, first, last, marked, next, 
  %r%r%b%bprevious, saved, unread, author:<name>, subject:<text>, 
    text:<text fragment>

  %r%rOnly the first character of the keyword needs to be specified.

  %r%rKey for meaning of symbols on left side of display:
  %r%r'+' - current letter
  %r'M' - marked letter (via +mark)
  %r'D' - marked for deletion letter (via +delete if delete option is 'soft')
  %r'U' - unread
  %r'S' - saved (via +save - will not be timed out and deleted)
  %r'T' - message is getting close to being timed out and automatically deleted
  %r'n' - message has a note registered with it (via +add note)

-
###############################################################################
#
#                              R E A D
#
###############################################################################

&READ_HELP #3481=

  The +read command may be used to read a specific mail message.%r
  +read with no parameters will display a summary status of your 
  mailbox.%b Either a keyword (listed below) or a list of letter 
  numbers as shown from a +read or +skim may also be specified. %b
  Example:%b +read 3 or +read unread.
  
  %r%rThe following keywords are available to specify the scope of +read:

  %r%r%b%ball, current, deleted, first, last, marked, next, previous, 
  saved, unread, author:<name>, subject:<text>, text:<text fragment>

  %r%rOnly the first character of the keyword needs to be specified.

  %r%rThis command also accepts a list of numbers including ranges.%b 
  For example:%b +read 1 3-5 8.%b Either a '-' or '..' may be used to 
  indicate a range specification.

-
###############################################################################
#
#                                U N R E A D          
#
###############################################################################

&UNREAD_HELP #3481=

  The +unread command may be used to mark a letter as being unread again. %b
  If no parameter is specified, the current letter is marked as unread.%b 
  Otherwise, an optional keyword (listed below) or letter number as shown 
  from a +read or +skim may be specified.%b Example:%b +unread 3 or 
  +unread marked.

  %r%rThe following keywords are available to specify the scope of +unread:

  %r%r%b%ball, current, deleted, first, last, marked, next, 
  previous, saved, author:<name>, subject:<text>, text:<text fragment>

  %r%rOnly the first character of the keyword needs to be specified.

  %r%rThis command also accepts a list of numbers including ranges.%b 
  For example:%b +unread 1 3-5 8.%b Either a '-' or '..' may be used to 
  indicate a range specification.

-
###############################################################################
#
#                           A D D   N O T E
#
###############################################################################

&ADD_NOTE_HELP #3481=

  The +add note to <letter # or keyword>=<text> command may be used to store 
  a personal 
  note associated with the letter specified.%b This note will show up on 
  subsequent +read's of this letter.%b It may be just reminders to yourself 
  for what needs to be done to take care of the contents of the letter, or 
  whatever else seems useful.%b Warning, this note is also sent along if the 
  letter it is associated with is forwarded to another player.

  %r%rThe following keywords are available to specify the scope of +add note:

  %r%r%b%bcurrent (default), first, last, next, previous

  %r%rOnly the first character of the keyword needs to be specified.
  
-
###############################################################################
#
#                                N O T E
#
###############################################################################

&NOTE_HELP #3481=

  The +note <text> command may be used to send a short personal mail 
  message to yourself.%b The subject line will be 'Personal Note'.

-
###############################################################################
#
#                              D E L E T E
#
###############################################################################

&DELETE_HELP #3481=

  The +delete command may be used to delete one or all of the messages in 
  your mailbox.%b +delete with no parameters will delete the current message. %b
  Either a keyword (listed below) or a list of letter numbers as shown 
  from a +read or +skim may also be specified.%b Example:%b +delete 3 or 
  +delete marked.
  
  %r%rThe following keywords are available to specify the scope of +delete:

  %r%r%b%ball, current, first, last, marked, next, previous, 
  saved, unread, author:<name>, subject:<text>, text:<text fragment>

  %r%rOnly the first character of the keyword needs to be specified.

  %r%rThis command also accepts a list of numbers including ranges. %b
  For example:%b +delete 1 3-5 8.%b Either a '-' or '..' may be used to 
  indicate a range specification.

-
###############################################################################
#
#                              C L E A R   
#
###############################################################################

&CLEAR_HELP #3481=

  The +clear command may be used to remove one or all of the messages in 
  your mailbox.%b +clear with no parameters will remove the current message. %b
  Either a keyword (listed below) or a list of letter numbers as 
  shown from a +read or +skim may also be specified.%b Example:%b +clear 3 or 
  +clear marked.
  
  %r%rThe following keywords are available to specify the scope of +clear:

  %r%r%b%ball, current, first, last, marked, next, previous, saved, 
  unread, author:<name>, subject:<text>, text:<text fragment>

  %r%rOnly the first character of the keyword needs to be specified.

  %r%rThis command also accepts a list of numbers including ranges.%b 
  For example:%b +clear 1 3-5 8.%b Either a '-' or '..' may be used to 
  indicate a range specification.

-
###############################################################################
#
#                             U N D E L E T E      
#
###############################################################################

&UNDELETE_HELP #3481=

  The +undelete command may be used to remove the 'marked for deletion' flag 
  previously set by a 'soft' delete.%b +undelete with no parameter specified 
  will remove the 'D' flag from the current message.%b Either a keyword (listed 
  below) or a list of letter numbers as shown from a +read or +skim may also 
  be specified.%b Example:%b +undelete 3 or +undelete deleted.
  
  %r%rThe following keywords are available to specify the scope of +undelete:

  %r%r%b%ball, current (default), deleted, first, last, marked, next, 
  previous, saved, unread, author:<name>, subject:<text>, text:<text fragment>

  %r%rOnly the first character of the keyword needs to be specified.

  %r%rThis command also accepts a list of numbers including ranges.%b 
  For example:%b +undelete 1 3-5 8.%b Either a '-' or '..' may be used to 
  indicate a range specification.

-
###############################################################################
#
#                                F L U S H         
#
###############################################################################

&FLUSH_HELP #3481=

  The +flush command may be used to flush (delete) all messages that have 
  been targeted for deletion by doing a soft delete.%b These messages show 
  up with a 'D' next to their number on a +skim.%b There is no way to 
  get these messages back once a +flush has been done.

-
###############################################################################
#
#                             M A R K               
#
###############################################################################

&MARK_HELP #3481=

  The +mark command may be used to tag a message for future operations.%b 
  +mark with no parameter will tag the current message.%b 
  +mark <keyword or list of letters> will tag the specified message(s).

  %r%rThe following keywords are available to specify the scope of +mark:

  %r%r%b%ball, current (default), deleted, first, last, next, previous, 
  saved, unread, author:<name>, subject:<text>, text:<text fragment>

  %r%rOnly the first character of the keyword needs to be specified.

  %r%rThis command also accepts a list of numbers including ranges.%b 
  For example:%b +unmark 1 3-5 8.%b Either a '-' or '..' may be used to 
  indicate a range specification.

  %r%rPossible further operations for the set of marked operations are:%b 
  +delete, +read, +save, +skim, +undelete, +unmark, +unread, +unsave

-
###############################################################################
#
#                             U N M A R K               
#
###############################################################################

&UNMARK_HELP #3481=

  The +unmark command may be used to remove a tag previously set by a 
  call to +mark.%b +unmark with no parameter will clear the 'M' flag on the 
  current message.%b +unmark <keyword or list of letters> will clear the 
  'M' flag on the specified message(s). 

  %r%rThe following keywords are available to specify the scope of +unmark:

  %r%r%b%ball, current (default), deleted, first, last, marked, next, 
  previous, saved, unread, author:<name>, subject:<text>, text:<text fragment>

  %r%rOnly the first character of the keyword needs to be specified.

  %r%rThis command also accepts a list of numbers including ranges.%b 
  For example:%b +unmark 1 3-5 8.%b Either a '-' or '..' may be used to 
  indicate a range specification.

-
###############################################################################
#
#                             S A V E               
#
###############################################################################

&SAVE_HELP #3481=

  The +save command may be used to exclude a message from normal mail 
  timeouts.%b +save with no parameter will set the 'S' flag on the current 
  message.%b +save <keyword or list of letters> will set the 'S' flag on the 
  the specified message(s).

  %r%rThe following keywords are available to specify the scope of +save:

  %r%r%b%ball, current (default), deleted, first, last, marked, next, 
  previous, unread, author:<name>, subject:<text>, text:<text fragment>

  %r%rOnly the first character of the keyword needs to be specified.

  %r%rThis command also accepts a list of numbers including ranges.%b 
  For example:%b +save 1 3-5 8.%b Either a '-' or '..' may be used to 
  indicate a range specification.

-
###############################################################################
#
#                             U N S A V E               
#
###############################################################################

&UNSAVE_HELP #3481=

  The +unsave command may be used to remove a tag previously set by a 
  call to +save.%b +unsave with no parameter will remove the 'S' flag 
  from the current message.%b +unsave <keyword or list of letters> 
  will clear the 'S' flag on the specified message(s). 

  %r%rThe following keywords are available to specify the scope of +unsave:

  %r%r%b%ball, current (default), deleted, first, last, marked, next, 
  previous, saved, unread, author:<name>, subject:<text>, text:<text fragment>

  %r%rOnly the first character of the keyword needs to be specified.

  %r%rThis command also accepts a list of numbers including ranges.%b 
  For example:%b +unsave 1 3-5 8.%b Either a '-' or '..' may be used to 
  indicate a range specification.

-
###############################################################################
#
#                             R E P L Y             
#
###############################################################################

&REPLY_HELP #3481=

  The +reply command may be used to reply to a received mail message.%b There 
  are two forms to this command.%b +reply with no parameter will reply to the 
  last message read.%b +reply <letter # or keyword> will reply to the 
  specified message.%b The destination will be set to where the original 
  letter came from, the subject will be the same as the original letter, with 
  a 'Re: ' prefixed to it.%b You will be prompted for the text of the reply.

  %r%rThe following keywords are available to specify the scope of +reply:

  %r%r%b%bcurrent, first, last, next, previous 

  %r%rOnly the first character of the keyword needs to be specified.

  %r%r+replyall may be used to respond to all recipients of the original 
  mail message.

-
###############################################################################
#
#                             F O R W A R D         
#
###############################################################################

&FORWARD_HELP #3481=

  The +forward command may be used to forward a piece of received mail to 
  a list of destinations.%b There are two available forms to this command.

  %r%r1) +forward \[<letter # or keyword>\] to <list of destinations>

  %r%r%tThis form will immediately forward the specified letter, 
  %r%tincluding any note that has been registered (via +add note).

  %r%r2) +forward <list of destinations>=\[<letter # or keyword>\]

  %r%r%tThis form will allow you to add additional text via '-<text>' 
  %r%tbefore sending the letter (via '--' or '+send').

  %r%rIn both instances, the subject line will be the same as the 
  original letter, with a 'Fwd: ' prefixed to it.

  %r%rThe following keywords are available to specify the scope of +forward:

  %r%r%b%bcurrent, first, last, next, previous 

  %r%rOnly the first character of the keyword needs to be specified.

-
###############################################################################
#
# WRITE related commands:
#
###############################################################################


###############################################################################
#
#                                M A I L         
#
###############################################################################

&MAIL_HELP #3481=

  The +mail subset of commands are split into five logical groups:

  %r%r%b%buser configurable options (+help mail1 or +help mail config)
  %r%b%bwrite-related commands (+help mail2 or +help mail write)
  %r%b%bread-related commands (+help mail3 or +help mail read) and 
  %r%b%bdistribution list-related commands (+help mail4 or +help mail aliases)
  %r%b%bfolder-related commands (+help mail5 or +help mail folders)


  %r%rTo begin writing a piece of mail, the command is:%r%r%b%b
  +mail <name1>\[,\] \[<name2> ...\]=<Subject line text>

  %r%rYou may specify any number of players, personal mail aliases, or%b
  global mail aliases to send the letter to, and a subject line. %b
  Both of these can be changed any time before the letter is actually%b
  sent, using the commands +edit to, and +edit subject.%b Once issued,%b
  the mail system will respond with instructions for writing your letter.
  %r%rNote:%b%bIf the player's names contain spaces, each 
  name should be separated by a comma.%b Example:%b +mail Joe Jones, Jane Smith, 
  wizards=FYI.. 

  %r%rDetailed information may be obtained about the individual mail commands%b
    by doing a +help <mail command>, example, +help set mail option

  %r%r{ %b'+help mail1' for more%b }

-
&MAIL_CONFIG_HELP #3481=

  [get_eval(me/mail1_help)]

-
&MAIL1_HELP #3481=

  %b%bUser configurable mail options:
 
  %r%r%b%b+set mail option delete=hard | soft%b%b(default is soft)
  %r%b%b+set mail option mode=verbose | terse%b%b(default is verbose)
  %r%b%b+set mail option format=standard | compact%b%b(default is standard)
  %r%b%b+set mail option autoforward=<list of people and/or mail aliases>
  %r%b%b+set mail option separator=space | return%b%b(default is space)
  %r%b%b+set mail option inbox=<folder name>%b%b(default is 'main')
  %r%b%b+set mail option vacation=<text>
  %r%b%b+set mail option reject=<text>
  %r%b%b+show mail options

  %r%r%b%bUsers that wish to have a .signature automatically included at the 
  end of %r%b%btheir +mail messages, should set whatever text they want into an 
  attribute %r%b%bcalled MAIL_SIG on themselves.%b Keep in mind that whatever 
  text is used in %r%b%byour MAIL_SIG will impact how much you can send in 
  the normal body of a letter. 
  %r%r%b%bExample:%b &MAIL_SIG me=--%%rObligatory cute .sig here

  %r%r{ %b'+help mail2' for the next page, 
  '+help set mail option' for more details%b }

-
&MAIL_WRITE_HELP #3481=

  [get_eval(me/mail2_help)]

-
&MAIL2_HELP #3481=

  %b%bCommands related to the WRITE side:%r%r
 
  %b%b+mail[space(11)]Begin the mail writing process
  %r%b%b-[space(15)]Used to enter text into the mail body and also to
  %r[space(18)]see available options if specified with no text
  %r%b%b--[space(14)]Same as +send
  %r%b%b+proof[space(10)]Proofread the mail in progress
  %r%b%b+toss[space(11)]Discard the current mail in progress
  %r%b%b+cc[space(13)]Set a carbon copy list
  %r%b%b+bcc[space(12)]Set a blind carbon copy list
  %r%b%b+edit cc[space(8)]Edit the current carbon copy list
  %r%b%b+edit bcc[space(7)]Edit the current blind carbon copy list
  %r%b%b+edit to[space(8)]Edit the destination list
  %r%b%b+edit subject[space(3)]Edit the subject line
  %r%b%b+edit text[space(6)]Edit the main body text
  %r%b%b+set mail flag[space(2)]Set or clear mail flag.%b Current flags 
    available are:
  %r[space(18)]Registered, Urgent, Private and Reply Requested
  %r%b%b+send[space(11)]This command is used once you are satisfied that 
    the mail
  %r[space(18)]is exactly the way you want it, to send it off.
  %r%b%b+retract[space(8)]This command may be used to retract, or delete a
  %r[space(18)]previously sent letter.%b The deletion is done
  %r[space(18)]ONLY if the mail has not been read yet. 
  %r%b%b+review[space(9)]This command may be used to show 
  %r[space(18)]summary or detailed information about one or more 
  %r[space(18)]previously sent letters.
  %r%b%b+status of mail sent%b This command may be used to see the status of%b
  %r[space(18)]mail that you have sent to the named person.
  %r%b%b+note <text>[space(4)]Send a short personal note to yourself

  %r%r{ %b'+help mail3' for the next page, 
  '+help <mail command>' for more details%b }

-
&MAIL_READ_HELP #3481=

  [get_eval(me/mail3_help)]

-
&MAIL3_HELP #3481=

  %b%bCommands related to the READ side:%r%r
 
  %b%b+check mail[space(5)]Tells you if you have any unread mail or not
  %r%b%b+skim[space(11)]Shows you a summary of all your received mail
  %r%b%b+read[space(11)]Read a particular piece of mail
  %r%b%b+unread[space(9)]Mark one or more messages as unread
  %r%b%b+add note[space(7)]Add a personal note to a received piece of mail
  %r%b%b+delete[space(9)]Delete one or more messages in your mailbox
  %r%b%b+undelete[space(7)]Remove the 'marked for deletion' flag from a
  %r[space(18)]previously 'soft' deleted letter.
  %r%b%b+flush[space(10)]Deletes all letters with the 'marked for deletion' flag
  %r%b%b+mark[space(11)]Mark a letter for future operation(s)
  %r%b%b+unmark[space(9)]Remove the 'mark' flag added by a previous +mark
  %r%b%b+save[space(11)]Mark a letter as 'saved' (not to be timed out)
  %r%b%b+unsave[space(9)]Remove the 'saved' flag added by a previous +save
  %r%b%b+reply[space(10)]Reply to a specific letter 
  %r%b%b+replyall[space(7)]Reply to all recipients of a specific letter 
  %r%b%b+forward[space(8)]Forward a specific letter to a list of people

  %r%r{ %b'+help mail4' for the next page, 
  '+help <mail command>' for more details%b }

-
&MAIL_ALIASES_HELP #3481=

  [get_eval(me/mail4_help)]

-
&MAIL4_HELP #3481=

  %b%bCommands related to distribution lists:%r%r

  %b%b+add personal alias <alias>=<list of people>
  %r%b%b+remove personal alias <alias>
  %r%b%b+list personal aliases
  %r%b%b+expand personal alias <alias>
  %r%b%b+edit personal alias <alias>=<old>/<new>

  %r%r%b%b+add global alias <alias>=<list of people>
  %r%b%b+remove global alias <alias>
  %r%b%b+list global aliases
  %r%b%b+expand global alias <alias>
  %r%b%b+edit global alias <alias>=<old>/<new>

  %r%rWhen +mail is addressed to someone, the search order is:
  %rplayer name, personal mail alias, global mail alias
  
  %r%r{ %b'+help mail5' for the next page, 
  '+help <mail command>' for more details%b }

-
&MAIL_FOLDERS_HELP #3481=

  [get_eval(me/mail5_help)]

-
&MAIL5_HELP #3481=

  Folders are a method of organizing your mail.%b All +mail commands 
  operate on the currently selected folder. %bThe folder for all 
  incoming mail is 'main', unless otherwise designated (via +set mail option 
  inbox=<folder name>).%b Folder names can be multi-word and be up 
  to 16 characters in length (besides blanks, characters 
  that are not allowed in attribute names should not be used).

  %r%r%b%bCommands related to folders:%r%r

  %b%b%b%b+add folder <folder name>
  %r%b%b%b%b+remove folder <folder name>
  %r%b%b%b%b+move <list of letters or keyword> to <folder name>
  %r%b%b%b%b+list folders
  %r%b%b%b%b+select folder <folder name>

  %r%rFilters can be used to automatically sort incoming mail into 
  different folders based on author or partial match on subject.

  %r%r%b%b%b%b+add filter author|subject=<name or text> folder=<folder name>
  %r%b%b%b%b+remove filter <number>
  %r%b%b%b%b+list filters

  %r%r%b%bAnd finally, +mail credits and +mail changes

-
###############################################################################
#
#                                   -           
#
###############################################################################

&DASH_HELP #3481=

  The dash command is used like this:%b -<text to add to letter>

  %r%rOnce a letter has been begin, using the +mail or +reply commands, 
  the - command is used to add text to the body of the letter.%b Consecutive 
  - commands append text to the letter in progress (note that a single 
  intervening space is added but no newline). 

  %r%rIssuing a - without any text following it will show the available%b
  options.

  %r%rNote that you may perform any other mush actions while you are 
  entering a message, as long as they do not start with the '-' character.

  %r%rThe standard MUSH substitutions may be used, %%r to insert a 
  carriage return, %%t to insert a tab character, etc (see help 
  substitutions for details).

-
###############################################################################
#
#                               P R O O F       
#
###############################################################################

&PROOF_HELP #3481=

  The +proof command may be used to proofread the mail message you are 
  currently writing.%b It will show all information that is registered for 
  the piece of mail in progress.

-
###############################################################################
#
#                               T O S S 
#
###############################################################################

&TOSS_HELP #3481=

  The +toss command may be used to discard the current mail in progress.

-
###############################################################################
#
#                                C C
#
###############################################################################

&CC_HELP #3481=

  The +cc <list of people> command may be used to add a list of people to 
  carbon copy on the current piece of mail being written.%b The list may 
  include player names, personal aliases and global aliases.

  %r%rNote:%b%bIf the player's names contain spaces, each 
  name should be separated by a comma.%b Example:%b +bcc Joe Jones, Jane Smith, 
  wizards 

-
###############################################################################
#
#                            E D I T   C C
#
###############################################################################

&EDIT_CC_HELP #3481=

  The +edit cc=<old text>/<new text> command may be used to edit the 
  current 'cc' that is registered for this piece of mail (originally 
  registered via the +cc command).%b The standard '^' and '$' may be 
  used for <old text> to prepend and append <new text> respectively. 

  %r%rNote:%b the resultant 'cc' list is checked to verify that all members 
  of the list are valid players, a personal mail alias or a global mail alias.

-
###############################################################################
#
#                               B C C
#
###############################################################################

&BCC_HELP #3481=

  The +bcc <list of people> command may be used to add a list of people to 
  blind carbon copy on the current piece of mail being written.%b What this 
  means is, the people on the 'to' list of the mail, will not be aware that 
  the mail has also been sent to whoever is specified on the 'bcc' list.%b 
  Also, on the receiving end, a +read of the letter will only show the reader 
  a line for 'bcc' if that person is on it, and it will only show that person, 
  not anyone else who is on the 'bcc' list for that piece of mail. 

  %r%rThe list may include player names, personal aliases and global aliases.
  %r%rNote:%b%bIf the player's names contain spaces, each 
  name should be separated by a comma.%b Example:%b +bcc Joe Jones, Jane Smith, 
  wizards 

-
###############################################################################
#
#                            E D I T   B C C
#
###############################################################################

&EDIT_BCC_HELP #3481=

  The +edit bcc=<old text>/<new text> command may be used to edit the 
  current 'bcc' that is registered for this piece of mail (originally 
  registered via the +bcc command).%b The standard '^' and '$' may be 
  used for <old text> to prepend and append <new text> respectively. 

  %r%rNote:%b the resultant 'bcc' list is checked to verify that all members 
  of the list are valid players, a personal mail alias or a global mail alias. 

-
###############################################################################
#
#                            E D I T   T O 
#
###############################################################################

&EDIT_TO_HELP #3481=

  The +edit to=<old text>/<new text> command may be used to edit the 
  current 'to' that is registered for this piece of mail (originally 
  registered via the +mail command).%b The standard '^' and '$' may be 
  used for <old text> to prepend and append <new text> respectively. 

  %r%rNote:%b the resultant 'to' list is checked to verify that all members of 
  the list are valid players, a personal mail alias or a global mail alias.

-
###############################################################################
#
#                        E D I T   S U B J E C T                     
#
###############################################################################

&EDIT_SUBJECT_HELP #3481=

  The +edit subject=<old text>/<new text> command may be used to edit the 
  current 'subject' that is registered for this piece of mail (originally 
  registered via the +mail command).%b The standard '^' and '$' may be 
  used for <old text> to prepend and append <new text> respectively.

-
###############################################################################
#
#                            E D I T   T E X T 
#
###############################################################################

&EDIT_TEXT_HELP #3481=

  The +edit text=<old text>/<new text> command may be used to edit the 
  current mail body that is registered for this piece of mail (originally 
  registered via use of the '-<text>' command).%b The standard '^' and '$' 
  may be used for <old text> to prepend and append <new text> respectively.

-
###############################################################################
#
#                         S E T   M A I L   F L A G
#
###############################################################################

&SET_MAIL_FLAG_HELP #3481=

  The +set mail flag <flag> or +set mail flag !<flag> may be respectively 
  used to set and clear flags associated with this piece of mail.%r%r
 
  The current flags available are:%r%r%t

      URGENT (U) %r%r%t%t

        Assigns an urgent priority to the mail%r%r%t

      REPLY REQUESTED (RR) %r%r%t%t

        Indicates the sender wishes a reply from the receiver of %r%t%t
        the mail%r%r%t

      PRIVATE (P) %r%r%t%t

        Indicates the sender is requesting that the mail contents be %r%t%t
        viewed in a 'for your eyes only' mode by the receiver%r%r%t

      REGISTERED (R) %r%r%t%t

        Perhaps the most intriguing flag.%b Mail sent with this flag %r%t%t
        set will result in a mail message being sent back to the %r%t%t
        originator when the person the mail was addressed to reads it.%r%t%t
        This 'receipt notification' mail will tell you the date and %r%t%t
        time the mail was read by the recipient, in addition to the%r%t%t
        date and time of the original mail and the subject line.

-
###############################################################################
#
#                                S E N D         
#
###############################################################################

&SEND_HELP #3481=

  The +send command may be used to send the current mail in progress off to 
  the previously established list of destinations.%b (Note:%b '--' has the%b
  same functionality as +send).

-
###############################################################################
#
#                             R E T R A C T   
#
###############################################################################

&RETRACT_LETTER_HELP #3481=
-
&RETRACT_HELP #3481=

  The '+retract <letter or keyword>' command may be used to retract, or 
  in other words, delete a letter you have previously sent but changed 
  your mind about.%b You can only retract a letter if no one on the 
  distribution list has read it or deleted it yet.

  %r%rThe following keywords may be used to specify the scope of +retract:%b 

  %r%r%b%bfirst, next, previous, last, current

  %r%rRelated commands:%b +review, +status of mail sent to <person>

-
###############################################################################
#
#                               R E V I E W 
#
###############################################################################

&REVIEW_LETTER_HELP #3481=
-
&REVIEW_HELP #3481=

  The '+review' command may be used to show a summary list of all letters 
  that you have previously sent that have not been deleted yet.%b 

  %r%rThe '+review <letter or keyword>' command may be used to show 
  detailed information about one or more previously sent letters.%b 
  
  %r%rThe following keywords may be used to specify the scope of +review:

  %r%r%b%ball, current, first, last, next, previous, to:<name>, subject:<text>, 
    text:<text fragment>

  %r%rFor example, to review all letters that you have sent to Brandy, 
  do a '+review to:Brandy'.

  %r%rRelated commands:%b +retract, +status of mail sent to <person>

-
###############################################################################
#
#           S T A T U S   O F   M A I L   S E N T   T O   <P E R S O N>
#
###############################################################################

&STATUS_OF_MAIL_SENT_HELP #3481=

  The '+status of mail sent to <person>' command may be used to see the%b
  status of any mail messages from you in <person>'s mailbox.%b If the message%b
  has been read, it will show you the date and time, if it has not been read,%b
  it will simply say 'Message has not been read'.%b The display shows you the%b
  subject line of the original mail message and the time it was sent. %b
  Obviously, once the mail has been deleted from the system, status for 
  that letter will no longer be shown.

  %r%rRelated commands:%b +review, +retract
-

###############################################################################
#
#       C O N F I G U R A T I O N   A N D   A D M I N I S T R A T I O N
#
###############################################################################

###############################################################################
#
#                            M A I L   S T A T U S                           
#
###############################################################################

&MAIL_STATUS_HELP #3481=

  The '+mail status' command may be used to obtain summary information 
  about all mailboxes.%b Information shown includes:%b dbref, person who the 
  mailbox is for, if mail is in progress, how many letter have been 
  received total, how many letters are currently stored in the 
  mailbox, how many aliases are defined, how many folders are defined, 
  and how many filters are defined.%b This command is slow, but 'queue nice'.

  %r%rYou may also do a +mail status for <person>, which shows 
  the more detailed information for a specific player.
  %b Example:%b%b+mail status for brandy. 

  %r%rYou may also do a '+mail status > <number>' to 
  show all mailboxes who have greater than <number> messages stored.%b 
  Example:%b +mail status > 100.

  %r%rOr, '+mail status < <number>' to show all mailboxes who have less%b
  than the <number> messages stored.%b Example:%b +mail status < 1 to see all%b
  empty mailboxes.

  %r%rOr, '+mail status bad sem*' to show only those mailboxes who have 
  a semaphore that is not -1.

-
###############################################################################
#
#                        M A K E   M A I L B O X                               
#
###############################################################################

&MAKE_MAILBOX_HELP #3481=

  The '+make mailbox for <name>' command is used to create a mailbox for a 
  player who does not currently have one.%b It sets up all the necessary 
  information in the new mailbox as well as all the administrative data in 
  the master mailbox.

-
###############################################################################
#
#                        D E S T R O Y   M A I L B O X                     
#
###############################################################################

&DESTROY_MAILBOX_HELP #3481=

  The '+destroy mailbox for <name>' command is used to destroy a mailbox for a 
  specific player.%b It destroys the mailbox and updates all the relevant 
  administrative data in the master mailbox.

  %r%rYou can also '+destroy mailbox for <dbref>', where the dbref%b
  specified is the dbref of a player, either currently existing or%b
  destroyed.%b If a mailbox exists for the dbref specified, all administrative%b
  information is cleaned up and the mailbox is destroyed.%b Some attempt is%b
  made to verify that what is destroyed actually IS a mailbox.

  %r%rCAUTION:%b All mail previously sent by <name> which is still outstanding 
  in the system is removed!%b It is very important to NOT destroy mailboxes 
  by @dest, but to use this command instead.

-
###############################################################################
#
#                   + M A I L   C O N F I G U R A T I O N             
#
###############################################################################

&MAIL_CONFIGURATION_HELP #3481=

  The '+mail configuration' command shows the current values for the 
  mail global configuration options.

  %r%rDefaults shown:
  %r%b%bdestroy
  %r%b%bdelete
  %r%b%bmode
  %r%b%bformat
  %r%b%bsave
  %r%b%bseparator
  %r%b%btimeout
  %r%b%bpurge

  %r%rAlso shown:

  %r%b%bValues for various notification text shown to the user.

  %r%b%bStatus information:%b how many global mail aliases are defined, 
  how many mailboxes are in the system, and how many attributes are currently 
  being used to store the list of mailboxes.

-
###############################################################################
#
#           + S E T   M A I L   O P T I O N   D E S T R O Y   
#
###############################################################################

&SET_MAIL_OPTION_HELP #3481=

  The '+set mail option <option>=<value>' command may be used to set 
  various personal, and global (if you're a wizard) mail options.%b The 
  current options are:%r%r

  %b%b'delete', with possible values of 'hard (h)' or 'soft (s)'%r
  %b%b'destroy', which takes a simple boolean value%r
  %b%b'mode', with possible values of 'verbose (v)' or 'terse (t)'%r
  %b%b'format', with possible values of 'standard (s)' or 'compact (c)'%r
  %b%b'separator', with possible values of 'space (s)' or 'return (r)'%r
  %b%b'inbox', which takes a folder name%r
  %b%b'vacation', which takes a text string%r
  %b%b'reject', which takes a text string%r
  %b%b'autoforward', specify either no text at all to clear it, or the name 
  of a player to have all your mail autoforwarded to.%r
  %b%b'timeout', specify a value in days after which mail will expire and 
  be automatically destroyed.%r

  %r{%b '+help set mail option2' for more %b}

-
&SET_MAIL_OPTION2_HELP #3481=

  The 'delete' option specifies the action taken if a letter is deleted.%b 
  If the option is set to 'hard', a deleted letter is immediately deleted.%b 
  If the option is set to 'soft', a deleted letter is simply marked for 
  deletion and may be restored with '+undelete <letter>'.%b A letter marked for 
  deletion will still show up in a +skim display, with a 'D' next to the 
  letter number.%b The +flush command may be used to force letters marked for 
  deletion to actually go away.%b The default value for this option is 'hard'. 

  The 'destroy' option is used to set whether mailboxes will automatically be 
  destroyed when they become empty.%b true, t, yes, on or 1 all mean that 
  mailboxes WILL be automatically deleted when they become empty.%b false, f, 
  no, off or 0 all mean that mailboxes will NOT be automatically deleted when 
  they become empty.%b Mailboxes are always automatically created as needed.%b 
  This should be invisible to the user.%b This is a wizard-only settable 
  option.%r%r 

  The 'mode' option is used to specify how much 'helpful' information is 
  shown to the user of the mail system.%b The default mode is 'verbose'.%b Once 
  a user becomes fluent in the usage of the mail system, setting their mail 
  option mode to 'terse' will shorten the messages seen when using the system. 

  %r%r{%b '+help set mail option3' for more%b }

-
&SET_MAIL_OPTION3_HELP #3481=

  The 'format' option is used to specify the output format of the 
  +mail displays.%b A 'compact' format has extraneous whitespace 
  and bordering lines removed.%b The default is 'standard'.

  %r%rThe 'separator' option is used to specify whether a blank or a carriage
  return is used between text specified via '-<text>'.%b The default 
  is 'space'.

  %r%rThe 'inbox' option is used to specify a folder name for incoming 
  mail to be stored in.%b The default is 'main'.

  %r%r{%b '+help set mail option4' for more%b }

-
&SET_MAIL_OPTION4_HELP #3481=

  The 'vacation' option is used to register text to be sent back to 
  the originator of received +mail.

  The 'reject' option is used to indicate that all incoming +mail 
  should be rejected and to register text to be sent back to 
  the originator.

  %r%rThe 'autoforward' option may be used to have all your mail autoforwarded 
  to another player.%b This can be particularly useful if you have a builder 
  character that you don't necessarily want to log in as very often but you 
  wish to receive any mail directed towards.

  %r%rThe 'timeout' option may be used to set a value different from the 
  mail system-wide value for timeout.%b After a message has not been read 
  for the specified number of days, it will automatically be deleted.%b  
  More specifically, already-read mail that has not been read within the 
  time limit will be deleted and also mail that has not been read but was 
  received longer than the time limit ago will be deleted.%b 
  Syntax is slightly different than for the other options, +set mail 
  option timeout=<number of days> for <player>.%b This is a wizard-only 
  settable option.  
  
-
###############################################################################
#
#                     + S E T   M A I L   D E F A U L T   
#
###############################################################################

&SET_MAIL_DEFAULT_HELP #3481=

  The '+set mail default delete=<value>' command may be used to set 
  the default mail system delete mode.%b Each user may specify their own 
  default for this by using the +set mail option delete command.%b 
  The default delete value is only used if the user has not specified 
  a value.%b Possible values are 'hard' or 'soft'.

  %r%rThe 'delete' default specifies the action taken if a letter is deleted.%b 
  If the option is set to 'hard', a deleted letter is immediately deleted.%b 
  If the option is set to 'soft', a deleted letter is simply marked for 
  deletion and may be restored with '+undelete <letter>'.%b A letter marked for 
  deletion will still show up in a +skim display, with a 'D' next to the 
  letter number.%b The +flush command may be used to force letters marked for 
  deletion to actually go away. 

  %r%rThe '+set mail default mode=<value>' command may be used to set 
  the default mail system help text mode.%b Each user may specify their own 
  default for this by using the +set mail option mode command.%b 
  The default mode value is only used if the user has not specified 
  a value.%b Possible values are 'terse' or 'verbose'.

  %r%rThe '+set mail default format=<value>' command may be used to set 
  the default mal system format mode.%b Each user may specify their own 
  default for this by using the +set mail option format command.%b 
  The default format value is only used if the user has not specified a 
  value.%b Possible values are 'standard' or 'compact'.

  %r%r{%b '+help set mail default2' for more%b }

-
&SET_MAIL_DEFAULT2_HELP #3481=

  The '+set mail default timeout=<number of days>' command may be used 
  to set the default mail system timeout value for messages.%b If a value 
  of zero is used, the timeout capability is disabled.%b Otherwise, the 
  value should be equal to or greater than 7 days.

  %r%rThe '+set mail default purge=<day of week> <hour>:<minute>' command 
  may be used to specify when the (rather time-consuming) letter purge 
  code should run, hopefully during a time when the MUSH is less active.%b 
  Example:%b +set mail default purge=Wednesday 04:00

  %r%rThe '+set mail default separator=<value>' command may be used to set 
  the default mail system separator.%b Each user may specify their own 
  default for this by using the +set mail option separator command.%b 
  The default separator value is only used if the user has not specified a 
  value.%b Possible values are 'space' or 'return'.  This option is used 
  to specify whether a blank or a carriage return is inserted between 
  text added via '-<text>'.

  %r%rThe '+set mail default save=<value>' command may be used to 
  enable or disable the '+save' command.%b Possible values are 'enable' or 
  'disable'.

-
###############################################################################
#
#                  + S H O W   M A I L   O P T I O N S               
#
###############################################################################

&SHOW_MAIL_OPTIONS_HELP #3481=

  The '+show mail options' command may be used to show what your current 
  personal mail options are set to.%b Current options shown are:%b%b
  delete option (soft or hard), mode option (terse or verbose), 
  format option (standard or compact), separator option (space or return), 
  if there is an autoforward set on your mailbox, what the timeout value 
  is in number of days before mail expires, list of personal mail aliases 
  defined, list of folders defined, number of filters defined, 
  vacation text registered, and reject text registered.

-
###############################################################################
#
#       P E R S O N A L   A N D   G L O B A L   M A I L   A L I A S E S
#       in other words, mail distribution lists
#
###############################################################################

###############################################################################
#
#                  + A D D   P E R S O N A L   A L I A S 
#
###############################################################################

&ADD_PERSONAL_ALIAS_HELP #3481=

  The '+add personal alias <alias>=<list of people>' command may be used to 
  associate an alias with a list of people that you wish to commonly send 
  +mail to.%b This way, you can '+mail my_group=status update' rather than 
  having to always specify the list of people.%b The alias must be a single 
  word only, and should not contain any characters which are not allowed 
  in attribute names (ie, no '`!*()=\[\]{}\%|,<>/?:; " well, you get the 
  idea).%b 
  Personal mail aliases may only be used by the person who added the alias.%b 
  If you wish to add a mail alias that may be used by anyone, the command 
  '+add global alias <alias>=<list of people>' should be used instead. 

  %r%rNote:%b%bIf the player's names contain spaces, each 
  name should be separated by a comma.%b Example:%b +add personal 
  alias my_family=
  Joe Jones, Mary Jones, Baby Jones

  %r%rPersonal aliases may refer to other personal aliases defined 
  previously by the user and also any global aliases.

-
###############################################################################
#
#                + L I S T   P E R S O N A L   A L I A S E S  
#
###############################################################################

&LIST_PERSONAL_ALIASES_HELP #3481=

  The '+list personal aliases' command may be used to show the names of 
  personal mail aliases that were previously defined via the '+add 
  personal alias <alias>=<list of people>' command.
 
-
###############################################################################
#
#                + E X P A N D   P E R S O N A L   A L I A S   
#
###############################################################################

&EXPAND_PERSONAL_ALIAS_HELP #3481=

  The '+expand personal alias <alias>' command may be used to show the 
  list of people on the specified personal distribution list which was 
  previously defined via the '+add personal alias <alias>=<list of people>' 
  command.%b You may only expand lists that you own.
 
-
###############################################################################
#
#                 + E D I T   P E R S O N A L  A L I A S
#
###############################################################################

&EDIT_PERSONAL_ALIAS_HELP #3481=

  The +edit personal alias <alias>=<old text>/<new text> command may be%b
  used to edit a personal mail alias previously added with a '+add personal%b
  alias <alias>=<list of people> command.%b The standard '^' and '$' may be%b
  used for <old text> to prepend and append <new text> respectively. 

  %r%rNote:%b the resultant list of people is checked to verify that all members%b
  of the distribution list are valid players or mail aliases.

-
###############################################################################
#
#                + R E M O V E   P E R S O N A L   A L I A S   
#
###############################################################################

&REMOVE_PERSONAL_ALIAS_HELP #3481=

  The '+remove personal alias <alias>' command may be used remove 
  a personal distribution list which was previously defined via the 
  '+add personal alias <alias>=<list of people>' command.%b You may 
  only remove lists that you own.
 
-
###############################################################################
#
#                 + L I S T   G L O B A L   A L I A S E S
#
###############################################################################

&LIST_GLOBAL_ALIASES_HELP #3481=

  The '+list global aliases' command may be used to show the names of 
  global mail aliases that were previously defined via the '+add 
  global alias <alias>=<list of people>' command.%b These aliases may 
  be used by anyone while writing +mail.
 
-
###############################################################################
#
#                    + A D D   G L O B A L   A L I A S
#
###############################################################################

&ADD_GLOBAL_ALIAS_HELP #3481=

  The '+add global alias <alias>=<list of people>' command may be used to 
  associate an alias with a list of people that it is felt many people 
  would wish to send +mail to as a group.%b This way, you can 
  '+mail wizards=question' rather than having to always specify the list 
  of people.%b The alias must be a single word only, and should not contain 
  any characters which are not allowed in attribute names 
  (ie, no '`!*()=\[\]{}\%|,<>/?:; " well, you get the idea).%b 
  Global mail aliases may be used by anyone using the +mail system.%b 
  If you wish to add a personal mail alias that is for your use alone, 
  the command '+add personal alias <alias>=<list of people>' should be 
  used instead. 

  %r%rNote:%b%bIf the player's names contain spaces, each 
  name should be separated by a comma.%b Example:%b +add global alias the_jones=
  Joe Jones, Mary Jones, Baby Jones

  %r%rGlobal aliases may refer to other global aliases defined.

-
###############################################################################
#
#                + E X P A N D   G L O B A L   A L I A S
#
###############################################################################

&EXPAND_GLOBAL_ALIAS_HELP #3481=

  The '+expand global alias <alias>' command may be used to show the 
  list of people on the specified global distribution list which was 
  previously defined via the '+add global alias <alias>=<list of people>' 
  command.%b You may expand any global distribution list.
 
-
###############################################################################
#
#                 + E D I T   G L O B A L   A L I A S
#
###############################################################################

&EDIT_GLOBAL_ALIAS_HELP #3481=

  The +edit global alias <alias>=<old text>/<new text> command may be%b
  used to edit a global mail alias previously added with a '+add global%b
  alias <alias>=<list of people> command.%b The standard '^' and '$' may be%b
  used for <old text> to prepend and append <new text> respectively. 

  %r%rNote:%b the resultant list of people is checked to verify that all 
  members of the distribution list are valid players or global mail aliases.

-
###############################################################################
#
#                + R E M O V E   G L O B A L   A L I A S
#
###############################################################################

&REMOVE_GLOBAL_ALIAS_HELP #3481=

  The '+remove global alias <alias>' command may be used remove 
  a global distribution list which was previously defined via the 
  '+add global alias <alias>=<list of people>' command.%b You may 
  only remove lists that you added.%b Please contact the person who 
  owns the list if you wish it to be changed.%b The 'owner' of the 
  alias shows up in the output of the '+expand global alias <alias>' 
  command.
 
-
###############################################################################
#
#                             F O L D E R S
#
###############################################################################

###############################################################################
#
#                        + A D D   F O L D E R
#
###############################################################################

&ADD_FOLDER_HELP #3481=

  The '+add folder <folder name>' command may be used to 
  create a folder that mail may be moved to 
  (via the '+move <letter(s) or keyword> to <folder name>' command).

  %r%rThe folder name may be multiple words, but is limited to 16 
  characters and should not contain any characters (besides blanks) 
  which are not allowed in attribute names (ie, no '`!*()=\[\]{}\%|,<>/?:; " 
  well, you get the idea).

  %r%rRelated commands:%b%b+remove folder, +select folder, +list folders 
  and +move

-
###############################################################################
#
#                      + R E M O V E    F O L D E R
#
###############################################################################

&REMOVE_FOLDER_HELP #3481=

  The '+remove folder <folder name>' command may be used to 
  remove a folder that was previously defined either by an explicit 
  '+add folder <folder name>' command, or 
  indirectly by a '+move <letter(s) or keyword> to <folder name>' command.

  %r%rThe folder name may be multiple words, but is limited to 16 
  characters and should not contain any characters (besides blanks) 
  which are not allowed in attribute names (ie, no '`!*()=\[\]{}\%|,<>/?:; " 
  well, you get the idea).

  %r%rYou may only remove empty folders.

  %r%rRelated commands:%b%b+add folder, +select folder, +list folders and +move

-
###############################################################################
#
#                              + M O V E
#
###############################################################################

&MOVE_HELP #3481=

  The '+move <letter(s) or keyword> to <folder name>' command may be used to 
  move one or more letters to the specified folder.

  %r%rThe following keywords are available to specify the scope of +move:

  %r%r%b%ball, current (default), deleted, first, marked, last, next, 
    previous, saved, unread, author:<name>, subject:<text>, text:<text fragment>

  %r%rOnly the first character of the keyword needs to be specified.

  %r%rThis command also accepts a list of numbers, including ranges.%b For 
  example:%b%b'+move 1 3-5 8 to things to do'.%b Either a '-' or a '..' may 
  be used to indicate a range specification.

  %r%rThe folder name may be multiple words, but is limited to 16 
  characters and should not contain any characters (besides blanks) 
  which are not allowed in attribute names (ie, no '`!*()=\[\]{}\%|,<>/?:; " 
  well, you get the idea).

  %r%rIf the folder does not exist, it will be created automatically.

  %r%rRelated commands:%b%b+add folder, +remove folder, +select folder 
  and +list folders

-
###############################################################################
#
#                      + L I S T    F O L D E R S
#
###############################################################################

&LIST_FOLDERS_HELP #3481=

  The '+list folders' command may be used to 
  show the names of folders that were previously defined either by an 
  explicit '+add folder <folder name>' command, or 
  indirectly by a '+move <letter(s) or keyword> to <folder name>' command.

  %r%rNext to each folder name, a total of letters stored in that folder 
  is shown.

  %r%rRelated commands:%b%b+add folder, +remove folder, +select folder 
     and +move

-
###############################################################################
#
#                      + S E L E C T    F O L D E R 
#
###############################################################################
&SELECT_FOLDER_HELP #3481=

  The '+select folder <folder name>' command may be used to 
  choose a 'working' folder. %bAll +mail commands work off the 
  currently selected folder.

  %r%rRelated commands:%b%b+add folder, +remove folder, +list folders and +move

-
###############################################################################
#
#                         + A D D    F I L T E R
#
###############################################################################
&ADD_FILTER_HELP #3481=

  The '+add filter author|subject=<name or text> folder=<folder name>' 
  command may be used to add a mail filter.%b Incoming mail can be 
  automatically filtered into different folders based on author 
  or partial match on subject line.

  %r%rThe folder name may be multiple words, but is limited to 16 
  characters and should not contain any characters (besides blanks) 
  which are not allowed in attribute names (ie, no '`!*()=\[\]{}\%|,<>/?:; " 
  etc), and will be created when needed.

  %r%rExamples:  

  %r%r%b%b+add filter author=Brandy folder=ignore

  %r%r[space(4)]All incoming mail from Brandy will be stored in folder 'ignore'. ;)

  %r%r%b%b+add filter subject=interview folder=interviews

  %r%r[space(4)]All incoming mail that has the word 'interview' in its 
  subject line will be stored in folder 'interviews'.

  %r%rRelated commands:%b%b+remove filter and +list filters 

-
###############################################################################
#
#                      + R E M O V E    F I L T E R
#
###############################################################################
&REMOVE_FILTER_HELP #3481=

  The '+remove filter <number>' command may be used to 
  remove a folder that was previously defined by a 
  '+add filter' command.%b The number to use may be obtained 
  by doing a '+list filters' command.

  %r%rRelated commands:%b%b+add filter and +list filters

-
###############################################################################
#
#                      + L I S T    F I L T E R S
#
###############################################################################
&LIST_FILTERS_HELP #3481=

  The '+list filters' command may be used to
  show the names of filters that were previously defined by a 
  '+add filter' command.%b Information shown includes type of 
  filter (author or subject), value to use while filtering (name 
  or partial subject text), and the folder into which mail is 
  stored when it passes that filter. 

  %r%rRelated commands:%b%b+add filter and +remove filter

-
&EDIT_HELP #3481=

  The syntax of the +edit command is:%b 
  +edit <mail part>=<old text>/<new text>, 
  where mail part may be one of the following:%b to, bcc, subject or text.

-
&HELP_HELP #3481=

    The +help command may be used with no parameter to obtain a list of the 
    current set of global commands.%b It may also be used with a single 
    parameter which indicates the name of the global command that more 
    information is desired for.

-
&MAIL_CREDITS_HELP #3481=

    The +mail credits command shows .. well .. credits. \; )

-
&MAIL_CHANGES_HELP #3481=

    The +mail changes command shows the most recent changes to +mail.

-
###############################################################################
#
#            H I S T O R Y of the revision changes for this +mailer
#
###############################################################################
#
# Version 13 updates:
#
#   See notes at the beginning of this file.
#
###############################################################################
#
# Version 12 updates:
#
#   Added setq()/r() usage to improve performance
#
###############################################################################
#
# Version 11 updates:
#
#   New command:
#
#     +replyall [keyword or letter number]
#
#     The following keywords are available to specified the scope of 
#     +replyall:  current (default), first, last, next previous
#
#     This variation of the +reply command will send a response to 
#     all of the people who received the original message.
#
#   New wizard command: 
#
#     +set mail default format = standard | compact 
#
#     Sets the game default is for the format of +mail displays.  
#     Users may specify their own individual default. Installation 
#     default is 'standard'.  'compact' displays have the same
#     information as the 'standard' displays, without the formatting
#     lines and white space.
#
#   New command:  +set mail option format = standard | compact
#
#   Show new 'format' value on the +show mail options command.
#
#   Show new default 'format' value on the +mail configuration command.
#
#   Modified +proof, +show mail options, +review letter, +status of 
#   mail sent, +skim, +read, +list personal aliases, +expand personal alias,
#   +list global aliases, +expand global alias and all admin display commands
#   to use the new 'format' option in determining the format of the displayed 
#   output.
#
###############################################################################
#
# Version 10 updates:
#
#   New wizard-only command:
#
#     +set mail default timeout=<number of days>  
#
#       Sets the number of days before mail messages are timed out and
#       deleted.  (Installation default is 2 weeks). Code to delete
#       timed out messages runs every timeout default divided by 2 days. 
#       For example, since the default timeout is 2 weeks, the code to 
#       delete timed out messages runs once a week.  Or one hour
#       after game startup.
#
#   Show new default 'timeout' value on the +mail configuration command.
#
#   Show 'timeout' value on the +show mail options' command.     
#
#   New wizard-only command:
#
#     +set mail option timeout=<number of days> for <name> 
# 
#       Sets the number of days before mail messages are timed out and 
#       deleted on a specific mailbox, if other than the mail system-wide
#       default is desired.  A value of zero disables the timeout
#       mechanism for the specified mailbox.
#
#   New commands:
#
#     +save [keyword or list of letter numbers]
#
#       Sets the specified letters as not to be timed out
#
#     +unsave [keyword or list of letter numbers]
#
#       Removes the 'S' (saved) flag from the specified letters
#
#   Show new 'S' flag on +skim and +read
#
#   Some performance tweaks
#
#   Added more comments to the code
#
#   Fixed a bug in the handling of registered mail.  It was mishandling if
#   you did a +read that resulted in more than one registered mail being 
#   read.  In some cases, the receipt notification was not being sent 
#   back.
#
# Restructured admin commands to be 'queue nice' (though slower as a 
# result - only one queue entry at a time)  (all +mail status cmds) 
#
# Added '+mail status bad sem*' to show only those mailboxes with
# whacked out semaphores.
#
# Modified +mail status commands to flag mailboxes that are no longer
# associated with a valid player (useful for handling player dests).
#
###############################################################################
#
# Version 9 updates:
#
#   Trimmed excess blanks from attribute lists to make the server happier
#
#   +review letter to <person>
#
#     Use this command to see the text of a letter you have already sent
#     to someone if you want to refresh your mind on what you said (possibly
#     before doing a +retract letter to <person> ;).
#
#   Tweaked +flush to tell you how many messages were deleted and how many
#     remain
#
#   +set mail option autoforward=<person>
#     (I've got a request in to make this be a list of people and to also
#     allow mail aliases - it's a future thing, I haven't gotten to that
#     yet)
#
#   Changed receipt notification to show who letter is from and any flags
#     that are set.
#
###############################################################################
#
# Version 8 updates:
#
# Both personal and global mail aliases may now refer to other aliases
# in addition to player names. (Requested by Marlena of SC)
#
# Added new wizard command: +set mail default delete=hard | soft so the
# administration can configure what the game default is for +delete. Users
# may still specify their own individual defaults of course. Changed the
# default delete option from hard to soft.
#
# Added new wizard command: +set mail default mode=verbose | terse so the
# administration can configure what the game default is for mode. Users
# may still specify their own individual defaults of course. 
#
# Added +mark
# Added +unmark
# Added +mail changes
#
# +mark, +unmark, +delete, +undelete, +read, +unread, +skim now accept the
# following keywords:  all, current, deleted, first, last, marked, next,
# previous, and unread. These commands also accept a list of numbers
# including ranges. For example:  +mark 1 3-5 8. Either a '-' or '..' may be
# used to indicate a range specification.
#
# +reply, +forward, +add note now accept the following keywords:  current,
# first, last, next, previous in addition to letter number.
#
# Allow +cancel letter to be an alias to +retract letter
# Allow +clear to be an alias to +delete
#
# Changed to be more efficient on attribute usage. For example, if the
# internal in-list was 0 2 5 37, the next number to use will be 1 instead
# of 38.
#
# Some minor performance tweaking, i.e., removed a wad'o'extra ['s
#
# fixed some bugs
#
###############################################################################
#
# Version 7 updates:
#
#   Changed to work with player names that contain blanks
#
###############################################################################
#
# Version 6 updates:
#
# Added '+status of mail sent to <person>'
#
# removed the mail-body-in-progress flag. '-' by itself now simply shows
# the available options. Tweaked the verbose/terse messages.
#
# added +edit personal alias <alias>=<old>/<new>
#
# added +edit global alias <alias>=<old>/<new>
#
# (note: any time a +edit <personal or global> alias is done, it automatically
# weeds out the non-players.
#
# fixed bug in +read related to registered mail. It was sending a registered
# response every time a registered mail was read, instead of just the first 
# time.
#
# fixed +edit to, +edit cc and +edit bcc to not force you to enter a
# blank to keep the names separate when using the ^ or $ options.
# ie, used to have to +edit to=$/%bBrandy, now can +edit to=$/Brandy
#
# changed the +mail status summary display to show number of aliases defined
#
# moved the verbose and terse messages onto the mail system object
# and removed all references to the help text module from this file
#
# added a date/time stamp for when the source code was last updated.
# (shows up in +mail credits)
#
# fixed typo in cleanup_forward and cleanup_send which referenced
# master_room instead of mail_system
#
###############################################################################
# Version 5 updates:
#
#   Changed +destroy mailbox for <person> to also accept the dbref of
#   a person, either still around or destroyed.
#
#   Set the mailboxes 'safe' upon creation.
#   Change the destroy mailbox code to use the /override switch
#
#   Cleaned up +mail status, +mail configuration, and destroy mailbox to
#   handle overflow of mailboxes_<whatever>. The make mailbox has handled
#   it all along, but the other ones didn't. Overflow occurs at about
#   600 or so depending on the size of the dbrefs in the list.
#   (to be exact, 557 if all dbrefs are a full 5 digits)
#
#   Added some safety precautions in destroy_mailbox to make sure that
#   a key mail attribute is present in the object before dest'ing it.
#
#   Changed +mail status, +mail status for <person> and +mail status ><num>
#   to show a warning message if it runs across something that doesn't seem
#   to be a valid mailbox.
#
###############################################################################
# Version 4 updates:
#
#   put a blank in between successive -'s. :P 
# 
#   add a pickup_notification attribute (for use in +send, +reply).
#
#   added a forward_notification attribute (for use in +forward).
#
#   Have +check mail and +read tell how many total messages in addition 
#   to how many unread, so they know where to start reading. 
#
#   fixed bug in +add global alias which was referencing %0 instead of %#
#
#   put +add global alias and +remove global alias under semaphore protection
#
#   changed +add global alias and +add personal alias to not allow an alias
#   which is a player's name.
#
#   changed +list global aliases, +list personal aliases, +expand global
#   alias and +expand personal alias to show a warning message if the alias
#   is the name of a player.
#
#   Modified +mail status to show the value of the semaphore for each
#   mailbox to make it easier to identify mailboxes that are potentially
#   hosed.
#
###############################################################################
# Version 3 updates:
#
#   SECURITY changes. Numerous changes were put in to prevent
#   malicious users from doing nasty things like:
#   +mail %[loc(*<player>)%]=whatever
#
#   changed +check mail to tell you how many unread messages you have
#   and also to warn you if a mail message is in progress.
#
#   Also added '--' as an alias for +send.
#
#   Also changed the behavior for a +read with no parameters to do basically
#   the same thing as a +check mail
#
#   Restructured +mail a little so it has the same number of switches before
#   attempting to get the semaphore as '-' and '+send'. This allows attributes
#   on players to include code which does things like 
#   +mail brandy; -stuff; +send
#
###############################################################################
# Version 2 updates:
#
#   +unread <num>, +unread<num> or +unread all
#
#   +cc <list of people>
#   +edit cc=<old text>/<new text>
#
#   +add personal alias <alias>=<list of people>
#   +remove personal alias <alias>
#   +list personal aliases
#   +expand personal alias <alias>
#
#   +add global alias <alias>=<list of people>
#   +remove global alias <alias>
#   +list global aliases
#   +expand global alias <alias>
#
#   changed +mail configuration to show number of global mail aliases
#   changed +mail status for <name> to show number of personal mail aliases
#
#   Modified and enhanced the verbose/terse messages
#
#   added +mail credits
#
#   Some bug fixes and help text improvements (some of which were
#   provided by Zalcor of Singlenesia)
#
#   +reply no longer keeps putting yet another Re: if there is already one
#   there, same thing for +forward.
#
#   added .signature capability. Users that wishes to have a .sig automatically
#     put at the end of their +mail messages, should set whatever .sig they
#     want in an attribute called MAIL_SIG on themselves.
#     example:  &MAIL_SIG me=--%rObligatory cute .sig here
#   (note to admin, you might need to muss about with @attribute permissions
#   on that attribute - also, if this feature is undesired, it is very easy
#   to rip out, just zap a couple lines in &send_command)
#
#   Some performance related changes.
#   (did some munging around with complicating the existing @swi statements
#   to allow me to somewhat reduce some of the nesting levels)
#
###############################################################################
#
# Version 1 - Original Release
#
###############################################################################


#
# At the end here is code to support a +help system and +wizhelp system.
# Since lots of games have their own code to do this, this code is 
# commented out, feel free to use or not use at your discretion.
#
# &GLOBAL_COMMANDS #3481=
# 
#  setunion(
#    [v(global_commands)] 
#    add_filter add_folder add_global_alias add_personal_alias add_note bcc 
#    cc check_mail clear delete edit edit_bcc edit_cc 
#    edit_global_alias edit_personal_alias edit_subject edit_text edit_to 
#    expand_global_alias expand_personal_alias flush forward help 
#    list_filters list_folders list_global_aliases list_personal_aliases 
#    mail_changes mail_config mail_credits mail_folders mail_read 
#    mail_write mail_aliases 
#    mail mail1 mail2 mail3 mail4 mail5 mark move note proof read remove_filter 
#    remove_folder remove_global_alias remove_personal_alias reply 
#    retract review save send skim set_mail_flag set_mail_option 
#    set_mail_option2 set_mail_option3 set_mail_option4 show_mail_options 
#    status_of_mail_sent toss undelete unmark unread unsave
#    , 
#  )
#
-
# &HELP_HELP #3481=
#
#  The +help command may be used with no parameter to obtain a list of 
#  the current set of global commands. It may also be used with a single 
#  parameter which indicates the name of the global command that more 
#  information is desired for. 
#
-
# &help_text #3478=#3481
-
# &HELP_COMMAND #3478=
#
#   $+help *:
# 
#     @swi %0 = -,
#     {
#       @pemit %#= 
#         %r[u(equal_line)]
#         %rHelp text for the dash command:
#         %r[u(dash_line)]
#         %r
#         %r[get_eval(v(help_text)/dash_help)]
#         %r
#         %r[u(equal_line)]%r
#     },
#     {
#       @swi match(get(v(help_text)/global_commands), edit(%0, %b, _)) = 0,
#       {
#         @pemit %# = Sorry, there is no '+%0' global command.
#       },
#
#       @pemit %#=
#         %r[u(equal_line)]
#         %rHelp text for global function +%0:
#         %r[u(dash_line)]
#         %r
#         %r[get_eval(v(help_text)/[edit(%0,%b,_)]_HELP)]
#         %r
#         %r[u(equal_line)]%r
#     }
# 
-
# &HELP_NO_PARAM #3478=
# 
#   $+help:
# 
#     @pemit %#=
#       %r[u(equal_line)]
#       %r
#       %r%b%bThe following global commands are available:
#       %r
#       %r%b%b+mail
#       %r
#       %r%b%bTo obtain further information about any of these commands, do a 
#       %r%b%b+help <command>, example, +help mail
#       %r
#       %r[u(equal_line)]%r
#
-
# &wiz_help_specific_command #3478=
# 
#   $+wizhelp *:
#
#     @swi hasflag(%#, wizard) = 1,
#     {
#       @swi match(get(v(help_text)/wizonly_commands), edit(%0, %b, _)) = 0,
#       {
#         @pemit %# = Sorry, there is no '+%0' wiz command.
#       },
#       {
#         @pemit %# =
#           %r[u(equal_line)]
#           %rHelp text for wiz global function +%0:
#           %r[u(dash_line)]
# 
#           %r%r[get_eval(v(help_text)/[edit(%0, %b, _)]_HELP)]
# 
#           %r%r[u(equal_line)]
#           %r
#       }
#     }
#
-
# &wiz_help_command #3478=
# 
#   $+wizhelp:
# 
#     @swi hasflag(%#, wizard) = 1,
#     {
#       @pemit %#=
#         %r[u(equal_line)]
# 
#         %r%r%b%bThe following wizard-only global commands are available:
# 
#         %r
#         %r%b%b%b%b+destroy mailbox for <name or dbref> 
#         %r%b%b%b%b+mail configuration
#         %r%b%b%b%b+mail status
#         %r%b%b%b%b+mail status > <number of messages>
#         %r%b%b%b%b+mail status < <number of messages>
#         %r%b%b%b%b+mail status bad sem
#         %r%b%b%b%b+mail status for <name>
#         %r%b%b%b%b+make mailbox for <name>
#         %r%b%b%b%b+set mail default delete=hard or soft
#         %r%b%b%b%b+set mail default mode=terse or verbose
#         %r%b%b%b%b+set mail default format=standard or compact
#         %r%b%b%b%b+set mail default save=enabled or disabled
#         %r%b%b%b%b+set mail default separator=space or return
#         %r%b%b%b%b+set mail default timeout=<number of days>
#         %r%b%b%b%b+set mail default purge=<day> <hour>:<minute>
# 
#         %r%r%b%bTo obtain further in formation about any of these 
#           commands, do a 
#         %r%b%b+wizhelp <command>, example, +wizhelp mail status
# 
#         %r%r[u(equal_line)]%r
#     }
# 
-
# &wizonly_commands #3481=
# 
#   setunion(
#     [v(wizonly_commands)] 
#     destroy_mailbox mail_configuration mail_status make_mailbox 
#     set_mail_default
#     , 
#   )
# 
-
# &EQUAL_LINE #3478=repeat(=, 78)
-
# &DASH_LINE #3478=repeat(-, 78)
-
#
# JAVELIN: Blank attributes prevent a child from accessing attribs
# on its parent, and the attempt to clear child attribs above
# leaves them blank instead due to Penn/Tiny differences.
# This rectifies the problem.
#
@dolist lattr(#3478)=@switch hasattrval(#3478,##)=0, {&## #3478}
-
#
# Show the installer what the current +mail configuration is.
#

  +mail configuration

-

# JAVELIN: Log of changes (other than those marked JAVELIN above)
# 1. Changed all "*[*" to "*\[*" throughout
# 2. Changed all "@attrib obj= ;" to "@attrib obj;" 
